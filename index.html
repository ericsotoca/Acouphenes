<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Titre mis à jour pour refléter la finalisation -->
    <title>Acouphènes Zen v1.1 - Gestion & Auto-hypnose</title>
    <style>
        /* --- CSS Intégré --- */

        /* Variables (Thème Clair par défaut) */
        :root {
            --bg-color: #f4f7f9;
            --text-color: #212529; /* Légèrement plus foncé */
            --primary-color: #0056b3; /* Bleu plus soutenu */
            --secondary-color: #5a9a00; /* Vert plus soutenu */
            --accent-color: #ffc107; /* Jaune plus vif */
            --card-bg: #ffffff;
            --border-color: #dee2e6; /* Gris plus standard */
            --input-bg: #ffffff;
            --button-text: #ffffff;
            --link-color: var(--primary-color);
            --disabled-color: #adb5bd; /* Gris pour désactivé */
            --shadow-color: rgba(0, 0, 0, 0.1);
            --danger-color: #dc3545; /* Rouge Bootstrap */
            --success-color: #28a745; /* Vert Bootstrap */
            --info-color: #17a2b8; /* Cyan Bootstrap */
            --warning-color: #ffc107; /* Jaune Bootstrap */
            --light-grey: #f8f9fa; /* Gris très clair */

            --nav-height: 70px;
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-size-base: 16px;
            --line-height-base: 1.6;

            --spacing-xs: 4px;
            --spacing-s: 8px;
            --spacing-m: 16px;
            --spacing-l: 24px;
            --spacing-xl: 32px;

            --border-radius: 4px;
            --shadow: 0 2px 5px var(--shadow-color);
            --focus-outline-color: color-mix(in srgb, var(--primary-color) 50%, transparent);
            --focus-outline-width: 3px; /* Plus visible */
        }

        /* Thème Sombre */
        body.dark-mode {
            --bg-color: #212529; /* Noir doux */
            --text-color: #e9ecef; /* Gris très clair */
            --primary-color: #4dabf7; /* Bleu clair */
            --secondary-color: #94d82d; /* Vert citron */
            --accent-color: #ffd43b; /* Jaune clair */
            --card-bg: #343a40; /* Gris foncé */
            --border-color: #495057; /* Gris moyen */
            --input-bg: #495057;
            --button-text: #212529; /* Texte sombre pour boutons clairs */
            --link-color: var(--primary-color);
            --disabled-color: #6c757d; /* Gris sombre */
            --shadow-color: rgba(0, 0, 0, 0.3);
            --danger-color: #f57782; /* Rouge clair */
            --success-color: #7ee2a1; /* Vert clair */
            --info-color: #6edff6; /* Cyan clair */
            --warning-color: #ffe066; /* Jaune clair */
            --light-grey: #343a40;
            --focus-outline-color: color-mix(in srgb, var(--accent-color) 70%, transparent);
        }

        /* Reset et Styles Globaux */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { font-size: var(--font-size-base); scroll-behavior: smooth; }
        body { font-family: var(--font-main); background-color: var(--bg-color); color: var(--text-color); line-height: var(--line-height-base); transition: background-color 0.3s ease, color 0.3s ease; }
        #app { max-width: 900px; margin: 0 auto; padding: var(--spacing-l); }

        /* Accessibilité: Style de focus visible */
        *:focus-visible {
            outline: var(--focus-outline-width) solid var(--focus-outline-color);
            outline-offset: 2px;
            box-shadow: 0 0 0 var(--focus-outline-width) var(--focus-outline-color);
            border-radius: var(--border-radius); /* Assure que l'outline suit la forme */
        }
        /* Ajustement spécifique pour les inputs/textarea */
         input:focus-visible, textarea:focus-visible, select:focus-visible {
            border-color: var(--primary-color); /* Garde la bordure interne */
         }
         /* Assurer que les boutons n'ont pas d'outline par défaut qui interfère */
         button:focus { outline: none; }


        /* Navigation */
        nav { position: fixed; top: 0; left: 0; width: 100%; background-color: var(--card-bg); box-shadow: var(--shadow); padding: var(--spacing-s) var(--spacing-l); z-index: 1000; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        nav .nav-brand { font-weight: bold; font-size: 1.3em; color: var(--primary-color); text-decoration: none; margin-right: var(--spacing-l); }
        nav ul { list-style: none; display: flex; gap: var(--spacing-m); flex-wrap: wrap; align-items: center; }
        nav a { text-decoration: none; color: var(--link-color); font-weight: 500; transition: color 0.2s ease, background-color 0.2s ease; padding: var(--spacing-s) var(--spacing-m); border-radius: var(--border-radius); }
        nav a:hover, nav a.active { color: var(--button-text); background-color: var(--primary-color); } /* Amélioration contraste hover/active */

        /* Contenu Principal */
        main { min-height: calc(100vh - var(--nav-height) - 120px); /* Ajusté pour footer plus grand */ }
        .content-section { background-color: var(--card-bg); padding: var(--spacing-l); border-radius: var(--border-radius); box-shadow: var(--shadow); margin-bottom: var(--spacing-l); animation: fadeIn 0.5s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Éléments de Formulaire */
        fieldset { border: 1px solid var(--border-color); padding: var(--spacing-m); border-radius: var(--border-radius); margin-bottom: var(--spacing-l); }
        legend { font-weight: 600; padding: 0 var(--spacing-s); color: var(--primary-color); margin-bottom: var(--spacing-m); }
        label { display: block; margin-bottom: var(--spacing-s); font-weight: 500; }
        .radio-group label, .checkbox-group label { display: inline-block; margin-right: var(--spacing-m); font-weight: normal; vertical-align: middle; cursor: pointer; }
        .radio-group input[type="radio"], .checkbox-group input[type="checkbox"] { margin-right: var(--spacing-xs); vertical-align: middle; cursor: pointer; }
        input[type="text"], input[type="number"], textarea, select { width: 100%; padding: var(--spacing-s) var(--spacing-m); margin-bottom: var(--spacing-m); border: 1px solid var(--border-color); border-radius: var(--border-radius); background-color: var(--input-bg); color: var(--text-color); font-size: inherit; transition: border-color 0.2s ease, box-shadow 0.2s ease; }
        input:focus, textarea:focus, select:focus { outline: none; border-color: var(--primary-color); /* Ombre gérée par focus-visible global */ }
        textarea { min-height: 100px; resize: vertical; }
        input[type="range"] { width: calc(100% - 50px); vertical-align: middle; cursor: pointer; margin-bottom: var(--spacing-m); }
        output { display: inline-block; min-width: 30px; text-align: right; font-weight: bold; color: var(--primary-color); vertical-align: middle; margin-left: var(--spacing-s); }

        /* Boutons */
        button, .button { display: inline-flex; /* Pour aligner icônes/texte */ align-items: center; justify-content: center; background-color: var(--primary-color); color: var(--button-text); border: none; padding: var(--spacing-m) var(--spacing-l); border-radius: var(--border-radius); font-size: inherit; font-weight: 500; cursor: pointer; transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease; text-align: center; text-decoration: none; margin-right: var(--spacing-s); margin-bottom: var(--spacing-s); gap: var(--spacing-s); /* Espace entre texte et icône éventuelle */ }
        button:last-child, .button:last-child { margin-right: 0; }
        button:hover, .button:hover { background-color: color-mix(in srgb, var(--primary-color) 85%, black); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); }
        button:active, .button:active { transform: translateY(1px); } /* Effet enfoncé */
        button:disabled, .button:disabled { background-color: var(--disabled-color); color: color-mix(in srgb, var(--text-color) 70%, var(--disabled-color)); cursor: not-allowed; box-shadow: none; transform: none; }
        .button-secondary { background-color: var(--secondary-color); }
        .button-secondary:hover { background-color: color-mix(in srgb, var(--secondary-color) 85%, black); }
        .button-danger { background-color: var(--danger-color); }
        .button-danger:hover { background-color: color-mix(in srgb, var(--danger-color) 80%, black); }
        .button-icon { padding: var(--spacing-s); font-size: 1.2em; line-height: 1; min-width: 40px; /* Assurer taille minimale pour clics */ } /* Pour boutons avec juste une icône */

        /* Utilitaires */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .mt-s { margin-top: var(--spacing-s); } .mt-m { margin-top: var(--spacing-m); } .mt-l { margin-top: var(--spacing-l); }
        .mb-s { margin-bottom: var(--spacing-s); } .mb-m { margin-bottom: var(--spacing-m); } .mb-l { margin-bottom: var(--spacing-l); }
        .mr-m { margin-right: var(--spacing-m); } .ml-m { margin-left: var(--spacing-m); }
        .alert { padding: var(--spacing-m); margin-top: var(--spacing-m); margin-bottom: var(--spacing-m); border-radius: var(--border-radius); border: 1px solid transparent; }
        .alert-info { color: color-mix(in srgb, var(--info-color) 80%, black); background-color: color-mix(in srgb, var(--info-color) 15%, transparent); border-color: color-mix(in srgb, var(--info-color) 30%, transparent); }
        .alert-warning { color: color-mix(in srgb, var(--warning-color) 80%, black); background-color: color-mix(in srgb, var(--warning-color) 25%, transparent); border-color: color-mix(in srgb, var(--warning-color) 40%, transparent); }
        .alert-success { color: color-mix(in srgb, var(--success-color) 80%, black); background-color: color-mix(in srgb, var(--success-color) 15%, transparent); border-color: color-mix(in srgb, var(--success-color) 30%, transparent); }
        .alert-danger { color: color-mix(in srgb, var(--danger-color) 80%, black); background-color: color-mix(in srgb, var(--danger-color) 15%, transparent); border-color: color-mix(in srgb, var(--danger-color) 30%, transparent); }
        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 25px; border-radius: 25px; color: white; z-index: 1001; box-shadow: 0 3px 10px rgba(0,0,0,0.2); opacity: 0; transition: opacity 0.5s ease, bottom 0.5s ease; font-size: 0.95em; text-align: center; }
        .toast-info { background-color: var(--info-color); } .toast-success { background-color: var(--success-color); } .toast-warning { background-color: var(--warning-color); color: #333; } .toast-error { background-color: var(--danger-color); }
        .toast.show { opacity: 1; bottom: 30px; }

        /* Styles spécifiques aux modules */
        /* --- Hypnose --- */
        #hypnose-session .timer { font-size: 2.5em; font-weight: bold; text-align: center; margin: var(--spacing-m) 0; color: var(--secondary-color); font-variant-numeric: tabular-nums; }
        #hypnose-session .progress-bar-container { height: 8px; background-color: var(--border-color); border-radius: 4px; overflow: hidden; margin-bottom: var(--spacing-m); }
        #hypnose-session .progress-bar { height: 100%; width: 0%; background-color: var(--secondary-color); transition: width 0.5s linear; }
        #hypnose-session .session-text { background-color: color-mix(in srgb, var(--bg-color) 95%, var(--text-color)); padding: var(--spacing-m) var(--spacing-l); border-radius: var(--border-radius); min-height: 180px; border-left: 5px solid var(--primary-color); font-size: 1.1em; line-height: 1.7; overflow-y: auto; max-height: 300px; margin-bottom: var(--spacing-l); }
        #hypnose-session .controls { border-top: 1px solid var(--border-color); padding-top: var(--spacing-m); }
        #hypnose-session .controls > div { margin-bottom: var(--spacing-m); display: flex; flex-wrap: wrap; align-items: center; gap: var(--spacing-s) var(--spacing-m); }
        #hypnose-session .controls label { display: inline-block; margin-right: var(--spacing-xs); min-width: 80px; }
        #hypnose-session .controls input[type="range"] { width: 120px; vertical-align: middle; margin-bottom: 0; /* Ajusté car dans flexbox */ }
        #hypnose-session .controls select { width: auto; display: inline-block; vertical-align: middle; margin-bottom: 0; max-width: 180px; /* Empêche le select de voix de devenir trop large */ }
        #hypnose-session .controls .checkbox-group { margin-top: 0; width: 100%; /* Prendre toute la largeur */}
        #hypnose-session .tts-status { font-size: 0.9em; font-style: italic; color: var(--disabled-color); }
        #hypnose-session .session-main-controls { text-align: center; gap: var(--spacing-m); justify-content: center; } /* Classe pour les boutons Start/Pause/Stop */

        /* --- Sons Thérapeutiques --- */
        #favorite-sounds { border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: var(--spacing-m); margin-top: var(--spacing-l); }
        #favorite-sounds legend { margin-bottom: var(--spacing-s); }
        #favorite-sounds-list { display: flex; flex-wrap: wrap; gap: var(--spacing-s); list-style: none; padding: 0; margin-top: var(--spacing-s); }
        #favorite-sounds-list li { display: flex; align-items: center; gap: var(--spacing-xs); background-color: color-mix(in srgb, var(--light-grey) 50%, transparent); padding: var(--spacing-xs) var(--spacing-s); border-radius: var(--border-radius); }
        #favorite-sounds-list .play-fav-btn { background-color: transparent; color: var(--primary-color); padding: var(--spacing-xs); font-weight: bold; border: none; font-size: 0.9em; cursor: pointer; }
        #favorite-sounds-list .delete-fav-btn { background-color: transparent; color: var(--danger-color); padding: var(--spacing-xs); border: none; font-size: 1em; line-height: 1; cursor: pointer; }
        #favorite-sounds-list .delete-fav-btn:hover { color: color-mix(in srgb, var(--danger-color) 70%, black); }

        /* --- Suivi --- */
        #tracking-history ul { list-style: none; padding-left: 0; max-height: 400px; overflow-y: auto; border: 1px solid var(--border-color); padding: var(--spacing-m); border-radius: var(--border-radius); margin-top: var(--spacing-s); }
        #tracking-history li { border-bottom: 1px dashed var(--border-color); padding: var(--spacing-m) 0; margin-bottom: var(--spacing-s); }
        #tracking-history li:last-child { border-bottom: none; margin-bottom: 0; }
        #tracking-history strong { color: var(--primary-color); }
        #tracking-history em { color: color-mix(in srgb, var(--text-color) 70%, var(--bg-color));}
        #tracking-history .controls label, #tracking-chart-container .controls label { margin-right: var(--spacing-s); }
        #tracking-history .controls select, #tracking-chart-container .controls select { width: auto; vertical-align: middle; }
        #tracking-chart-container { margin-top: var(--spacing-l); min-height: 280px; border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: var(--spacing-m); position: relative; }
        #tracking-chart-container svg { display: block; width: 100%; height: 100%; min-height: 240px; }
        .chart-line { fill: none; stroke: var(--secondary-color); stroke-width: 2.5px; }
        .chart-point { fill: var(--primary-color); stroke: var(--card-bg); stroke-width: 1.5px; cursor: pointer; transition: r 0.2s ease; }
        .chart-point:hover { r: 6; }
        .chart-axis { stroke: var(--border-color); stroke-width: 1px; }
        .chart-grid { stroke: var(--border-color); stroke-width: 1px; opacity: 0.3; stroke-dasharray: 2,2; }
        .chart-average-line { stroke: var(--accent-color); stroke-width: 1.5px; stroke-dasharray: 4, 4; } /* Style pour la ligne moyenne */
        .chart-text { font-size: 11px; fill: var(--text-color); text-anchor: middle; }
        .chart-text.axis-label-y { text-anchor: end; }
        .chart-text.axis-label-x { text-anchor: middle; }
        .chart-no-data { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--disabled-color); font-style: italic; }

        /* Footer & Quick Entry */
        footer { text-align: center; padding: var(--spacing-l); margin-top: var(--spacing-xl); font-size: 0.9em; color: color-mix(in srgb, var(--text-color) 60%, var(--bg-color)); border-top: 1px solid var(--border-color); position: relative; padding-bottom: 80px; /* Espace pour quick entry */ }
        #quick-entry-widget { background-color: var(--card-bg); border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: var(--spacing-s) var(--spacing-m); box-shadow: 0 -2px 5px rgba(0,0,0,0.1); position: fixed; /* Ou absolute dans le footer */ bottom: 10px; right: 10px; z-index: 999; display: flex; align-items: center; gap: var(--spacing-s); max-width: calc(100% - 20px); /* Empêche dépassement sur petits écrans */ }
        #quick-entry-widget label { margin-bottom: 0; font-size: 0.9em; }
        #quick-entry-widget input[type="range"] { width: 100px; margin-bottom: 0; }
        #quick-entry-widget output { font-size: 0.9em; min-width: 20px; margin-left: 0; }
        #quick-entry-widget button { padding: var(--spacing-s); font-size: 1.2em; line-height: 1; min-width: auto; margin-bottom: 0; }

        /* Responsive */
        @media (max-width: 768px) {
            nav { padding: var(--spacing-s) var(--spacing-m); justify-content: center; }
            nav .nav-brand { margin-bottom: var(--spacing-s); width: 100%; text-align: center; }
            nav ul { gap: var(--spacing-s); justify-content: center; width: 100%; margin-top: var(--spacing-s); }
            #app { padding: var(--spacing-m); }
            .content-section { padding: var(--spacing-m); }
            input[type="range"] { width: calc(100% - 40px); }
            output { min-width: 25px; }
            #hypnose-session .timer { font-size: 2em; }
            #hypnose-session .controls label { min-width: auto; /* Permet de réduire si besoin */ }
            #hypnose-session .controls input[type="range"] { width: 100px; }
            #quick-entry-widget { bottom: 5px; right: 5px; padding: var(--spacing-xs) var(--spacing-s); }
        }
        @media (max-width: 480px) {
            nav ul { gap: var(--spacing-xs); }
            nav a { padding: var(--spacing-xs) var(--spacing-s); font-size: 0.9em; }
            button, .button { font-size: 0.95em; padding: var(--spacing-s) var(--spacing-m); }
            .chart-text { font-size: 9px; }
            #quick-entry-widget label { display: none; /* Cache le label sur très petit écran */ }
            #quick-entry-widget input[type="range"] { width: 80px; }
        }

        /* Theme Toggle */
        #theme-toggle { cursor: pointer; background: none; border: none; font-size: 1.6em; padding: 0 var(--spacing-s); color: var(--text-color); margin-left: auto; order: 3; }
        @media (max-width: 768px) { #theme-toggle { margin-left: 0; } }

    </style>
</head>
<body>
    <div id="app">
        <nav id="main-nav">
             <a href="#home" class="nav-brand">Acouphènes Zen</a>
            <ul>
                <li><a href="#home" title="Accueil">🏠</a></li>
                <li><a href="#evaluation" title="Évaluation">📝</a></li>
                <li><a href="#hypnose" title="Auto-Hypnose">🧘</a></li>
                <li><a href="#sounds" title="Sons">🔊</a></li>
                <li><a href="#tracking" title="Suivi">📊</a></li>
                <li><a href="#resources" title="Ressources">📚</a></li>
            </ul>
             <button id="theme-toggle" title="Changer le thème">☀️</button>
        </nav>

        <main id="main-content">
            <!-- Contenu injecté ici -->
        </main>

        <footer>
            <!-- Widget d'Entrée Rapide -->
            <div id="quick-entry-widget">
                 <label for="quick-intensity-slider">Intensité:</label>
                 <input type="range" id="quick-intensity-slider" name="quick-intensity" min="0" max="10" value="5" step="1" oninput="document.getElementById('quick-intensity-output').textContent = this.value">
                 <output id="quick-intensity-output">5</output>
                 <button id="quick-intensity-submit" class="button-secondary" title="Noter l'intensité actuelle">💾</button>
            </div>

            <p>Acouphènes Zen &copy; 2025 - Outil de gestion non médical.</p>
            <p style="font-size: 0.8em; margin-top: 5px;"><strong>Important:</strong> Cette application ne remplace pas un avis médical. Consultez un professionnel de santé.</p>
			<p class="more-apps-link"><a href="https://ericsotoca.github.io/" target="_blank" rel="noopener noreferrer">Plus d'Applis ? Cliquez ici !</a></p>
        </footer>
    </div>

    <!-- --- Modèles HTML --- -->

    <template id="template-home">
         <section class="content-section">
            <h1>Bienvenue sur Acouphènes Zen</h1>
            <p class="lead" style="font-size: 1.1em;">Votre compagnon pour mieux comprendre et gérer vos acouphènes au quotidien grâce à l'auto-hypnose et aux sons thérapeutiques.</p>
            <div class="alert alert-warning mt-l mb-l">
                <strong>Avertissement Important :</strong> Acouphènes Zen est un outil d'accompagnement et de gestion. Il n'est pas destiné à diagnostiquer, traiter ou guérir les acouphènes. Consultez <strong>toujours</strong> un médecin ou un spécialiste ORL pour un diagnostic précis et un plan de traitement adapté à votre situation.
            </div>
            <h2 class="mt-l">Comment cette application peut vous aider :</h2>
            <ul>
                <li><strong>Comprendre :</strong> Accédez à des informations claires sur les acouphènes (<a href="#resources">📚 Ressources</a>).</li>
                <li><strong>Évaluer :</strong> Faites une première évaluation de vos acouphènes (<a href="#evaluation">📝 Évaluation</a>).</li>
                <li><strong>Apaiser :</strong> Utilisez des sessions guidées d'auto-hypnose avec lecture vocale optionnelle (<a href="#hypnose">🧘 Auto-Hypnose</a>).</li>
                <li><strong>Masquer :</strong> Générez des sons thérapeutiques et sauvegardez vos favoris (<a href="#sounds">🔊 Sons</a>).</li>
                <li><strong>Suivre :</strong> Tenez un journal, visualisez votre progression et notez rapidement votre intensité (<a href="#tracking">📊 Suivi</a>).</li>
            </ul>
            <h2 class="mt-l">Pour commencer :</h2>
            <p>Nous vous recommandons de commencer par la section <a href="#evaluation">📝 Évaluation</a>. Ensuite, explorez les sessions d'<a href="#hypnose">🧘 Auto-Hypnose</a> ou le <a href="#sounds">🔊 Générateur de Sons</a>.</p>
            <p class="mt-m" style="font-style: italic;">Toutes vos données sont stockées <strong>uniquement sur votre appareil</strong> et ne sont jamais envoyées sur un serveur.</p>
            <div class="text-center mt-l">
                <a href="#evaluation" class="button">Commencer l'évaluation 📝</a>
            </div>
        </section>
    </template>

    <template id="template-evaluation">
         <section class="content-section">
            <h2>📝 Évaluation Initiale des Acouphènes</h2>
            <form id="evaluation-form">
                <p>Ce questionnaire aide à mieux comprendre vos acouphènes et leur impact. Vos réponses sont confidentielles et stockées localement.</p>
                <fieldset class="mb-l">
                    <legend>Caractéristiques</legend>
                    <label for="sound-type">Quel type de son entendez-vous principalement ?</label>
                    <input type="text" id="sound-type" name="sound-type" required placeholder="Ex: Sifflement aigu, bourdonnement...">
                    <label class="mt-m">Le son est-il perçu dans :</label>
                    <div class="radio-group"> <input type="radio" id="ear-left" name="ear-location" value="left"> <label for="ear-left">Oreille G</label> <input type="radio" id="ear-right" name="ear-location" value="right"> <label for="ear-right">Oreille D</label> <input type="radio" id="ear-both" name="ear-location" value="both" checked> <label for="ear-both">Les deux</label> <input type="radio" id="ear-head" name="ear-location" value="head"> <label for="ear-head">Tête</label> </div>
                    <label for="intensity-avg" class="mt-m">Intensité <strong>moyenne</strong> (0-10) ?</label>
                    <input type="range" id="intensity-avg" name="intensity-avg" min="0" max="10" value="5" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>5</output>
                    <label for="variation" class="mt-m">L'intensité varie-t-elle beaucoup ?</label>
                    <select id="variation" name="variation"> <option value="peu">Peu</option> <option value="moderee">Modérément</option> <option value="beaucoup">Beaucoup</option> </select>
                </fieldset>
                 <fieldset class="mb-l">
                     <legend>Impact sur le quotidien (0=aucun, 10=majeur)</legend>
                     <label for="impact-sleep">Impact sur le <strong>sommeil</strong> ?</label>
                    <input type="range" id="impact-sleep" name="impact-sleep" min="0" max="10" value="3" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>3</output>
                     <label for="impact-concentration" class="mt-m">Impact sur la <strong>concentration</strong> ?</label>
                    <input type="range" id="impact-concentration" name="impact-concentration" min="0" max="10" value="3" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>3</output>
                    <label for="impact-mood" class="mt-m">Impact sur l'<strong>humeur</strong> ?</label>
                    <input type="range" id="impact-mood" name="impact-mood" min="0" max="10" value="3" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>3</output>
                     <label for="impact-hearing" class="mt-m">Interférence avec l'<strong>audition</strong> ?</label>
                    <input type="range" id="impact-hearing" name="impact-hearing" min="0" max="10" value="2" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>2</output>
                 </fieldset>
                 <fieldset>
                    <legend>Facteurs d'influence (Optionnel)</legend>
                    <label for="triggers">Ce qui semble <strong>aggraver</strong> :</label>
                    <textarea id="triggers" name="triggers" rows="3" placeholder="Stress, fatigue, bruit, silence..."></textarea>
                     <label for="reducers" class="mt-m">Ce qui semble <strong>atténuer / aider</strong> :</label>
                    <textarea id="reducers" name="reducers" rows="3" placeholder="Bruit de fond, musique, relaxation..."></textarea>
                 </fieldset>
                <div id="evaluation-result" class="mt-l mb-m"></div>
                <button type="submit" class="mt-m">💾 Enregistrer / Mettre à jour</button>
            </form>
        </section>
    </template>

    <template id="template-hypnose">
        <section class="content-section">
            <h2>🧘 Auto-Hypnose Guidée</h2>
            <p>Choisissez une session. Installez-vous au calme. Utilisez des écouteurs si possible.</p>
             <div class="alert alert-info mt-m"> <strong>Conseil :</strong> Activez la lecture vocale (si dispo) pour fermer les yeux. La régularité est la clé. </div>
            <div id="hypnose-menu" class="mt-l">
                <h3 class="mb-m">Sélectionnez une session :</h3>
                <button class="button mb-m" data-session="debutant">Débutant (~10 min)</button>
                <button class="button mb-m" data-session="intermediaire">Intermédiaire (~15 min)</button>
                <button class="button mb-m" data-session="avance">Avancé (~20 min)</button>
            </div>
            <div id="hypnose-session" class="hidden mt-l">
                <h3 id="session-title" class="mb-m"></h3>
                <div class="timer">--:--</div>
                <!-- Barre de progression -->
                <div class="progress-bar-container"><div class="progress-bar" id="session-progress-bar"></div></div>
                <p id="session-step-indicator" class="text-center" style="font-style: italic; margin-bottom: var(--spacing-m);"></p>
                <div class="session-text" id="session-text-content"> <p>Chargement...</p> </div>
                <div class="controls mt-l">
                     <div>
                         <label for="hypno-noise">Bruit fond:</label>
                         <select id="hypno-noise"> <option value="none">Aucun</option> <option value="white">Blanc</option> <option value="pink">Rose</option> <option value="brown">Brun</option> </select>
                         <label for="hypno-volume" class="ml-m">Vol:</label>
                         <input type="range" id="hypno-volume" min="0" max="0.5" step="0.01" value="0.05">
                     </div>
                     <div class="checkbox-group">
                         <input type="checkbox" id="hypno-tts-enable">
                         <label for="hypno-tts-enable">🗣️ Lecture vocale</label>
                         <select id="hypno-voice-select" class="ml-m" title="Choisir la voix (si supporté)"> <option value="">Voix par défaut</option> </select>
                         <span id="tts-status" class="tts-status"></span>
                     </div>
                    <div class="mt-l session-main-controls">
                        <button id="start-session-btn" class="button-secondary" disabled>▶️ Démarrer</button>
                        <button id="pause-session-btn" class="button-secondary hidden" title="Pause">⏸️</button>
                        <button id="resume-session-btn" class="button-secondary hidden" title="Reprendre">▶️</button>
                        <button id="stop-session-btn" class="button-danger hidden" title="Arrêter">⏹️</button>
                    </div>
                </div>
            </div>
        </section>
    </template>

    <template id="template-sounds">
         <section class="content-section">
            <h2>🔊 Générateur de Sons Thérapeutiques</h2>
            <p>Utilisez ces sons pour créer un environnement sonore plus confortable.</p>
             <div class="alert alert-info mt-m"> <strong>Conseil :</strong> Expérimentez. Un volume juste sous le niveau de l'acouphène est souvent recommandé (TRT). </div>

             <!-- Favoris -->
             <fieldset id="favorite-sounds">
                 <legend>❤️ Vos Favoris</legend>
                 <ul id="favorite-sounds-list">
                     <li id="no-favorites-msg">Aucun favori enregistré.</li>
                     <!-- Les favoris seront ajoutés ici par JS -->
                 </ul>
             </fieldset>

            <div class="sound-generator-controls mt-l">
                 <div class="mb-m">
                    <label for="sound-type-select">Type de son :</label>
                     <select id="sound-type-select"> <option value="white">Bruit Blanc</option> <option value="pink">Bruit Rose</option> <option value="brown">Bruit Brun</option> </select>
                 </div>
                <div class="mb-m">
                    <label for="sound-volume">Volume :</label>
                    <input type="range" id="sound-volume" min="0" max="0.7" step="0.01" value="0.1" oninput="this.nextElementSibling.textContent = parseFloat(this.value).toFixed(2)"> <output>0.10</output>
                     <button id="save-favorite-btn" class="button-icon" title="❤️ Enregistrer ce réglage comme favori" style="margin-left: 10px; background-color: var(--accent-color); color: var(--bg-color); padding: 6px 8px;">❤️</button>
                </div>
                 <div class="mb-l">
                    <label for="sound-timer">⏱️ Arrêt auto (min, 0=∞) :</label>
                    <input type="number" id="sound-timer" min="0" step="5" value="0" style="width: 80px; display: inline-block; vertical-align: middle;">
                     <span id="sound-timer-status" style="margin-left: var(--spacing-s); vertical-align: middle; font-style: italic;"></span>
                 </div>
                <div class="mt-l text-center">
                    <button id="play-sound-btn" class="button">▶️ Jouer</button>
                    <button id="stop-sound-btn" class="button-danger hidden">⏹️ Arrêter</button>
                </div>
            </div>
        </section>
    </template>

    <template id="template-tracking">
         <section class="content-section">
            <h2>📊 Suivi Quotidien</h2>
            <p>Notez régulièrement l'intensité pour identifier des tendances.</p>
            <form id="tracking-form" class="mb-l">
                 <fieldset>
                     <legend>Ajouter une entrée</legend>
                     <div class="alert alert-info mb-m">La date/heure actuelles sont enregistrées.</div>
                    <label for="tracking-intensity">Intensité <strong>maintenant</strong> (0-10) ?</label>
                    <input type="range" id="tracking-intensity" name="intensity" min="0" max="10" value="5" step="1" required oninput="this.nextElementSibling.textContent = this.value"> <output>5</output>
                    <label for="tracking-notes" class="mt-m">Notes (optionnel) :</label>
                    <textarea id="tracking-notes" name="notes" rows="3" placeholder="Ex: Stress, fatigue, activités, humeur..."></textarea>
                    <button type="submit" class="mt-m">💾 Ajouter au journal</button>
                 </fieldset>
            </form>
            <hr style="margin: var(--spacing-l) 0; border: none; border-top: 1px solid var(--border-color);">
             <fieldset id="tracking-history" class="mb-l">
                <legend>📓 Historique</legend>
                 <div class="controls mb-m" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--spacing-m);">
                     <label for="history-limit">Afficher :</label>
                     <select id="history-limit"> <option value="10">10 dern.</option> <option value="30" selected>30 dern.</option> <option value="100">100 dern.</option> <option value="all">Toutes</option> </select>
                 </div>
                <p id="history-loading" class="text-center italic">Chargement...</p>
                <ul></ul>
            </fieldset>
             <fieldset id="tracking-chart-container">
                <legend>📈 Graphique d'Évolution</legend>
                <div class="controls mb-m" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--spacing-m);">
                     <label for="chart-limit">Période :</label>
                     <select id="chart-limit"> <option value="7">7 j</option> <option value="30" selected>30 j</option> <option value="90">90 j</option> <option value="all">Tout</option> </select>
                 </div>
                 <div id="tracking-chart"></div>
                 <div id="chart-no-data" class="chart-no-data hidden">Pas assez de données pour afficher le graphique.</div>
            </fieldset>
             <div class="mt-l text-center">
                 <button id="export-data-btn" class="button-secondary" title="Exporter les données en JSON">Exporter (JSON)</button>
                 <button id="export-csv-btn" class="button-secondary" title="Exporter le journal en CSV">Exporter (CSV)</button>
                 <button id="clear-data-btn" class="button-danger" title="Supprimer toutes vos données">🗑️ TOUT Supprimer</button>
             </div>
        </section>
    </template>

    <template id="template-resources">
         <section class="content-section">
            <h2>📚 Ressources Éducatives</h2>
            <p>Mieux comprendre est une étape importante.</p>
             <div class="alert alert-warning mt-m mb-l"> <strong>Rappel :</strong> Infos éducatives, non médicales. Consultez un pro. </div>
            <article class="mb-l">
                <h3>Qu'est-ce que l'Acouphène ?</h3>
                <p>Perception d'un son sans source externe. Symptôme, pas maladie. Causes multiples :</p>
                <ul> <li>Exposition bruit fort</li> <li>Perte auditive (âge)</li> <li>Infections, bouchon</li> <li>Maladies (Ménière...)</li> <li>Traumatismes</li> <li>Médicaments</li> <li>Stress, fatigue</li> <li>Problèmes vasculaires...</li> </ul>
                <p><strong>Consultez un médecin/ORL pour diagnostic.</strong></p>
            </article>
            <article class="mb-l">
                <h3>🧘 L'Auto-Hypnose</h3>
                <p>Technique de relaxation profonde et concentration. Ne supprime pas le son mais aide à :</p>
                <ul> <li>Réduire Stress/Anxiété</li> <li>Modifier la Perception (son neutre, moins intrusif)</li> <li>Détourner l'Attention</li> <li>Améliorer le Sommeil</li> <li>Reprendre du Contrôle</li> </ul>
                <p><strong>Régularité = clé.</strong> Lecture vocale aide.</p>
            </article>
             <article class="mb-l">
                <h3>🔊 Thérapie par le Son</h3>
                <p>Utilisation de sons externes (bruits colorés, nature...). Objectifs :</p>
                <ul> <li><strong>Masquage :</strong> Couvrir l'acouphène.</li> <li><strong>Distraction :</strong> Focaliser sur autre chose.</li> <li><strong>Habituation (TRT) :</strong> Aider le cerveau à ignorer l'acouphène (son faible, sur durée, souvent avec pro).</li> </ul>
                 <p>Expérimentez avec le générateur.</p>
             </article>
            <article>
                <h3>💡 Conseils Complémentaires</h3>
                <ul> <li>Protégez votre audition (bouchons).</li> <li>Gérez votre stress (relaxation, hobbies).</li> <li>Soignez votre sommeil.</li> <li>Activité physique régulière.</li> <li>Alimentation équilibrée (attention caféine, alcool, sel si lien noté).</li> <li>Évitez le silence complet (fond sonore léger).</li> <li>Restez informé mais pas obsédé.</li> <li>Cherchez du soutien (proches, associations).</li> </ul>
            </article>
             <article class="mt-l">
                 <h3>❓ FAQ</h3>
                 <p><strong>Q: Guérit l'acouphène ?</strong> R: Non, outil de gestion.</p>
                 <p class="mt-m"><strong>Q: Auto-hypnose sûre ?</strong> R: Oui (relaxation/stress). Pas en conduisant.</p>
                 <p class="mt-m"><strong>Q: Lecture vocale marche partout ?</strong> R: Dépend navigateur/OS. Voix varient.</p>
                 <p class="mt-m"><strong>Q: Quel bruit (blanc, rose, brun) ?</strong> R: Testez ! Blanc=aigu/sifflant, Rose=moyen/cascade, Brun=grave/grondement.</p>
                 <p class="mt-m"><strong>Q: Données sécurisées ?</strong> R: Stockées localement sur VOTRE appareil uniquement. Supprimables via Suivi.</p>
             </article>
        </section>
    </template>


    <!-- --- JavaScript Intégré --- -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            console.log("Acouphènes Zen App Initializing v1.1 Enhanced...");

            // --- MODULE: Utilitaires Globaux ---
            const Utils = (() => {
                 function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return unsafe; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
                 function formatTime(seconds) { if (isNaN(seconds) || seconds < 0) return "--:--"; const mins = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
                 function updateBodyPadding() { const nav = document.getElementById('main-nav'); if (nav) { const navHeight = nav.offsetHeight; const buffer = 5; document.body.style.paddingTop = `${navHeight + buffer}px`; document.documentElement.style.setProperty('--nav-height', `${navHeight + buffer}px`); } }
                 function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }
                 function generateUUID() { // Simple UUID generator
                    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
                    );
                 }
                 return { escapeHtml, formatTime, updateBodyPadding, debounce, generateUUID };
            })();


            // --- MODULE: État Global & Stockage Local ---
            const Store = (() => {
                const STORAGE_KEY = 'acouphenesZenData_v1.2'; // Incrémenté pour nouvelles prefs
                const MAX_JOURNAL_ENTRIES = 365;

                const defaultPreferences = {
                    theme: 'light',
                    hypnoTtsEnabled: false,
                    preferredVoiceURI: null, // Ajout préférence Voix
                    favoriteSounds: [] // Ajout favoris sons
                };

                let state = {
                    userProfile: {
                        initialAssessment: null,
                        preferences: { ...defaultPreferences }
                    },
                    sessions: [], // { timestamp: ISOString, sessionKey: string, duration: number, completed: boolean }
                    journal: [],  // { date: ISOString, intensity: number, notes: string }
                    lastActive: null
                };

                function load() {
                    const storedData = localStorage.getItem(STORAGE_KEY);
                    if (storedData) {
                        try {
                            const parsedData = JSON.parse(storedData);
                            state = {
                                userProfile: {
                                    initialAssessment: parsedData.userProfile?.initialAssessment || null,
                                    preferences: {
                                        ...defaultPreferences, // Assure que les nouvelles clés existent
                                        ...(parsedData.userProfile?.preferences || {})
                                     }
                                },
                                sessions: Array.isArray(parsedData.sessions) ? parsedData.sessions : [],
                                journal: Array.isArray(parsedData.journal) ? parsedData.journal.map(entry => ({...entry, intensity: parseInt(entry.intensity, 10) || 0})) : [], // Assure intensity est un nombre
                                lastActive: parsedData.lastActive || null
                            };
                             // Nettoyage favoris (assurer ID unique si manque)
                             if (state.userProfile.preferences.favoriteSounds) {
                                state.userProfile.preferences.favoriteSounds = state.userProfile.preferences.favoriteSounds.map(fav => ({
                                    ...fav,
                                    id: fav.id || Utils.generateUUID(), // Ajoute un ID si manquant
                                    volume: parseFloat(fav.volume) || 0.1 // Assure que volume est un nombre
                                }));
                             } else {
                                 state.userProfile.preferences.favoriteSounds = [];
                             }

                            state.journal.sort((a, b) => new Date(a.date) - new Date(b.date));
                            console.log('Données chargées depuis localStorage.');
                        } catch (e) { console.error("Erreur chargement localStorage:", e); state.userProfile.preferences = { ...defaultPreferences }; state.journal = []; state.sessions = []; } // Reset en cas d'erreur grave
                    } else { console.log('Aucune donnée locale trouvée, état initial.'); }
                    applyThemePreference(); // Applique thème chargé ou par défaut
                }

                function save() {
                    state.lastActive = new Date().toISOString();
                    try {
                        state.journal.sort((a, b) => new Date(a.date) - new Date(b.date));
                        if (state.journal.length > MAX_JOURNAL_ENTRIES) state.journal = state.journal.slice(state.journal.length - MAX_JOURNAL_ENTRIES);
                        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                    } catch (e) { console.error("Erreur sauvegarde localStorage:", e); UI.showToast("Erreur sauvegarde données.", "error"); }
                }

                function getState() { return JSON.parse(JSON.stringify(state)); }
                function updateProfile(profileData) { state.userProfile.initialAssessment = profileData; save(); }
                function addJournalEntry(entry) {
                     if (typeof entry.intensity === 'undefined' || entry.intensity === null) return null;
                     const newEntry = {
                        date: new Date().toISOString(),
                        intensity: parseInt(entry.intensity, 10), // Assurer que c'est un nombre
                        notes: (entry.notes || "").trim()
                     };
                     state.journal.push(newEntry);
                     save();
                     return newEntry;
                 }
                function getJournalEntries(limit = null) { const sortedJournal = [...state.journal].sort((a, b) => new Date(b.date) - new Date(a.date)); if (limit && typeof limit === 'number' && limit > 0) { return sortedJournal.slice(0, limit); } return sortedJournal; }
                function addSessionLog(logData) { logData.timestamp = new Date().toISOString(); state.sessions.push(logData); save(); }

                // --- Préférences ---
                function updateThemePreference(theme) { state.userProfile.preferences.theme = theme; save(); applyThemePreference(); }
                function getThemePreference() { return state.userProfile.preferences.theme || 'light'; }
                function setTtsPreference(enabled) { state.userProfile.preferences.hypnoTtsEnabled = !!enabled; save(); }
                function getTtsPreference() { return !!state.userProfile.preferences.hypnoTtsEnabled; }
                function setPreferredVoiceURI(uri) { state.userProfile.preferences.preferredVoiceURI = uri; save(); }
                function getPreferredVoiceURI() { return state.userProfile.preferences.preferredVoiceURI; }

                // --- Favoris Sons ---
                function addFavoriteSound(preset) {
                    const name = prompt(`Nommez ce favori (ex: Pluie douce):`, `${preset.type} (${preset.volume.toFixed(2)})`);
                    if (name && name.trim()) {
                        const newFav = { ...preset, id: Utils.generateUUID(), name: name.trim() };
                        state.userProfile.preferences.favoriteSounds.push(newFav);
                        save();
                        return newFav;
                    }
                    return null;
                }
                function removeFavoriteSound(id) { state.userProfile.preferences.favoriteSounds = state.userProfile.preferences.favoriteSounds.filter(fav => fav.id !== id); save(); }
                function getFavoriteSounds() { return state.userProfile.preferences.favoriteSounds || []; }

                function clearAllData() {
                     if (confirm("ATTENTION !\n\nÊtes-vous sûr de vouloir supprimer TOUTES vos données (évaluation, journal, sessions, favoris, préférences) ?\n\nIRRÉVERSIBLE.")) {
                        const prefsToKeep = { ...state.userProfile.preferences }; // Sauvegarde temporaire
                        localStorage.removeItem(STORAGE_KEY);
                        state = { // Reset complet
                            userProfile: { initialAssessment: null, preferences: { ...defaultPreferences } },
                            sessions: [], journal: [], lastActive: null
                        };
                        // Rétablir certaines préférences si on veut (ex: theme)
                        state.userProfile.preferences.theme = prefsToKeep.theme;
                         // state.userProfile.preferences.preferredVoiceURI = prefsToKeep.preferredVoiceURI; // Garder la voix ? A débattre
                         save(); // Sauver l'état réinitialisé
                        console.log("Toutes les données utilisateur ont été supprimées.");
                        window.location.hash = '#home';
                        window.location.reload(); // Force rechargement pour appliquer partout
                        return true;
                    }
                    return false;
                 }

                 function applyThemePreference() {
                     const theme = getThemePreference();
                     document.body.classList.toggle('dark-mode', theme === 'dark');
                     const toggleButton = document.getElementById('theme-toggle');
                     if (toggleButton) {
                        toggleButton.textContent = theme === 'dark' ? '☀️' : '🌙';
                        toggleButton.title = `Passer au thème ${theme === 'dark' ? 'clair' : 'sombre'}`;
                     }
                 }
                 load(); // Charger au démarrage

                return { getState, updateProfile, addJournalEntry, getJournalEntries, addSessionLog, updateThemePreference, getThemePreference, applyThemePreference, setTtsPreference, getTtsPreference, setPreferredVoiceURI, getPreferredVoiceURI, addFavoriteSound, removeFavoriteSound, getFavoriteSounds, clearAllData };
            })();

            // --- MODULE: UI (Manipulation du DOM & Feedback) ---
            const UI = (() => {
                const uiElements = { mainContent: document.getElementById('main-content'), navLinks: document.querySelectorAll('#main-nav a[href^="#"]') };
                function renderTemplate(templateId) { const template = document.getElementById(templateId); if (!template) { console.error(`Template ${templateId} non trouvé`); uiElements.mainContent.innerHTML = `<section class="content-section"><p class="alert alert-danger">Erreur contenu page.</p></section>`; setActiveNavLink(''); return null; } try { const content = template.content.cloneNode(true); uiElements.mainContent.innerHTML = ''; uiElements.mainContent.appendChild(content); setActiveNavLink(templateId.replace('template-', '')); window.scrollTo({ top: 0, behavior: 'smooth' }); return uiElements.mainContent.firstChild; } catch (error) { console.error(`Erreur rendu ${templateId}:`, error); uiElements.mainContent.innerHTML = `<section class="content-section"><p class="alert alert-danger">Erreur affichage section.</p></section>`; setActiveNavLink(''); return null; } }
                function setActiveNavLink(hash) { uiElements.navLinks.forEach(link => { link.classList.remove('active'); if (link.getAttribute('href') === `#${hash}`) link.classList.add('active'); }); }
                function displayEvaluationResult(score, message) { const resultDiv = document.getElementById('evaluation-result'); if (resultDiv) { let alertClass = 'alert-success'; if (score >= 25) alertClass = 'alert-danger'; else if (score >= 15) alertClass = 'alert-warning'; else alertClass = 'alert-info'; resultDiv.innerHTML = `<div class="alert ${alertClass}"><strong>Résultat :</strong> ${Utils.escapeHtml(message)} (Score d'impact: ${score})</div>`; resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } }
                function renderJournalEntry(entry) { const li = document.createElement('li'); const entryDate = new Date(entry.date); const formattedDateTime = entryDate.toLocaleString('fr-FR', { dateStyle: 'short', timeStyle: 'short' }); li.innerHTML = `<strong>${formattedDateTime}</strong> - Intensité: <span style="font-weight: bold; color: var(--primary-color);">${entry.intensity}/10</span> ${entry.notes ? `<br><em>${Utils.escapeHtml(entry.notes)}</em>` : ''}`; return li; }
                function displayJournalHistory(entries) { const historyList = document.querySelector('#tracking-history ul'); const loadingMsg = document.getElementById('history-loading'); if (!historyList || !loadingMsg) return; historyList.innerHTML = ''; if (!entries || entries.length === 0) { loadingMsg.textContent = "Journal vide."; loadingMsg.style.display = 'block'; } else { loadingMsg.style.display = 'none'; entries.forEach(entry => { const li = renderJournalEntry(entry); if (li) historyList.appendChild(li); }); } }
                function showToast(message, type = 'info', duration = 3000) { const toast = document.createElement('div'); toast.className = `toast toast-${type}`; toast.textContent = message; document.body.appendChild(toast); requestAnimationFrame(() => { toast.classList.add('show'); }); setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => { if (toast.parentNode) toast.parentNode.removeChild(toast); }, { once: true }); }, duration); }
                // Nouvelle fonction pour afficher les favoris
                function displayFavoriteSounds(favorites, playCallback, deleteCallback) {
                    const list = document.getElementById('favorite-sounds-list');
                    const msg = document.getElementById('no-favorites-msg');
                    if (!list || !msg) return;
                    list.innerHTML = ''; // Clear existing
                    if (!favorites || favorites.length === 0) {
                        msg.style.display = 'list-item'; // Show "Aucun favori" message
                        list.appendChild(msg); // Re-add it if it was cleared
                    } else {
                        msg.style.display = 'none'; // Hide "Aucun favori" message
                        favorites.forEach(fav => {
                            const li = document.createElement('li');
                            const playBtn = document.createElement('button');
                            playBtn.className = 'play-fav-btn';
                            playBtn.textContent = fav.name;
                            playBtn.title = `Jouer ${fav.name} (${fav.type}, Vol ${fav.volume.toFixed(2)})`;
                            playBtn.onclick = () => playCallback(fav);

                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'delete-fav-btn button-icon';
                            deleteBtn.innerHTML = '🗑️';
                            deleteBtn.title = `Supprimer ${fav.name}`;
                            deleteBtn.setAttribute('aria-label', `Supprimer ${fav.name}`);
                            deleteBtn.onclick = () => deleteCallback(fav.id);

                            li.appendChild(playBtn);
                            li.appendChild(deleteBtn);
                            list.appendChild(li);
                        });
                    }
                }

                return { renderTemplate, setActiveNavLink, displayEvaluationResult, displayJournalHistory, showToast, displayFavoriteSounds };
             })();

            // --- MODULE: Audio (Web Audio API) - Avec Fondu ---
            const AudioManager = (() => {
                let audioContext; let masterGainNode; let currentNoiseSource = null; let currentFilterNode = null; let currentNoiseType = null; let noiseTimer = null;
                const FADE_DURATION = 0.5; // Durée du fondu en secondes

                function getContext() { if (!audioContext) { try { window.AudioContext = window.AudioContext || window.webkitAudioContext; if (!window.AudioContext) throw new Error("Web Audio API non supportée"); audioContext = new AudioContext(); masterGainNode = audioContext.createGain(); masterGainNode.connect(audioContext.destination); masterGainNode.gain.setValueAtTime(0, audioContext.currentTime); /* Start at 0 volume */ console.log("AudioContext créé."); } catch(e) { console.error("Erreur AudioContext:", e); UI.showToast("Audio non supporté.", "error"); return null; } } if (audioContext.state === 'suspended') audioContext.resume().catch(err => console.error("Erreur reprise:", err)); return audioContext; }
                function initContextOnInteraction() { const initAudio = () => { const context = getContext(); if (context && context.state === 'running') { console.log("Audio activé."); document.body.removeEventListener('click', initAudio, { capture: true }); document.body.removeEventListener('touchstart', initAudio, { capture: true }); document.body.removeEventListener('keydown', initAudio, { capture: true }); } }; document.body.addEventListener('click', initAudio, { once: true, capture: true }); document.body.addEventListener('touchstart', initAudio, { once: true, capture: true }); document.body.addEventListener('keydown', initAudio, { once: true, capture: true }); }
                function createWhiteNoiseSource(context) { const bufferSize = context.sampleRate * 2; const buffer = context.createBuffer(1, bufferSize, context.sampleRate); const output = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1; const source = context.createBufferSource(); source.buffer = buffer; source.loop = true; return source; }
                function createPinkFilter(context) { const filter = context.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(800, context.currentTime); filter.Q.setValueAtTime(0.707, context.currentTime); return filter; }
                function createBrownFilter(context) { const filter = context.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(300, context.currentTime); filter.Q.setValueAtTime(1, context.currentTime); return filter; }

                function playNoise(type, volume, durationMinutes = 0) {
                    stopNoise(); // Nettoyage AVANT
                    const context = getContext();
                    if (!context || context.state !== 'running') { if (context?.state === 'suspended') { context.resume().then(() => playNoise(type, volume, durationMinutes)).catch(err => UI.showToast("Activez l'audio (clic?).", "warning")); } else UI.showToast("Audio non prêt (cliquez?).", "warning"); return false; }

                    try {
                        currentNoiseSource = null; currentFilterNode = null; currentNoiseType = type;
                        const whiteSource = createWhiteNoiseSource(context);
                        currentNoiseSource = whiteSource; let nodeToConnect = whiteSource;
                        if (type === 'pink') { currentFilterNode = createPinkFilter(context); whiteSource.connect(currentFilterNode); nodeToConnect = currentFilterNode; }
                        else if (type === 'brown') { currentFilterNode = createBrownFilter(context); whiteSource.connect(currentFilterNode); nodeToConnect = currentFilterNode; }
                        nodeToConnect.connect(masterGainNode);
                        currentNoiseSource.start(0);
                        // Fade In
                        masterGainNode.gain.cancelScheduledValues(context.currentTime);
                        masterGainNode.gain.setValueAtTime(0, context.currentTime); // Start at 0
                        masterGainNode.gain.linearRampToValueAtTime(volume, context.currentTime + FADE_DURATION);
                        console.log(`Bruit ${type} démarré avec fondu vers ${volume}.`);

                        if (durationMinutes > 0) { const s = durationMinutes * 60; noiseTimer = setTimeout(() => { console.log("Timer atteint."); stopNoise(); UI.showToast("Son arrêté (timer).", "info"); document.dispatchEvent(new CustomEvent('audiotimerend')); }, s * 1000); document.dispatchEvent(new CustomEvent('audiotimerstart', { detail: { durationMinutes } })); } else { document.dispatchEvent(new CustomEvent('audiotimerclear')); }
                        return true;
                    } catch (error) { console.error(`Erreur lecture ${type}:`, error); UI.showToast(`Erreur lecture audio (${type}).`, "error"); stopNoise(); return false; }
                }

                function stopNoise(immediate = false) {
                    if (noiseTimer) { clearTimeout(noiseTimer); noiseTimer = null; document.dispatchEvent(new CustomEvent('audiotimerclear')); }
                    if (!currentNoiseSource || !audioContext) return false; // Nothing to stop

                    const sourceToStop = currentNoiseSource;
                    const filterToDisconnect = currentFilterNode;
                    const stoppedType = currentNoiseType;

                    // Clear current references immediately
                    currentNoiseSource = null; currentFilterNode = null; currentNoiseType = null;

                    const fadeOutTime = audioContext.currentTime + (immediate ? 0.01 : FADE_DURATION);

                    // Fade Out
                    masterGainNode.gain.cancelScheduledValues(audioContext.currentTime);
                    masterGainNode.gain.setValueAtTime(masterGainNode.gain.value, audioContext.currentTime); // Start from current volume
                    masterGainNode.gain.linearRampToValueAtTime(0.0001, fadeOutTime); // Ramp down to near zero

                    // Stop the source slightly after the fade completes
                    sourceToStop.stop(fadeOutTime + 0.05);

                    // Disconnect after stopping
                    setTimeout(() => {
                        try {
                            if (filterToDisconnect) filterToDisconnect.disconnect();
                            sourceToStop.disconnect();
                            console.log(`Bruit ${stoppedType} arrêté et déconnecté après fondu.`);
                        } catch(e) { console.warn("Erreur déconnexion post-arrêt:", e); }
                    }, (fadeOutTime - audioContext.currentTime + 0.1) * 1000); // Delay slightly longer than stop time

                    return true;
                }

                function setVolume(volume) { volume = Math.max(0, Math.min(1, volume)); if (masterGainNode && audioContext && currentNoiseSource) { masterGainNode.gain.cancelScheduledValues(audioContext.currentTime); masterGainNode.gain.setTargetAtTime(volume, audioContext.currentTime, 0.015); } }
                function isPlaying() { return !!currentNoiseSource; }
                // Ajout pour pause/resume audio (utilisé par hypnose)
                function suspendAudio() { if (audioContext && audioContext.state === 'running') return audioContext.suspend(); return Promise.resolve(); }
                function resumeAudio() { if (audioContext && audioContext.state === 'suspended') return audioContext.resume(); return Promise.resolve(); }

                return { initContextOnInteraction, playNoise, stopNoise, setVolume, isPlaying, getContext, suspendAudio, resumeAudio };
             })();

            // --- MODULE: Synthèse Vocale (TTS) - Avec sélection de voix ---
			const TTSManager = (() => {
				let synthesis = window.speechSynthesis;
				let voices = [];
				let isSupported = false;
				let currentUtterance = null;
				let isCurrentlySpeakingInternal = false;

				function init() {
					if ('speechSynthesis' in window) {
						isSupported = true;
						console.log("TTS supporté.");
						synthesis.onvoiceschanged = populateVoiceList; // Important!
						populateVoiceList(); // Premier essai
					} else { console.warn("TTS non supporté."); }
				}

                function populateVoiceList() {
                    if (!isSupported) return;
                    try {
                        voices = synthesis.getVoices().filter(v => v.lang.startsWith('fr')); // Filtre voix FR
                        console.log("Voix FR trouvées:", voices.length);
                        // Mise à jour du select dans la page hypnose (si elle est affichée)
                         const voiceSelect = document.getElementById('hypno-voice-select');
                         if (voiceSelect) {
                             const currentVal = voiceSelect.value; // Sauver la valeur actuelle
                             voiceSelect.innerHTML = '<option value="">Voix par défaut</option>'; // Reset options
                             voices.forEach(voice => {
                                 const option = document.createElement('option');
                                 option.value = voice.voiceURI;
                                 option.textContent = `${voice.name} (${voice.lang})`;
                                 option.selected = (voice.voiceURI === currentVal); // Resélectionner si possible
                                 voiceSelect.appendChild(option);
                             });
                             // Tenter de sélectionner la voix préférée sauvegardée
                             const preferredURI = Store.getPreferredVoiceURI();
                             if (preferredURI && voices.some(v => v.voiceURI === preferredURI)) {
                                 voiceSelect.value = preferredURI;
                             }
                         }
                    } catch (e) { console.error("Erreur getVoices:", e); }
                 }

                function speak(text) {
                    const audioCtx = AudioManager.getContext();
                    if (!audioCtx || audioCtx.state !== 'running') { console.warn("TTS speak ignoré: AudioContext non actif."); audioCtx?.resume().then(() => speak(text)).catch(err => { UI.showToast("Activez l'audio (clic?) pour la lecture vocale.", "warning"); }); return false; }
                    if (!isSupported || !text) { console.warn("TTS speak ignoré: non supporté ou vide"); return false; }
                    if (isCurrentlySpeakingInternal) { cancel(); } // Annule la précédente si elle parle encore

                    currentUtterance = new SpeechSynthesisUtterance(text);
                    const preferredURI = Store.getPreferredVoiceURI();
                    const selectedVoice = voices.find(v => v.voiceURI === preferredURI);

                    if (selectedVoice) {
                        currentUtterance.voice = selectedVoice;
                        console.log("Voix TTS sélectionnée:", selectedVoice.name);
                    } else {
                         let defaultFrVoice = voices.find(v => v.lang === 'fr-FR') || voices[0]; // Fallback sur la première FR
                         if (defaultFrVoice) {
                             currentUtterance.voice = defaultFrVoice;
                             console.log("Voix TTS FR par défaut utilisée:", defaultFrVoice.name);
                         } else { console.warn("Aucune voix FR trouvée, utilise défaut système."); }
                    }
                    currentUtterance.lang = 'fr-FR';
                    currentUtterance.pitch = 1;
                    currentUtterance.rate = 0.9;

                    currentUtterance.onstart = () => { console.log("TTS: onstart"); isCurrentlySpeakingInternal = true; };
                    currentUtterance.onend = () => { console.log("TTS: onend"); isCurrentlySpeakingInternal = false; currentUtterance = null; };
					currentUtterance.onerror = (e) => {
						const errorMsg = e.error || 'unknown';
						// **Modification Log**
						if (errorMsg === 'interrupted' || errorMsg === 'canceled') {
							 console.log(`TTS: Lecture interrompue (${errorMsg}) - Normal si arrêt/pause/changement page/étape.`);
						} else {
							 console.error('Erreur TTS:', errorMsg);
							 UI.showToast(`Erreur lecture vocale (${errorMsg}).`, "error");
						}
						isCurrentlySpeakingInternal = false;
						currentUtterance = null; // Assurer le nettoyage
					};

                    try { synthesis.speak(currentUtterance); console.log("TTS: Demande de lecture:", text.substring(0,30)+"..."); return true; }
                    catch (e) { console.error("Erreur synthesis.speak:", e); UI.showToast("Impossible démarrer lecture.", "error"); isCurrentlySpeakingInternal = false; currentUtterance = null; return false; }
                 }

				function cancel() { if (synthesis && (synthesis.speaking || synthesis.pending || isCurrentlySpeakingInternal)) { console.log("TTS: cancel() demandé."); synthesis.cancel(); isCurrentlySpeakingInternal = false; currentUtterance = null; } }
				function isSpeaking() { return isCurrentlySpeakingInternal; }
                // Pause/Resume pour TTS sont peu fiables, on utilisera cancel/speak
                function pause() { if(synthesis && synthesis.speaking) synthesis.pause(); }
                function resume() { if(synthesis && synthesis.paused) synthesis.resume(); }

				init(); // Doit être appelé pour que onvoiceschanged fonctionne
				return { isSupported: () => isSupported, populateVoiceList, speak, cancel, pause, resume, isSpeaking }; // Expose populate
			})();

            // --- Déclaration Globale des Handlers ---
            const pageHandlers = {};

            // --- MODULE: Routage ---
            const Router = (() => {
                let currentPageInitFunction = null; let currentPageCleanupFunction = null;
                function handleRouteChange() {
                    const hash = window.location.hash || '#home'; let route = hash.substring(1);
                    console.log(`Routing vers: ${route}`);
                    if (typeof currentPageCleanupFunction === 'function') { try { currentPageCleanupFunction(); } catch (e) { console.error(`Erreur cleanup:`, e); } }
                    currentPageCleanupFunction = null; currentPageInitFunction = null;
                    // Arrêt systématique sons/tts au changement de page
                    if (AudioManager.isPlaying()) AudioManager.stopNoise(true); // Arrêt immédiat
                    if (TTSManager.isSpeaking()) TTSManager.cancel();

                    const templateId = `template-${route}`; if (!document.getElementById(templateId)) { route = 'home'; window.location.hash = '#home'; }
                    const renderedElement = UI.renderTemplate(`template-${route}`);
                    if (renderedElement) {
                        switch (route) {
                            case 'evaluation': currentPageInitFunction = initEvaluationPage; currentPageCleanupFunction = cleanupEvaluationPage; break;
                            case 'hypnose': currentPageInitFunction = initHypnosePage; currentPageCleanupFunction = cleanupHypnosePage; break;
                            case 'sounds': currentPageInitFunction = initSoundsPage; currentPageCleanupFunction = cleanupSoundsPage; break;
                            case 'tracking': currentPageInitFunction = initTrackingPage; currentPageCleanupFunction = cleanupTrackingPage; break;
                            case 'resources': currentPageInitFunction = initResourcesPage; currentPageCleanupFunction = cleanupResourcesPage; break;
                            case 'home': default: currentPageInitFunction = initHomePage; currentPageCleanupFunction = cleanupHomePage; break;
                        }
                        if (typeof currentPageInitFunction === 'function') { try { currentPageInitFunction(); console.log(`Init ${route} OK.`); } catch(e) { console.error(`Erreur init ${route}:`, e); UI.showToast(`Erreur chargement ${route}.`, "error"); } }
                    }
                 }
                function init() { window.addEventListener('hashchange', handleRouteChange); AudioManager.initContextOnInteraction(); initThemeToggle(); initQuickEntry(); Utils.updateBodyPadding(); window.addEventListener('resize', Utils.debounce(Utils.updateBodyPadding, 150)); handleRouteChange(); } // Init Quick Entry
                return { init };
            })();

            // --- Fonctions Init/Cleanup des Pages ---

            function initHomePage() { console.log("Init Home"); }
            function cleanupHomePage() { console.log("Cleanup Home"); }

            function initEvaluationPage() {
                console.log("Init Evaluation"); const form = document.getElementById('evaluation-form'); const resultDiv = document.getElementById('evaluation-result'); const savedProfile = Store.getState().userProfile.initialAssessment; if (form && savedProfile) { Object.keys(savedProfile).forEach(key => { const input = form.elements[key]; if (input) { if (input.type === 'radio') form.querySelectorAll(`input[name="${key}"]`).forEach(radio => { radio.checked = (radio.value === savedProfile[key]); }); else if (input.type === 'range') { input.value = savedProfile[key]; if (input.nextElementSibling?.tagName === 'OUTPUT') input.nextElementSibling.textContent = input.value; } else if (input.tagName === 'SELECT') input.value = savedProfile[key]; else input.value = savedProfile[key]; } }); resultDiv.innerHTML = `<div class="alert alert-info">Infos chargées.</div>`; } else if (resultDiv) resultDiv.innerHTML = '';
                pageHandlers.evaluationSubmit = handleEvaluationSubmit;
                form?.addEventListener('submit', pageHandlers.evaluationSubmit);
             }
            function handleEvaluationSubmit(e) { e.preventDefault(); const form = e.target; const formData = new FormData(form); const data = {}; let score = 0; const impactKeys = ['intensity-avg', 'impact-sleep', 'impact-concentration', 'impact-mood', 'impact-hearing']; formData.forEach((value, key) => { data[key] = Utils.escapeHtml(value.trim()); if (impactKeys.includes(key)) score += parseInt(value, 10) || 0; }); Store.updateProfile(data); let msg = "Éval enregistrée. "; if (score >= 25) msg += "Impact significatif."; else if (score >= 15) msg += "Impact modéré."; else msg += "Impact léger."; UI.displayEvaluationResult(score, msg); UI.showToast("Éval enregistrée !", "success"); }
            function cleanupEvaluationPage() { const form = document.getElementById('evaluation-form'); if(form && pageHandlers.evaluationSubmit) form.removeEventListener('submit', pageHandlers.evaluationSubmit); delete pageHandlers.evaluationSubmit; console.log("Cleanup Éval"); }

            // --- Page Auto-Hypnose (MAJ Majeure) ---
             let hypnoTimerInterval = null;
             let hypnoSessionEndTime = 0;
             let hypnoCurrentSessionData = null;
             let hypnoIsPaused = false;
             let hypnoPauseStartTime = 0;
             let hypnoTotalPauseDuration = 0;
             let hypnoNoiseType = 'none';
             let hypnoVolume = 0.05;
             let hypnoTtsEnabled = false;
             let hypnoSessionCompleted = false;
             let hypnoLastSpokenText = null; // Garder trace du texte courant pour reprise

             const sessionsData = { // Contenu des sessions inchangé, repris de votre code original
                debutant: { title: "Débutant (env. 10 min) - Relaxation et Prise de Conscience", duration: 600, script: [ { time: 0, text: "Commencez par trouver une position confortable, assise ou allongée, où vous ne serez pas dérangé. Fermez doucement les yeux ou fixez un point devant vous sans effort." }, { time: 20, text: "Prenez maintenant trois respirations profondes et calmes. Inspirez par le nez en gonflant le ventre... et expirez lentement par la bouche, en relâchant les tensions..." }, { time: 45, text: "Répétez encore deux fois à votre rythme... Sentez votre corps commencer à se détendre à chaque expiration..." }, { time: 75, text: "Portez maintenant votre attention sur les sensations de votre corps. Ressentez le contact de vos pieds avec le sol ou le support... le poids de votre corps..." }, { time: 120, text: "Scannez mentalement votre corps, des pieds à la tête. Remarquez simplement les sensations, sans jugement. S'il y a des tensions, imaginez qu'elles se relâchent à chaque expiration..." }, { time: 180, text: "Portez maintenant votre attention sur votre respiration naturelle. Observez le va-et-vient de l'air, sans chercher à la contrôler... C'est votre point d'ancrage dans le moment présent..." }, { time: 240, text: "Les pensées peuvent venir, c'est normal. Laissez-les passer comme des nuages dans le ciel, sans vous y accrocher, et revenez doucement à la sensation de votre respiration..." }, { time: 300, text: "Maintenant, portez une attention douce et curieuse aux sons autour de vous... Ceux de la pièce... ceux de l'extérieur... Accueillez-les sans jugement..." }, { time: 360, text: "Remarquez aussi la présence de votre acouphène, s'il est là. Essayez de le percevoir comme un son parmi d'autres, sans lui donner plus d'importance. Juste une sensation sonore..." }, { time: 420, text: "Imaginez que vous pouvez créer un espace mental autour de ce son. Il est là, mais il y a aussi de l'espace, du calme autour..." }, { time: 480, text: "Revenez à la sensation globale de votre corps détendu... Appréciez ce moment de calme intérieur..." }, { time: 540, text: "Sachez que vous pouvez retrouver cet état de calme quand vous le souhaitez. C'est une capacité en vous." }, { time: 570, text: "Dans quelques instants, cette session va se terminer. Commencez à reprendre conscience de votre environnement... Bougez doucement les doigts, les orteils..." }, { time: 590, text: "Quand vous serez prêt, à votre rythme, ouvrez les yeux en gardant avec vous cette sensation de calme. Étirez-vous si vous le souhaitez." } ] },
                 intermediaire: { title: "Intermédiaire (env. 15 min) - Détournement de l'Attention", duration: 900, script: [ { time: 0, text: "Installez-vous confortablement, fermez les yeux. Prenez quelques respirations profondes pour signaler à votre corps qu'il peut se détendre." }, { time: 30, text: "Imaginez une lumière douce et apaisante au sommet de votre tête. Sentez sa chaleur et sa détente descendre lentement... sur votre front... vos yeux... vos mâchoires qui se desserrent..." }, { time: 60, text: "Cette vague de détente descend dans votre cou, vos épaules... le long de vos bras jusqu'au bout de vos doigts... Sentez la lourdeur agréable de la relaxation..." }, { time: 120, text: "Elle continue dans votre poitrine, votre ventre... votre dos se relâche... Sentez votre respiration devenir plus calme, plus profonde..." }, { time: 180, text: "La détente atteint vos jambes... vos genoux... vos mollets... jusqu'à vos pieds. Tout votre corps est maintenant agréablement lourd et détendu." }, { time: 240, text: "Maintenant, portez votre attention sur votre ouïe. Écoutez les sons autour de vous... sans les analyser, juste les percevoir..." }, { time: 300, text: "Peut-être entendez-vous votre acouphène. Accueillez-le un instant, sans jugement. Puis, choisissez consciemment de porter votre attention ailleurs." }, { time: 360, text: "Imaginez que vous êtes dans un endroit que vous aimez, un lieu paisible. Une plage, une forêt, un jardin... Visualisez cet endroit avec le plus de détails possible." }, { time: 420, text: "Quelles sont les couleurs ? Les formes ? Y a-t-il une odeur particulière ? Une brise légère sur votre peau ?" }, { time: 480, text: "Quels sont les sons agréables de cet endroit ? Le bruit des vagues ? Le chant des oiseaux ? Le vent dans les feuilles ? Concentrez-vous sur ces sons imaginaires apaisants." }, { time: 540, text: "Si votre attention revient à l'acouphène, c'est normal. Remarquez-le simplement, puis redirigez doucement mais fermement votre attention vers les sons agréables de votre lieu paisible." }, { time: 660, text: "Imaginez que vous pouvez ajuster le volume des sons. Augmentez le volume des sons agréables... et diminuez mentalement le volume de l'acouphène, le rendant plus lointain, moins pertinent." }, { time: 780, text: "Restez dans cet état d'absorption agréable, en vous concentrant sur les sensations positives de votre lieu de calme." }, { time: 840, text: "Sachez que votre capacité à diriger votre attention est une compétence puissante que vous pouvez entraîner." }, { time: 870, text: "Préparez-vous maintenant à revenir. Ramenez progressivement votre conscience à votre corps, à la pièce où vous êtes. Prenez une respiration plus profonde." }, { time: 890, text: "Bougez doucement, étirez-vous, et ouvrez les yeux quand vous êtes prêt, en emportant avec vous le calme et la capacité à choisir votre focus." } ] },
                 avance: { title: "Avancé (env. 20 min) - Modification de la Perception", duration: 1200, script: [ { time: 0, text: "Installez-vous confortablement. Fermez les yeux et prenez quelques instants pour entrer dans un état de relaxation profonde, en utilisant la technique qui vous convient le mieux (respiration, scan corporel...)." }, { time: 60, text: "Une fois bien détendu, portez votre attention sur votre acouphène. Observez-le avec une curiosité détachée, comme un scientifique observe un phénomène." }, { time: 120, text: "Quelles sont ses caractéristiques ? Est-il aigu, grave ? Continu, pulsatile ? Est-il stable ou changeant ? Essayez de le décrire mentalement, sans jugement de valeur ('gênant', 'horrible')." }, { time: 180, text: "Imaginez maintenant que vous avez des 'cadrans de contrôle' mentaux pour ce son." }, { time: 240, text: "Visualisez un cadran pour le volume. Imaginez que vous tournez ce cadran très lentement vers le bas. Même si le son réel ne change pas, notez toute modification dans votre perception ou votre réaction émotionnelle." }, { time: 330, text: "Visualisez un cadran pour la 'tonalité' ou la 'qualité' du son. Imaginez que vous pouvez le rendre légèrement plus grave, ou plus doux, ou plus diffus. Jouez mentalement avec ces caractéristiques." }, { time: 420, text: "Imaginez un cadran pour la 'localisation'. Pouvez-vous mentalement déplacer le son ? Le rendre plus externe, plus lointain ? Le laisser flotter hors de votre tête ?" }, { time: 510, text: "Visualisez un cadran pour l''émotion' associée au son. Imaginez tourner ce cadran de 'gêne' ou 'anxiété' vers 'neutre' ou même 'acceptation'." }, { time: 600, text: "Maintenant, laissez les cadrans et portez votre attention sur une sensation agréable dans votre corps. Peut-être la chaleur de vos mains, la détente de vos épaules, ou le calme de votre respiration." }, { time: 690, text: "Amplifiez cette sensation agréable. Laissez-la grandir et se diffuser dans tout votre corps, créant un sentiment général de bien-être." }, { time: 780, text: "Imaginez que ce bien-être est comme une bulle protectrice autour de vous. L'acouphène peut être là, à l'extérieur ou à l'intérieur de la bulle, mais il ne perturbe pas le calme à l'intérieur." }, { time: 900, text: "L'acouphène est juste un son. Il n'a que le pouvoir que vous lui donnez. Vous apprenez à lui retirer ce pouvoir émotionnel." }, { time: 1020, text: "Ancrez cette sensation de contrôle et de calme en vous. Prenez une profonde inspiration et expirez lentement." }, { time: 1140, text: "Rappelez-vous que cette capacité à modifier votre perception s'affine avec la pratique régulière." }, { time: 1170, text: "Commencez maintenant à revenir progressivement à votre état de conscience habituel. Sentez l'énergie revenir dans votre corps. Bougez les doigts, les orteils." }, { time: 1190, text: "Quand vous êtes prêt, ouvrez les yeux, en gardant ce sentiment de perspective et de calme intérieur renouvelé." } ] }
             };

			// *** REMPLACEZ ENCORE VOTRE FONCTION updateHypnoTimer PAR CELLE-CI ***
			function updateHypnoTimer() {
				if (!hypnoCurrentSessionData || hypnoIsPaused) return;

				const now = Date.now();
				const elapsedSinceStart = (now - (hypnoSessionEndTime - hypnoCurrentSessionData.duration * 1000));
				const effectiveElapsed = elapsedSinceStart - hypnoTotalPauseDuration;
				const remaining = Math.max(0, hypnoCurrentSessionData.duration - effectiveElapsed / 1000);

				const timerDisplay = document.querySelector('#hypnose-session .timer');
				const progressBar = document.getElementById('session-progress-bar');
				const textContent = document.getElementById('session-text-content');
				const stepIndicator = document.getElementById('session-step-indicator');

				if (!timerDisplay || !progressBar || !textContent || !stepIndicator) { return; }

				timerDisplay.textContent = Utils.formatTime(remaining);
				const progressPercent = Math.min(100, (effectiveElapsed / 1000 / hypnoCurrentSessionData.duration) * 100);
				progressBar.style.width = `${progressPercent}%`;

				const currentStepIndex = hypnoCurrentSessionData.script.slice().reverse().findIndex(step => (effectiveElapsed / 1000) >= step.time);
				const currentStep = currentStepIndex !== -1 ? hypnoCurrentSessionData.script[hypnoCurrentSessionData.script.length - 1 - currentStepIndex] : null;

				if (currentStep) {
					const currentStepTextRaw = currentStep.text; // Texte de l'étape actuelle venant du script

					// *** NOUVELLE LOGIQUE DE COMPARAISON ICI ***
					// On compare le texte brut de l'étape actuelle avec le dernier texte qu'on a demandé de lire
					if (currentStepTextRaw !== hypnoLastSpokenText) {
						console.log(`[updateHypnoTimer] NOUVEAU texte détecté. Précédent: "${(hypnoLastSpokenText || 'null').substring(0,15)}...", Nouveau: "${currentStepTextRaw.substring(0,15)}..."`);

						// 1. Mettre à jour l'affichage DOM
						const currentStepTextEscaped = Utils.escapeHtml(currentStepTextRaw);
						textContent.innerHTML = `<p data-raw-text="${currentStepTextEscaped}">${currentStepTextEscaped}</p>`;
						textContent.scrollTop = textContent.scrollHeight;

						// 2. Mettre à jour notre référence interne *après* avoir confirmé que c'est nouveau
						hypnoLastSpokenText = currentStepTextRaw;

						// 3. Demander la lecture du nouveau texte (si activé et non en pause)
						if (hypnoTtsEnabled && TTSManager.isSupported() && !hypnoIsPaused) {
							 console.log(`[updateHypnoTimer] Demande lecture pour: "${hypnoLastSpokenText.substring(0,30)}..."`);
							 TTSManager.speak(hypnoLastSpokenText);
						} else if (hypnoIsPaused) {
							console.log("[updateHypnoTimer] Nouveau texte mais session en pause.");
						}
					} // *** Fin de la nouvelle logique de comparaison ***

					// Mise à jour de l'indicateur d'étape (toujours fait si une étape existe)
					const totalSteps = hypnoCurrentSessionData.script.length;
					const currentStepNumber = hypnoCurrentSessionData.script.length - currentStepIndex;
					stepIndicator.textContent = `Étape ${currentStepNumber} / ${totalSteps}`;

				} else {
					stepIndicator.textContent = 'Préparation...';
					// Si aucune étape n'est trouvée, on pourrait réinitialiser hypnoLastSpokenText
					// pour forcer la relecture si on revient à la première étape ? (à voir si nécessaire)
					// hypnoLastSpokenText = null;
				}

				if (remaining <= 0 && hypnoTimerInterval) {
					 console.log("Session hypnose terminée naturellement.");
					 hypnoSessionCompleted = true;
					 stopHypnoSession();
				 }
			}
			// *** FIN DU REMPLACEMENT POUR updateHypnoTimer ***

            function startHypnoSession(sessionKey) {
                console.log(`Démarrage session: ${sessionKey}`);
                hypnoCurrentSessionData = sessionsData[sessionKey]; if (!hypnoCurrentSessionData) { UI.showToast("Erreur session.", "error"); return; }

                // Récupération des éléments UI
                const menu = document.getElementById('hypnose-menu');
                const sessionView = document.getElementById('hypnose-session');
                const startBtn = document.getElementById('start-session-btn');
                const stopBtn = document.getElementById('stop-session-btn');
                const pauseBtn = document.getElementById('pause-session-btn');
                const resumeBtn = document.getElementById('resume-session-btn');
                const timerDisplay = sessionView?.querySelector('.timer');
                const progressBar = document.getElementById('session-progress-bar');
                const sessionTextContent = document.getElementById('session-text-content');
                const stepIndicator = document.getElementById('session-step-indicator');
                const noiseSelect = document.getElementById('hypno-noise');
                const volumeSlider = document.getElementById('hypno-volume');
                const ttsToggle = document.getElementById('hypno-tts-enable');
                const voiceSelect = document.getElementById('hypno-voice-select');


                // Initialisation état
                hypnoIsPaused = false;
                hypnoPauseStartTime = 0;
                hypnoTotalPauseDuration = 0;
                hypnoSessionCompleted = false;
                hypnoLastSpokenText = null;
                hypnoNoiseType = noiseSelect.value;
                hypnoVolume = parseFloat(volumeSlider.value);
                hypnoTtsEnabled = ttsToggle.checked;

                // Mise à jour UI initiale
                const firstStepText = hypnoCurrentSessionData.script[0]?.text || 'Préparation...';
                const firstStepTextEscaped = Utils.escapeHtml(firstStepText);
                hypnoLastSpokenText = firstStepText; // Définit texte initial
                sessionTextContent.innerHTML = `<p data-raw-text="${firstStepTextEscaped}">${firstStepTextEscaped}</p>`;
                stepIndicator.textContent = `Étape 1 / ${hypnoCurrentSessionData.script.length}`;
                timerDisplay.textContent = Utils.formatTime(hypnoCurrentSessionData.duration);
                progressBar.style.width = '0%';

                // Affichage/Masquage + Désactivation contrôles
                menu.classList.add('hidden');
                sessionView.classList.remove('hidden');
                startBtn.classList.add('hidden');
                stopBtn.classList.remove('hidden');
                pauseBtn.classList.remove('hidden');
                resumeBtn.classList.add('hidden'); // Resume caché au début
                noiseSelect.disabled = true; volumeSlider.disabled = true; ttsToggle.disabled = true; voiceSelect.disabled = true;

                console.log(`Audio: ${hypnoNoiseType} vol ${hypnoVolume}. TTS: ${hypnoTtsEnabled}`);
                if (hypnoNoiseType !== 'none' && hypnoVolume > 0) AudioManager.playNoise(hypnoNoiseType, hypnoVolume);
                if (hypnoTtsEnabled && TTSManager.isSupported() && hypnoLastSpokenText) TTSManager.speak(hypnoLastSpokenText); // Lecture 1ere étape

                hypnoSessionEndTime = Date.now() + hypnoCurrentSessionData.duration * 1000;
                if(hypnoTimerInterval) clearInterval(hypnoTimerInterval);
                hypnoTimerInterval = setInterval(updateHypnoTimer, 500); // Démarrage timer

                UI.showToast(`Session '${sessionKey}' démarrée.`, "info");
            }

            function pauseHypnoSession() {
                 if (!hypnoCurrentSessionData || hypnoIsPaused) return;
                 hypnoIsPaused = true;
                 hypnoPauseStartTime = Date.now();
                 if(hypnoTimerInterval) clearInterval(hypnoTimerInterval); // Arrête le timer JS
                 AudioManager.suspendAudio().catch(e => console.warn("Echec suspend audio context", e)); // Met l'audio en pause
                 if (TTSManager.isSpeaking()) TTSManager.cancel(); // Arrête la parole en cours

                 document.getElementById('pause-session-btn')?.classList.add('hidden');
                 document.getElementById('resume-session-btn')?.classList.remove('hidden');
                 UI.showToast("Session en pause.", "info");
             }

            function resumeHypnoSession() {
                 if (!hypnoCurrentSessionData || !hypnoIsPaused) return;
                 const pauseDuration = Date.now() - hypnoPauseStartTime;
                 hypnoTotalPauseDuration += pauseDuration; // Ajoute durée pause au total
                 hypnoIsPaused = false;
                 hypnoPauseStartTime = 0;

                 AudioManager.resumeAudio().catch(e => console.warn("Echec resume audio context", e)); // Reprend l'audio
                 if (hypnoTtsEnabled && TTSManager.isSupported() && hypnoLastSpokenText) {
                    TTSManager.speak(hypnoLastSpokenText); // Relit le texte où on s'est arrêté
                 }

                 if(hypnoTimerInterval) clearInterval(hypnoTimerInterval);
                 updateHypnoTimer(); // Appel immédiat pour rafraîchir affichage
                 hypnoTimerInterval = setInterval(updateHypnoTimer, 500); // Redémarre le timer

                 document.getElementById('pause-session-btn')?.classList.remove('hidden');
                 document.getElementById('resume-session-btn')?.classList.add('hidden');
                 UI.showToast("Session reprise.", "info");
             }

            function stopHypnoSession(forced = false) {
                console.log("Arrêt session hypnose.", forced ? "(Forcé)" : "");
                const sessionEndedNaturally = !forced && hypnoSessionCompleted;
                if(hypnoTimerInterval) clearInterval(hypnoTimerInterval); hypnoTimerInterval = null;
                AudioManager.stopNoise(); // Arrête avec fondu par défaut
                if (TTSManager.isSpeaking()) TTSManager.cancel();

                if (hypnoCurrentSessionData) {
                     const sessionKey = Object.keys(sessionsData).find(key => sessionsData[key] === hypnoCurrentSessionData);
                     if(sessionKey) Store.addSessionLog({ sessionKey, duration: hypnoCurrentSessionData.duration, completed: sessionEndedNaturally });
                 }

                // Réinitialisation état et UI
                hypnoCurrentSessionData = null; hypnoSessionCompleted = false; hypnoIsPaused = false; hypnoTotalPauseDuration = 0; hypnoLastSpokenText = null;

                const menu = document.getElementById('hypnose-menu');
                const sessionView = document.getElementById('hypnose-session');
                const startBtn = document.getElementById('start-session-btn');
                const stopBtn = document.getElementById('stop-session-btn');
                const pauseBtn = document.getElementById('pause-session-btn');
                const resumeBtn = document.getElementById('resume-session-btn');
                const noiseSelect = document.getElementById('hypno-noise');
                const volumeSlider = document.getElementById('hypno-volume');
                const ttsToggle = document.getElementById('hypno-tts-enable');
                const voiceSelect = document.getElementById('hypno-voice-select');
                const progressBar = document.getElementById('session-progress-bar');

                if (sessionView) sessionView.classList.add('hidden');
                if (menu) menu.classList.remove('hidden');
                if (stopBtn) stopBtn.classList.add('hidden');
                if (pauseBtn) pauseBtn.classList.add('hidden');
                if (resumeBtn) resumeBtn.classList.add('hidden');
                if (startBtn) { startBtn.classList.remove('hidden'); startBtn.textContent = "▶️ Sélectionner"; startBtn.disabled = true; startBtn.onclick = null; }
                if (noiseSelect) noiseSelect.disabled = false;
                if (volumeSlider) volumeSlider.disabled = false;
                if (ttsToggle) ttsToggle.disabled = !TTSManager.isSupported();
                if (voiceSelect) voiceSelect.disabled = !TTSManager.isSupported();
                if (progressBar) progressBar.style.width = '0%';

                if (!forced) UI.showToast(sessionEndedNaturally ? "Session terminée !" : "Session arrêtée.", sessionEndedNaturally ? "success" : "warning");
            }

            function initHypnosePage() {
                 console.log("Init Hypnose");
                 const menu = document.getElementById('hypnose-menu');
                 const sessionView = document.getElementById('hypnose-session');
                 const startBtn = document.getElementById('start-session-btn');
                 const stopBtn = document.getElementById('stop-session-btn');
                 const pauseBtn = document.getElementById('pause-session-btn');
                 const resumeBtn = document.getElementById('resume-session-btn');
                 const ttsToggle = document.getElementById('hypno-tts-enable');
                 const voiceSelect = document.getElementById('hypno-voice-select');
                 const ttsStatus = document.getElementById('tts-status');

                 // Reset UI
                 menu?.classList.remove('hidden');
                 sessionView?.classList.add('hidden');
                 startBtn?.classList.remove('hidden'); startBtn.textContent = "▶️ Sélectionner"; startBtn.disabled = true; startBtn.onclick = null;
                 stopBtn?.classList.add('hidden');
                 pauseBtn?.classList.add('hidden');
                 resumeBtn?.classList.add('hidden');

                 // Setup TTS Controls
                 if (ttsToggle && ttsStatus && voiceSelect) {
                     const isTtsSupported = TTSManager.isSupported();
                     ttsToggle.disabled = !isTtsSupported;
                     voiceSelect.disabled = !isTtsSupported;
                     ttsStatus.textContent = isTtsSupported ? '' : "(Lecture vocale non supportée par votre appareil/navigateur)";
                     if (isTtsSupported) {
                         ttsToggle.checked = Store.getTtsPreference();
                         TTSManager.populateVoiceList(); // Assure que la liste est à jour
                         voiceSelect.value = Store.getPreferredVoiceURI() || ""; // Select saved voice or default

                         pageHandlers.ttsToggleChange = handleTtsToggleChange;
                         pageHandlers.voiceSelectChange = handleVoiceSelectChange;
                         ttsToggle.removeEventListener('change', pageHandlers.ttsToggleChange); ttsToggle.addEventListener('change', pageHandlers.ttsToggleChange);
                         voiceSelect.removeEventListener('change', pageHandlers.voiceSelectChange); voiceSelect.addEventListener('change', pageHandlers.voiceSelectChange);
                     } else { ttsToggle.checked = false; }
                 }

                 // Attach button listeners using pageHandlers
                 pageHandlers.hypnoMenuClick = handleHypnoMenuClick;
                 pageHandlers.hypnoPauseClick = pauseHypnoSession;
                 pageHandlers.hypnoResumeClick = resumeHypnoSession;
                 pageHandlers.hypnoStopClick = () => stopHypnoSession(); // Need wrapper lambda

                 menu?.removeEventListener('click', pageHandlers.hypnoMenuClick); menu?.addEventListener('click', pageHandlers.hypnoMenuClick);
                 pauseBtn?.removeEventListener('click', pageHandlers.hypnoPauseClick); pauseBtn?.addEventListener('click', pageHandlers.hypnoPauseClick);
                 resumeBtn?.removeEventListener('click', pageHandlers.hypnoResumeClick); resumeBtn?.addEventListener('click', pageHandlers.hypnoResumeClick);
                 stopBtn?.removeEventListener('click', pageHandlers.hypnoStopClick); stopBtn?.addEventListener('click', pageHandlers.hypnoStopClick);

                 console.log("Hypnose listeners attachés.");
             }

            function handleHypnoMenuClick(e) {
                if (e.target.tagName === 'BUTTON' && e.target.dataset.session) {
                    const sessionKey = e.target.dataset.session;
                    console.log(`Session sélectionnée: ${sessionKey}`);
                    const sessionData = sessionsData[sessionKey]; if (!sessionData) return;
                    const startBtn = document.getElementById('start-session-btn');
                    const sessionTitle = document.getElementById('session-title');
                    const sessionView = document.getElementById('hypnose-session');
                    const timerDisplay = sessionView?.querySelector('.timer');
                    const sessionTextContent = document.getElementById('session-text-content');
                    const stepIndicator = document.getElementById('session-step-indicator');
                    const progressBar = document.getElementById('session-progress-bar');

                    if (sessionTitle) sessionTitle.textContent = sessionData.title + " (Prêt)";
                    if (timerDisplay) timerDisplay.textContent = Utils.formatTime(sessionData.duration);
                    if (sessionTextContent) sessionTextContent.innerHTML = `<p>Préparez-vous. Cliquez sur "Démarrer".</p>`;
                    if (stepIndicator) stepIndicator.textContent = `Durée: ${Math.round(sessionData.duration / 60)} min`;
                    if (progressBar) progressBar.style.width = '0%';

                    if (startBtn) {
                        startBtn.textContent = `▶️ Démarrer`;
                        // Nettoyer ancien listener avant d'ajouter le nouveau
                        startBtn.onclick = null;
                        startBtn.onclick = () => { console.log(`Démarrage session ${sessionKey} via bouton.`); startHypnoSession(sessionKey); };
                        startBtn.disabled = false;
                    }
                    sessionView?.classList.remove('hidden');
                    sessionView?.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Assurer que les bons boutons sont visibles/cachés
                    document.getElementById('stop-session-btn')?.classList.add('hidden');
                    document.getElementById('pause-session-btn')?.classList.add('hidden');
                    document.getElementById('resume-session-btn')?.classList.add('hidden');
                     // Activer les contrôles audio/tts (qui étaient peut-être désactivés)
                     document.getElementById('hypno-noise').disabled = false;
                     document.getElementById('hypno-volume').disabled = false;
                     const ttsToggle = document.getElementById('hypno-tts-enable');
                     const voiceSelect = document.getElementById('hypno-voice-select');
                     const isTtsSupported = TTSManager.isSupported();
                     if (ttsToggle) ttsToggle.disabled = !isTtsSupported;
                     if (voiceSelect) voiceSelect.disabled = !isTtsSupported;

                }
            }
            function handleTtsToggleChange(e) { Store.setTtsPreference(e.target.checked); console.log("Pref TTS:", e.target.checked); }
            function handleVoiceSelectChange(e) { Store.setPreferredVoiceURI(e.target.value); console.log("Pref Voix:", e.target.value); }
            function cleanupHypnosePage() {
                 console.log("Cleanup Hypnose");
                 if (hypnoCurrentSessionData) stopHypnoSession(true); // Arrêt forcé si on quitte la page

                 // Retrait listeners
                 const menu = document.getElementById('hypnose-menu');
                 const stopBtn = document.getElementById('stop-session-btn');
                 const pauseBtn = document.getElementById('pause-session-btn');
                 const resumeBtn = document.getElementById('resume-session-btn');
                 const ttsToggle = document.getElementById('hypno-tts-enable');
                 const voiceSelect = document.getElementById('hypno-voice-select');
                 const startBtn = document.getElementById('start-session-btn');

                 if(menu && pageHandlers.hypnoMenuClick) menu.removeEventListener('click', pageHandlers.hypnoMenuClick);
                 if(stopBtn && pageHandlers.hypnoStopClick) stopBtn.removeEventListener('click', pageHandlers.hypnoStopClick);
                 if(pauseBtn && pageHandlers.hypnoPauseClick) pauseBtn.removeEventListener('click', pageHandlers.hypnoPauseClick);
                 if(resumeBtn && pageHandlers.hypnoResumeClick) resumeBtn.removeEventListener('click', pageHandlers.hypnoResumeClick);
                 if(ttsToggle && pageHandlers.ttsToggleChange) ttsToggle.removeEventListener('change', pageHandlers.ttsToggleChange);
                 if(voiceSelect && pageHandlers.voiceSelectChange) voiceSelect.removeEventListener('change', pageHandlers.voiceSelectChange);
                 if(startBtn) startBtn.onclick = null; // Important

                 // Nettoyage des références
                 delete pageHandlers.hypnoMenuClick; delete pageHandlers.hypnoPauseClick; delete pageHandlers.hypnoResumeClick; delete pageHandlers.hypnoStopClick; delete pageHandlers.ttsToggleChange; delete pageHandlers.voiceSelectChange;
             }

            // --- Page Générateur de Sons (MAJ Favoris) ---
            let soundTimerInterval_page = null; let soundTimerEndTime_page = 0;
            function updateSoundTimerDisplay_page() { const statusSpan = document.getElementById('sound-timer-status'); if (!statusSpan || !AudioManager.isPlaying() || !noiseTimer) { if (statusSpan) statusSpan.textContent = ''; clearInterval(soundTimerInterval_page); soundTimerInterval_page = null; return; } const now = Date.now(); const remainingSeconds = Math.max(0, Math.round((soundTimerEndTime_page - now) / 1000)); if (remainingSeconds > 0) statusSpan.textContent = `Arrêt dans: ${Utils.formatTime(remainingSeconds)}`; else { statusSpan.textContent = ''; clearInterval(soundTimerInterval_page); soundTimerInterval_page = null; } }

            function initSoundsPage() {
                console.log("Init Sounds");
                const playBtn = document.getElementById('play-sound-btn');
                const stopBtn = document.getElementById('stop-sound-btn');
                const volumeSlider = document.getElementById('sound-volume');
                const saveFavBtn = document.getElementById('save-favorite-btn');

                pageHandlers.soundPlay = handlePlaySound_page;
                pageHandlers.soundStop = handleStopSound_page;
                pageHandlers.soundVolumeInput = handleSoundVolumeInput_page;
                pageHandlers.soundVolumeChange = handleSoundVolumeChange_page;
                pageHandlers.audioTimerStart = handleAudioTimerStart_page;
                pageHandlers.audioTimerEnd = handleAudioTimerEnd_page;
                pageHandlers.audioTimerClear = handleAudioTimerClear_page;
                pageHandlers.saveFavorite = handleSaveFavoriteSound_page;
                pageHandlers.playFavorite = handlePlayFavoriteSound_page;
                pageHandlers.deleteFavorite = handleDeleteFavoriteSound_page;

                playBtn?.removeEventListener('click', pageHandlers.soundPlay); playBtn?.addEventListener('click', pageHandlers.soundPlay);
                stopBtn?.removeEventListener('click', pageHandlers.soundStop); stopBtn?.addEventListener('click', pageHandlers.soundStop);
                volumeSlider?.removeEventListener('input', pageHandlers.soundVolumeInput); volumeSlider?.addEventListener('input', pageHandlers.soundVolumeInput);
                volumeSlider?.removeEventListener('change', pageHandlers.soundVolumeChange); volumeSlider?.addEventListener('change', pageHandlers.soundVolumeChange);
                saveFavBtn?.removeEventListener('click', pageHandlers.saveFavorite); saveFavBtn?.addEventListener('click', pageHandlers.saveFavorite);
                document.removeEventListener('audiotimerstart', pageHandlers.audioTimerStart); document.addEventListener('audiotimerstart', pageHandlers.audioTimerStart);
                document.removeEventListener('audiotimerend', pageHandlers.audioTimerEnd); document.addEventListener('audiotimerend', pageHandlers.audioTimerEnd);
                document.removeEventListener('audiotimerclear', pageHandlers.audioTimerClear); document.addEventListener('audiotimerclear', pageHandlers.audioTimerClear);

                // Affichage initial favoris
                updateFavoriteSoundsList_page();

                // Reset UI
                 stopBtn?.classList.add('hidden');
                 playBtn?.classList.remove('hidden');
                 document.getElementById('sound-type-select').disabled = false;
                 document.getElementById('sound-timer').disabled = false;
                 document.getElementById('sound-timer-status').textContent = '';
                 if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); soundTimerInterval_page = null;

                console.log("Sounds page listeners attachés.");
             }

            function updateFavoriteSoundsList_page() {
                const favorites = Store.getFavoriteSounds();
                UI.displayFavoriteSounds(favorites, pageHandlers.playFavorite, pageHandlers.deleteFavorite);
            }
            function handleSaveFavoriteSound_page() {
                const type = document.getElementById('sound-type-select').value;
                const volume = parseFloat(document.getElementById('sound-volume').value);
                const newFav = Store.addFavoriteSound({ type, volume });
                if (newFav) {
                    updateFavoriteSoundsList_page();
                    UI.showToast(`Favori "${newFav.name}" enregistré !`, "success");
                }
            }
            function handlePlayFavoriteSound_page(fav) {
                console.log("Lecture favori:", fav);
                document.getElementById('sound-type-select').value = fav.type;
                const volSlider = document.getElementById('sound-volume');
                volSlider.value = fav.volume;
                // Mettre à jour l'output du slider
                if (volSlider.nextElementSibling?.tagName === 'OUTPUT') volSlider.nextElementSibling.textContent = fav.volume.toFixed(2);
                // Laisser le timer à 0 (infini) par défaut pour un favori
                document.getElementById('sound-timer').value = 0;
                document.getElementById('sound-timer-status').textContent = '';
                if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); soundTimerInterval_page = null;

                handlePlaySound_page(); // Lance la lecture avec les nouveaux réglages
                UI.showToast(`Lecture favori: ${fav.name}`, "info");
            }
            function handleDeleteFavoriteSound_page(id) {
                const fav = Store.getFavoriteSounds().find(f => f.id === id);
                if (fav && confirm(`Supprimer le favori "${fav.name}" ?`)) {
                    Store.removeFavoriteSound(id);
                    updateFavoriteSoundsList_page();
                    UI.showToast(`Favori "${fav.name}" supprimé.`, "info");
                }
            }

            function handlePlaySound_page() { const type = document.getElementById('sound-type-select').value; const volume = parseFloat(document.getElementById('sound-volume').value); const durationMinutes = parseInt(document.getElementById('sound-timer').value, 10) || 0; const success = AudioManager.playNoise(type, volume, durationMinutes); if (success) { document.getElementById('play-sound-btn')?.classList.add('hidden'); document.getElementById('stop-sound-btn')?.classList.remove('hidden'); document.getElementById('sound-type-select').disabled = true; document.getElementById('sound-timer').disabled = true; } }
            function handleStopSound_page(immediate = false) { const stopped = AudioManager.stopNoise(immediate); if (stopped) { document.getElementById('play-sound-btn')?.classList.remove('hidden'); document.getElementById('stop-sound-btn')?.classList.add('hidden'); document.getElementById('sound-type-select').disabled = false; document.getElementById('sound-timer').disabled = false; handleAudioTimerClear_page(); /* Assure nettoyage timer UI */ } }
            function handleSoundVolumeInput_page(e) { const volumeOutput = e.target.nextElementSibling; if (volumeOutput?.tagName === 'OUTPUT') volumeOutput.textContent = parseFloat(e.target.value).toFixed(2); if (AudioManager.isPlaying()) AudioManager.setVolume(parseFloat(e.target.value)); }
            function handleSoundVolumeChange_page(e) { if (AudioManager.isPlaying()) AudioManager.setVolume(parseFloat(e.target.value)); } // Peut-être redondant avec input, mais garde pour 'change'
            function handleAudioTimerStart_page(e) { const durationMinutes = e.detail.durationMinutes; soundTimerEndTime_page = Date.now() + durationMinutes * 60 * 1000; if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); updateSoundTimerDisplay_page(); soundTimerInterval_page = setInterval(updateSoundTimerDisplay_page, 1000); }
            function handleAudioTimerEnd_page() { handleStopSound_page(); }
            function handleAudioTimerClear_page() { if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); soundTimerInterval_page = null; const statusSpan = document.getElementById('sound-timer-status'); if (statusSpan) statusSpan.textContent = ''; }

            function cleanupSoundsPage() {
                 console.log("Cleanup Sounds");
                 if (AudioManager.isPlaying()) handleStopSound_page(true); // Arrêt immédiat

                 const playBtn = document.getElementById('play-sound-btn');
                 const stopBtn = document.getElementById('stop-sound-btn');
                 const volumeSlider = document.getElementById('sound-volume');
                 const saveFavBtn = document.getElementById('save-favorite-btn');

                 if(pageHandlers.soundPlay) playBtn?.removeEventListener('click', pageHandlers.soundPlay);
                 if(pageHandlers.soundStop) stopBtn?.removeEventListener('click', pageHandlers.soundStop);
                 if(pageHandlers.soundVolumeInput) volumeSlider?.removeEventListener('input', pageHandlers.soundVolumeInput);
                 if(pageHandlers.soundVolumeChange) volumeSlider?.removeEventListener('change', pageHandlers.soundVolumeChange);
                 if(pageHandlers.saveFavorite) saveFavBtn?.removeEventListener('click', pageHandlers.saveFavorite);
                 if(pageHandlers.audioTimerStart) document.removeEventListener('audiotimerstart', pageHandlers.audioTimerStart);
                 if(pageHandlers.audioTimerEnd) document.removeEventListener('audiotimerend', pageHandlers.audioTimerEnd);
                 if(pageHandlers.audioTimerClear) document.removeEventListener('audiotimerclear', pageHandlers.audioTimerClear);
                 // Nettoyer la liste des favoris pour enlever les listeners (si ajoutés dynamiquement sur les boutons)
                 const favList = document.getElementById('favorite-sounds-list');
                 if (favList) favList.innerHTML = '<li id="no-favorites-msg">Aucun favori enregistré.</li>'; // Reset simple

                 delete pageHandlers.soundPlay; delete pageHandlers.soundStop; delete pageHandlers.soundVolumeInput; delete pageHandlers.soundVolumeChange; delete pageHandlers.saveFavorite; delete pageHandlers.playFavorite; delete pageHandlers.deleteFavorite; delete pageHandlers.audioTimerStart; delete pageHandlers.audioTimerEnd; delete pageHandlers.audioTimerClear;

                 if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); soundTimerInterval_page = null;
                 console.log("Sounds page listeners removed.");
             }

            // --- Page Suivi (MAJ Graphique) ---
            function initTrackingPage() {
                console.log("Init Tracking");
                const form = document.getElementById('tracking-form'); const clearDataBtn = document.getElementById('clear-data-btn'); const exportJsonBtn = document.getElementById('export-data-btn'); const exportCsvBtn = document.getElementById('export-csv-btn'); const historyLimitSelect = document.getElementById('history-limit'); const chartLimitSelect = document.getElementById('chart-limit');

                pageHandlers.trackingSubmit = handleTrackingSubmit;
                pageHandlers.clearData = handleClearData;
                pageHandlers.exportJson = handleExportJson;
                pageHandlers.exportCsv = handleExportCsv;
                pageHandlers.updateTracking = updateTrackingDisplay;

                form?.removeEventListener('submit', pageHandlers.trackingSubmit); form?.addEventListener('submit', pageHandlers.trackingSubmit);
                clearDataBtn?.removeEventListener('click', pageHandlers.clearData); clearDataBtn?.addEventListener('click', pageHandlers.clearData);
                exportJsonBtn?.removeEventListener('click', pageHandlers.exportJson); exportJsonBtn?.addEventListener('click', pageHandlers.exportJson);
                exportCsvBtn?.removeEventListener('click', pageHandlers.exportCsv); exportCsvBtn?.addEventListener('click', pageHandlers.exportCsv);
                historyLimitSelect?.removeEventListener('change', pageHandlers.updateTracking); historyLimitSelect?.addEventListener('change', pageHandlers.updateTracking);
                chartLimitSelect?.removeEventListener('change', pageHandlers.updateTracking); chartLimitSelect?.addEventListener('change', pageHandlers.updateTracking);

                updateTrackingDisplay();
                console.log("Tracking page listeners attached.");
             }

            function updateTrackingDisplay() { const historyLimit = document.getElementById('history-limit')?.value || '30'; const chartLimit = document.getElementById('chart-limit')?.value || '30'; let limitHistoryNum = historyLimit === 'all' ? null : parseInt(historyLimit, 10); let limitChartDays = chartLimit === 'all' ? null : parseInt(chartLimit, 10); const entries = Store.getJournalEntries(limitHistoryNum); UI.displayJournalHistory(entries); const allJournalData = Store.getState().journal; drawIntensityChart(allJournalData, limitChartDays); }
            function handleTrackingSubmit(e) { e.preventDefault(); const form = e.target; const formData = new FormData(form); const newEntry = { intensity: formData.get('intensity'), notes: formData.get('notes') }; const savedEntry = Store.addJournalEntry(newEntry); if (savedEntry) { form.reset(); const intensityRange = document.getElementById('tracking-intensity'); if(intensityRange && intensityRange.nextElementSibling) intensityRange.nextElementSibling.textContent = intensityRange.defaultValue || '5'; UI.showToast('Entrée ajoutée.', 'success'); updateTrackingDisplay(); } else { UI.showToast("Erreur ajout entrée.", 'error'); } }
            function handleClearData() { Store.clearAllData(); }
            function handleExportJson() { try { const data = Store.getState(); const dataStr = JSON.stringify(data, null, 2); const blob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `acouphenes_zen_data_${new Date().toISOString().split('T')[0]}.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); UI.showToast("Export JSON OK.", "success"); } catch (e) { console.error("Erreur export JSON:", e); UI.showToast("Erreur export JSON.", "error"); } }
            function handleExportCsv() { try { const journal = Store.getState().journal; if (!journal || journal.length === 0) { UI.showToast("Journal vide.", "warning"); return; } const header = "DateHeureISO;Intensite;Notes\n"; const rows = journal.map(entry => { const date = entry.date; const intensity = entry.intensity; let notes = entry.notes || ""; if (notes.includes('"') || notes.includes(';') || notes.includes('\n')) { notes = `"${notes.replace(/"/g, '""')}"`; } return `${date};${intensity};${notes}`; }); const csvContent = "\uFEFF" + header + rows.join("\n"); /* Ajout BOM pour Excel FR */ const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `acouphenes_zen_journal_${new Date().toISOString().split('T')[0]}.csv`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); UI.showToast("Export CSV OK.", "success"); } catch (e) { console.error("Erreur export CSV:", e); UI.showToast("Erreur export CSV.", "error"); } }

            function drawIntensityChart(data, limitDays) {
                const container = document.getElementById('tracking-chart');
                const noDataMsg = document.getElementById('chart-no-data');
                if (!container || !noDataMsg) return;
                container.innerHTML = ''; noDataMsg.classList.add('hidden');

                let filteredData = data;
                if (limitDays !== null && limitDays > 0) {
                    const limitDate = new Date(); limitDate.setDate(limitDate.getDate() - limitDays);
                    filteredData = data.filter(entry => new Date(entry.date) >= limitDate);
                }

                if (filteredData.length < 2) { noDataMsg.classList.remove('hidden'); return; }
                filteredData.sort((a, b) => new Date(a.date) - new Date(b.date));

                // Calculer la moyenne
                const sumIntensity = filteredData.reduce((sum, entry) => sum + entry.intensity, 0);
                const averageIntensity = sumIntensity / filteredData.length;

                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, "svg");
                const containerRect = container.getBoundingClientRect();
                const svgWidth = containerRect.width || 600;
                const svgHeight = 250;
                const margin = { top: 20, right: 30, bottom: 40, left: 40 };
                const width = svgWidth - margin.left - margin.right;
                const height = svgHeight - margin.top - margin.bottom;
                svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
                svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
                svg.style.width = "100%"; svg.style.height = `${svgHeight}px`;
                const g = document.createElementNS(svgNS, "g");
                g.setAttribute("transform", `translate(${margin.left},${margin.top})`);
                svg.appendChild(g);

                const firstDate = new Date(filteredData[0].date);
                const lastDate = new Date(filteredData[filteredData.length - 1].date);
                const totalTimeDiff = Math.max(1, lastDate.getTime() - firstDate.getTime()); // Avoid division by zero
                const xScale = (date) => ((new Date(date).getTime() - firstDate.getTime()) / totalTimeDiff) * width;
                const yScale = (intensity) => height - (intensity / 10) * height;

                // Axes et Grille (comme avant)
                const yAxis = document.createElementNS(svgNS, "line"); yAxis.setAttribute("x1", 0); yAxis.setAttribute("y1", 0); yAxis.setAttribute("x2", 0); yAxis.setAttribute("y2", height); yAxis.setAttribute("class", "chart-axis"); g.appendChild(yAxis);
                [0, 2, 4, 6, 8, 10].forEach(val => { const y = yScale(val); const label = document.createElementNS(svgNS, "text"); label.setAttribute("x", -margin.left / 2 + 10); label.setAttribute("y", y); label.setAttribute("dy", "0.32em"); label.setAttribute("class", "chart-text axis-label-y"); label.textContent = val; g.appendChild(label); const gridLine = document.createElementNS(svgNS, "line"); gridLine.setAttribute("x1", 0); gridLine.setAttribute("y1", y); gridLine.setAttribute("x2", width); gridLine.setAttribute("y2", y); gridLine.setAttribute("class", "chart-grid"); g.appendChild(gridLine); });
                const xAxis = document.createElementNS(svgNS, "line"); xAxis.setAttribute("x1", 0); xAxis.setAttribute("y1", height); xAxis.setAttribute("x2", width); xAxis.setAttribute("y2", height); xAxis.setAttribute("class", "chart-axis"); g.appendChild(xAxis);
                const formatDateLabel = (date) => date.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit'});
                [firstDate, lastDate].forEach((date, index) => { if(!date) return; const x = index === 0 ? 0 : width; const label = document.createElementNS(svgNS, "text"); label.setAttribute("x", x); label.setAttribute("y", height + margin.bottom / 2); label.setAttribute("dy", "0.71em"); label.setAttribute("class", "chart-text axis-label-x"); label.style.textAnchor = index === 0 ? "start" : "end"; label.textContent = formatDateLabel(date); g.appendChild(label); });

                 // Ligne de données principale
                 const linePath = document.createElementNS(svgNS, "path");
                 const pathData = filteredData.map((d, i) => { const x = xScale(d.date); const y = yScale(d.intensity); return `${i === 0 ? 'M' : 'L'} ${x.toFixed(2)} ${y.toFixed(2)}`; }).join(" ");
                 linePath.setAttribute("d", pathData);
                 linePath.setAttribute("class", "chart-line");
                 g.appendChild(linePath);

                 // Points de données (comme avant)
                 filteredData.forEach(d => { const x = xScale(d.date); const y = yScale(d.intensity); const point = document.createElementNS(svgNS, "circle"); point.setAttribute("cx", x); point.setAttribute("cy", y); point.setAttribute("r", 4); point.setAttribute("class", "chart-point"); const title = document.createElementNS(svgNS, "title"); const pointDate = new Date(d.date); title.textContent = `${pointDate.toLocaleDateString('fr-FR')} ${pointDate.toLocaleTimeString('fr-FR',{hour:'2-digit', minute:'2-digit'})} - Intensité: ${d.intensity}`; point.appendChild(title); g.appendChild(point); });

                // *** NOUVEAU: Ligne Moyenne ***
                if (averageIntensity >= 0 && averageIntensity <= 10) {
                    const yAvg = yScale(averageIntensity);
                    const avgLine = document.createElementNS(svgNS, "line");
                    avgLine.setAttribute("x1", 0);
                    avgLine.setAttribute("y1", yAvg);
                    avgLine.setAttribute("x2", width);
                    avgLine.setAttribute("y2", yAvg);
                    avgLine.setAttribute("class", "chart-average-line");
                    g.appendChild(avgLine);
                    // Label pour la moyenne
                    const avgLabel = document.createElementNS(svgNS, "text");
                    avgLabel.setAttribute("x", width + 5); // Position à droite
                    avgLabel.setAttribute("y", yAvg);
                    avgLabel.setAttribute("dy", "0.32em");
                    avgLabel.setAttribute("class", "chart-text");
                    avgLabel.style.fill = "var(--accent-color)";
                    avgLabel.style.textAnchor = "start";
                    avgLabel.textContent = `Moy: ${averageIntensity.toFixed(1)}`;
                    g.appendChild(avgLabel);
                }

                container.appendChild(svg);
            }

            function cleanupTrackingPage() {
                 console.log("Cleanup Tracking");
                 const form = document.getElementById('tracking-form'); const clearDataBtn = document.getElementById('clear-data-btn'); const exportJsonBtn = document.getElementById('export-data-btn'); const exportCsvBtn = document.getElementById('export-csv-btn'); const historyLimitSelect = document.getElementById('history-limit'); const chartLimitSelect = document.getElementById('chart-limit');
                 if(pageHandlers.trackingSubmit) form?.removeEventListener('submit', pageHandlers.trackingSubmit);
                 if(pageHandlers.clearData) clearDataBtn?.removeEventListener('click', pageHandlers.clearData);
                 if(pageHandlers.exportJson) exportJsonBtn?.removeEventListener('click', pageHandlers.exportJson);
                 if(pageHandlers.exportCsv) exportCsvBtn?.removeEventListener('click', pageHandlers.exportCsv);
                 if(pageHandlers.updateTracking) { historyLimitSelect?.removeEventListener('change', pageHandlers.updateTracking); chartLimitSelect?.removeEventListener('change', pageHandlers.updateTracking); }
                 const container = document.getElementById('tracking-chart'); if (container) container.innerHTML = '';
                 delete pageHandlers.trackingSubmit; delete pageHandlers.clearData; delete pageHandlers.exportJson; delete pageHandlers.exportCsv; delete pageHandlers.updateTracking;
                 console.log("Tracking listeners removed.");
             }

            // --- Page Ressources ---
            function initResourcesPage() { console.log("Init Ressources"); }
            function cleanupResourcesPage() { console.log("Cleanup Ressources"); }

            // --- Initialisation Générale & Widgets ---
             function initThemeToggle() { const toggleButton = document.getElementById('theme-toggle'); if (toggleButton) { toggleButton.addEventListener('click', () => { const currentTheme = Store.getThemePreference(); const newTheme = currentTheme === 'dark' ? 'light' : 'dark'; Store.updateThemePreference(newTheme); /* applyThemePreference est appelé dans update */ }); Store.applyThemePreference(); } }

             // Init Widget Entrée Rapide
             function initQuickEntry() {
                 const slider = document.getElementById('quick-intensity-slider');
                 const output = document.getElementById('quick-intensity-output');
                 const submitBtn = document.getElementById('quick-intensity-submit');

                 if (slider && output && submitBtn) {
                     pageHandlers.quickEntrySubmit = () => {
                         const intensity = slider.value;
                         const saved = Store.addJournalEntry({ intensity: intensity, notes: "Entrée rapide" });
                         if (saved) {
                             UI.showToast(`Intensité ${intensity}/10 notée.`, 'success');
                             // Optionnel: Mettre à jour l'historique/graphique si la page suivi est active
                             if (window.location.hash === '#tracking') {
                                 updateTrackingDisplay();
                             }
                             // Reset slider to default? Or keep value? Let's reset.
                             slider.value = 5;
                             output.textContent = 5;
                         } else {
                             UI.showToast("Erreur notation rapide.", 'error');
                         }
                     };
                     // Nettoyer listener précédent si existe
                     submitBtn.removeEventListener('click', pageHandlers.quickEntrySubmit);
                     submitBtn.addEventListener('click', pageHandlers.quickEntrySubmit);
                     // Assurer que l'output initial est correct
                     output.textContent = slider.value;

                 } else {
                     console.warn("Widget d'entrée rapide non trouvé.");
                 }
             }

            // --- DÉMARRAGE DE L'APPLICATION ---
            Router.init();
            console.log("Acouphènes Zen App Ready v1.1 Enhanced.");

        }); // Fin de DOMContentLoaded
    </script>
</body>
</html>
