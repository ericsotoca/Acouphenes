<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Titre mis √† jour pour refl√©ter la finalisation -->
    <title>Acouph√®nes Zen v1.1 - Gestion & Auto-hypnose</title>
    <style>
        /* --- CSS Int√©gr√© --- */

        /* Variables (Th√®me Clair par d√©faut) */
        :root {
            --bg-color: #f4f7f9;
            --text-color: #212529; /* L√©g√®rement plus fonc√© */
            --primary-color: #0056b3; /* Bleu plus soutenu */
            --secondary-color: #5a9a00; /* Vert plus soutenu */
            --accent-color: #ffc107; /* Jaune plus vif */
            --card-bg: #ffffff;
            --border-color: #dee2e6; /* Gris plus standard */
            --input-bg: #ffffff;
            --button-text: #ffffff;
            --link-color: var(--primary-color);
            --disabled-color: #adb5bd; /* Gris pour d√©sactiv√© */
            --shadow-color: rgba(0, 0, 0, 0.1);
            --danger-color: #dc3545; /* Rouge Bootstrap */
            --success-color: #28a745; /* Vert Bootstrap */
            --info-color: #17a2b8; /* Cyan Bootstrap */
            --warning-color: #ffc107; /* Jaune Bootstrap */
            --light-grey: #f8f9fa; /* Gris tr√®s clair */

            --nav-height: 70px;
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-size-base: 16px;
            --line-height-base: 1.6;

            --spacing-xs: 4px;
            --spacing-s: 8px;
            --spacing-m: 16px;
            --spacing-l: 24px;
            --spacing-xl: 32px;

            --border-radius: 4px;
            --shadow: 0 2px 5px var(--shadow-color);
            --focus-outline-color: color-mix(in srgb, var(--primary-color) 50%, transparent);
            --focus-outline-width: 3px; /* Plus visible */
        }

        /* Th√®me Sombre */
        body.dark-mode {
            --bg-color: #212529; /* Noir doux */
            --text-color: #e9ecef; /* Gris tr√®s clair */
            --primary-color: #4dabf7; /* Bleu clair */
            --secondary-color: #94d82d; /* Vert citron */
            --accent-color: #ffd43b; /* Jaune clair */
            --card-bg: #343a40; /* Gris fonc√© */
            --border-color: #495057; /* Gris moyen */
            --input-bg: #495057;
            --button-text: #212529; /* Texte sombre pour boutons clairs */
            --link-color: var(--primary-color);
            --disabled-color: #6c757d; /* Gris sombre */
            --shadow-color: rgba(0, 0, 0, 0.3);
            --danger-color: #f57782; /* Rouge clair */
            --success-color: #7ee2a1; /* Vert clair */
            --info-color: #6edff6; /* Cyan clair */
            --warning-color: #ffe066; /* Jaune clair */
            --light-grey: #343a40;
            --focus-outline-color: color-mix(in srgb, var(--accent-color) 70%, transparent);
        }

        /* Reset et Styles Globaux */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { font-size: var(--font-size-base); scroll-behavior: smooth; }
        body { font-family: var(--font-main); background-color: var(--bg-color); color: var(--text-color); line-height: var(--line-height-base); transition: background-color 0.3s ease, color 0.3s ease; }
        #app { max-width: 900px; margin: 0 auto; padding: var(--spacing-l); }

        /* Accessibilit√©: Style de focus visible */
        *:focus-visible {
            outline: var(--focus-outline-width) solid var(--focus-outline-color);
            outline-offset: 2px;
            box-shadow: 0 0 0 var(--focus-outline-width) var(--focus-outline-color);
            border-radius: var(--border-radius); /* Assure que l'outline suit la forme */
        }
        /* Ajustement sp√©cifique pour les inputs/textarea */
         input:focus-visible, textarea:focus-visible, select:focus-visible {
            border-color: var(--primary-color); /* Garde la bordure interne */
         }
         /* Assurer que les boutons n'ont pas d'outline par d√©faut qui interf√®re */
         button:focus { outline: none; }


        /* Navigation */
        nav { position: fixed; top: 0; left: 0; width: 100%; background-color: var(--card-bg); box-shadow: var(--shadow); padding: var(--spacing-s) var(--spacing-l); z-index: 1000; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        nav .nav-brand { font-weight: bold; font-size: 1.3em; color: var(--primary-color); text-decoration: none; margin-right: var(--spacing-l); }
        nav ul { list-style: none; display: flex; gap: var(--spacing-m); flex-wrap: wrap; align-items: center; }
        nav a { text-decoration: none; color: var(--link-color); font-weight: 500; transition: color 0.2s ease, background-color 0.2s ease; padding: var(--spacing-s) var(--spacing-m); border-radius: var(--border-radius); }
        nav a:hover, nav a.active { color: var(--button-text); background-color: var(--primary-color); } /* Am√©lioration contraste hover/active */

        /* Contenu Principal */
        main { min-height: calc(100vh - var(--nav-height) - 120px); /* Ajust√© pour footer plus grand */ }
        .content-section { background-color: var(--card-bg); padding: var(--spacing-l); border-radius: var(--border-radius); box-shadow: var(--shadow); margin-bottom: var(--spacing-l); animation: fadeIn 0.5s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* √âl√©ments de Formulaire */
        fieldset { border: 1px solid var(--border-color); padding: var(--spacing-m); border-radius: var(--border-radius); margin-bottom: var(--spacing-l); }
        legend { font-weight: 600; padding: 0 var(--spacing-s); color: var(--primary-color); margin-bottom: var(--spacing-m); }
        label { display: block; margin-bottom: var(--spacing-s); font-weight: 500; }
        .radio-group label, .checkbox-group label { display: inline-block; margin-right: var(--spacing-m); font-weight: normal; vertical-align: middle; cursor: pointer; }
        .radio-group input[type="radio"], .checkbox-group input[type="checkbox"] { margin-right: var(--spacing-xs); vertical-align: middle; cursor: pointer; }
        input[type="text"], input[type="number"], textarea, select { width: 100%; padding: var(--spacing-s) var(--spacing-m); margin-bottom: var(--spacing-m); border: 1px solid var(--border-color); border-radius: var(--border-radius); background-color: var(--input-bg); color: var(--text-color); font-size: inherit; transition: border-color 0.2s ease, box-shadow 0.2s ease; }
        input:focus, textarea:focus, select:focus { outline: none; border-color: var(--primary-color); /* Ombre g√©r√©e par focus-visible global */ }
        textarea { min-height: 100px; resize: vertical; }
        input[type="range"] { width: calc(100% - 50px); vertical-align: middle; cursor: pointer; margin-bottom: var(--spacing-m); }
        output { display: inline-block; min-width: 30px; text-align: right; font-weight: bold; color: var(--primary-color); vertical-align: middle; margin-left: var(--spacing-s); }

        /* Boutons */
        button, .button { display: inline-flex; /* Pour aligner ic√¥nes/texte */ align-items: center; justify-content: center; background-color: var(--primary-color); color: var(--button-text); border: none; padding: var(--spacing-m) var(--spacing-l); border-radius: var(--border-radius); font-size: inherit; font-weight: 500; cursor: pointer; transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease; text-align: center; text-decoration: none; margin-right: var(--spacing-s); margin-bottom: var(--spacing-s); gap: var(--spacing-s); /* Espace entre texte et ic√¥ne √©ventuelle */ }
        button:last-child, .button:last-child { margin-right: 0; }
        button:hover, .button:hover { background-color: color-mix(in srgb, var(--primary-color) 85%, black); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); }
        button:active, .button:active { transform: translateY(1px); } /* Effet enfonc√© */
        button:disabled, .button:disabled { background-color: var(--disabled-color); color: color-mix(in srgb, var(--text-color) 70%, var(--disabled-color)); cursor: not-allowed; box-shadow: none; transform: none; }
        .button-secondary { background-color: var(--secondary-color); }
        .button-secondary:hover { background-color: color-mix(in srgb, var(--secondary-color) 85%, black); }
        .button-danger { background-color: var(--danger-color); }
        .button-danger:hover { background-color: color-mix(in srgb, var(--danger-color) 80%, black); }
        .button-icon { padding: var(--spacing-s); font-size: 1.2em; line-height: 1; min-width: 40px; /* Assurer taille minimale pour clics */ } /* Pour boutons avec juste une ic√¥ne */

        /* Utilitaires */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .mt-s { margin-top: var(--spacing-s); } .mt-m { margin-top: var(--spacing-m); } .mt-l { margin-top: var(--spacing-l); }
        .mb-s { margin-bottom: var(--spacing-s); } .mb-m { margin-bottom: var(--spacing-m); } .mb-l { margin-bottom: var(--spacing-l); }
        .mr-m { margin-right: var(--spacing-m); } .ml-m { margin-left: var(--spacing-m); }
        .alert { padding: var(--spacing-m); margin-top: var(--spacing-m); margin-bottom: var(--spacing-m); border-radius: var(--border-radius); border: 1px solid transparent; }
        .alert-info { color: color-mix(in srgb, var(--info-color) 80%, black); background-color: color-mix(in srgb, var(--info-color) 15%, transparent); border-color: color-mix(in srgb, var(--info-color) 30%, transparent); }
        .alert-warning { color: color-mix(in srgb, var(--warning-color) 80%, black); background-color: color-mix(in srgb, var(--warning-color) 25%, transparent); border-color: color-mix(in srgb, var(--warning-color) 40%, transparent); }
        .alert-success { color: color-mix(in srgb, var(--success-color) 80%, black); background-color: color-mix(in srgb, var(--success-color) 15%, transparent); border-color: color-mix(in srgb, var(--success-color) 30%, transparent); }
        .alert-danger { color: color-mix(in srgb, var(--danger-color) 80%, black); background-color: color-mix(in srgb, var(--danger-color) 15%, transparent); border-color: color-mix(in srgb, var(--danger-color) 30%, transparent); }
        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 25px; border-radius: 25px; color: white; z-index: 1001; box-shadow: 0 3px 10px rgba(0,0,0,0.2); opacity: 0; transition: opacity 0.5s ease, bottom 0.5s ease; font-size: 0.95em; text-align: center; }
        .toast-info { background-color: var(--info-color); } .toast-success { background-color: var(--success-color); } .toast-warning { background-color: var(--warning-color); color: #333; } .toast-error { background-color: var(--danger-color); }
        .toast.show { opacity: 1; bottom: 30px; }

        /* Styles sp√©cifiques aux modules */
        /* --- Hypnose --- */
        #hypnose-session .timer { font-size: 2.5em; font-weight: bold; text-align: center; margin: var(--spacing-m) 0; color: var(--secondary-color); font-variant-numeric: tabular-nums; }
        #hypnose-session .progress-bar-container { height: 8px; background-color: var(--border-color); border-radius: 4px; overflow: hidden; margin-bottom: var(--spacing-m); }
        #hypnose-session .progress-bar { height: 100%; width: 0%; background-color: var(--secondary-color); transition: width 0.5s linear; }
        #hypnose-session .session-text { background-color: color-mix(in srgb, var(--bg-color) 95%, var(--text-color)); padding: var(--spacing-m) var(--spacing-l); border-radius: var(--border-radius); min-height: 180px; border-left: 5px solid var(--primary-color); font-size: 1.1em; line-height: 1.7; overflow-y: auto; max-height: 300px; margin-bottom: var(--spacing-l); }
        #hypnose-session .controls { border-top: 1px solid var(--border-color); padding-top: var(--spacing-m); }
        #hypnose-session .controls > div { margin-bottom: var(--spacing-m); display: flex; flex-wrap: wrap; align-items: center; gap: var(--spacing-s) var(--spacing-m); }
        #hypnose-session .controls label { display: inline-block; margin-right: var(--spacing-xs); min-width: 80px; }
        #hypnose-session .controls input[type="range"] { width: 120px; vertical-align: middle; margin-bottom: 0; /* Ajust√© car dans flexbox */ }
        #hypnose-session .controls select { width: auto; display: inline-block; vertical-align: middle; margin-bottom: 0; max-width: 180px; /* Emp√™che le select de voix de devenir trop large */ }
        #hypnose-session .controls .checkbox-group { margin-top: 0; width: 100%; /* Prendre toute la largeur */}
        #hypnose-session .tts-status { font-size: 0.9em; font-style: italic; color: var(--disabled-color); }
        #hypnose-session .session-main-controls { text-align: center; gap: var(--spacing-m); justify-content: center; } /* Classe pour les boutons Start/Pause/Stop */

        /* --- Sons Th√©rapeutiques --- */
        #favorite-sounds { border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: var(--spacing-m); margin-top: var(--spacing-l); }
        #favorite-sounds legend { margin-bottom: var(--spacing-s); }
        #favorite-sounds-list { display: flex; flex-wrap: wrap; gap: var(--spacing-s); list-style: none; padding: 0; margin-top: var(--spacing-s); }
        #favorite-sounds-list li { display: flex; align-items: center; gap: var(--spacing-xs); background-color: color-mix(in srgb, var(--light-grey) 50%, transparent); padding: var(--spacing-xs) var(--spacing-s); border-radius: var(--border-radius); }
        #favorite-sounds-list .play-fav-btn { background-color: transparent; color: var(--primary-color); padding: var(--spacing-xs); font-weight: bold; border: none; font-size: 0.9em; cursor: pointer; }
        #favorite-sounds-list .delete-fav-btn { background-color: transparent; color: var(--danger-color); padding: var(--spacing-xs); border: none; font-size: 1em; line-height: 1; cursor: pointer; }
        #favorite-sounds-list .delete-fav-btn:hover { color: color-mix(in srgb, var(--danger-color) 70%, black); }

        /* --- Suivi --- */
        #tracking-history ul { list-style: none; padding-left: 0; max-height: 400px; overflow-y: auto; border: 1px solid var(--border-color); padding: var(--spacing-m); border-radius: var(--border-radius); margin-top: var(--spacing-s); }
        #tracking-history li { border-bottom: 1px dashed var(--border-color); padding: var(--spacing-m) 0; margin-bottom: var(--spacing-s); }
        #tracking-history li:last-child { border-bottom: none; margin-bottom: 0; }
        #tracking-history strong { color: var(--primary-color); }
        #tracking-history em { color: color-mix(in srgb, var(--text-color) 70%, var(--bg-color));}
        #tracking-history .controls label, #tracking-chart-container .controls label { margin-right: var(--spacing-s); }
        #tracking-history .controls select, #tracking-chart-container .controls select { width: auto; vertical-align: middle; }
        #tracking-chart-container { margin-top: var(--spacing-l); min-height: 280px; border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: var(--spacing-m); position: relative; }
        #tracking-chart-container svg { display: block; width: 100%; height: 100%; min-height: 240px; }
        .chart-line { fill: none; stroke: var(--secondary-color); stroke-width: 2.5px; }
        .chart-point { fill: var(--primary-color); stroke: var(--card-bg); stroke-width: 1.5px; cursor: pointer; transition: r 0.2s ease; }
        .chart-point:hover { r: 6; }
        .chart-axis { stroke: var(--border-color); stroke-width: 1px; }
        .chart-grid { stroke: var(--border-color); stroke-width: 1px; opacity: 0.3; stroke-dasharray: 2,2; }
        .chart-average-line { stroke: var(--accent-color); stroke-width: 1.5px; stroke-dasharray: 4, 4; } /* Style pour la ligne moyenne */
        .chart-text { font-size: 11px; fill: var(--text-color); text-anchor: middle; }
        .chart-text.axis-label-y { text-anchor: end; }
        .chart-text.axis-label-x { text-anchor: middle; }
        .chart-no-data { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--disabled-color); font-style: italic; }

        /* Footer & Quick Entry */
        footer { text-align: center; padding: var(--spacing-l); margin-top: var(--spacing-xl); font-size: 0.9em; color: color-mix(in srgb, var(--text-color) 60%, var(--bg-color)); border-top: 1px solid var(--border-color); position: relative; padding-bottom: 80px; /* Espace pour quick entry */ }
        #quick-entry-widget { background-color: var(--card-bg); border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: var(--spacing-s) var(--spacing-m); box-shadow: 0 -2px 5px rgba(0,0,0,0.1); position: fixed; /* Ou absolute dans le footer */ bottom: 10px; right: 10px; z-index: 999; display: flex; align-items: center; gap: var(--spacing-s); max-width: calc(100% - 20px); /* Emp√™che d√©passement sur petits √©crans */ }
        #quick-entry-widget label { margin-bottom: 0; font-size: 0.9em; }
        #quick-entry-widget input[type="range"] { width: 100px; margin-bottom: 0; }
        #quick-entry-widget output { font-size: 0.9em; min-width: 20px; margin-left: 0; }
        #quick-entry-widget button { padding: var(--spacing-s); font-size: 1.2em; line-height: 1; min-width: auto; margin-bottom: 0; }

        /* Responsive */
        @media (max-width: 768px) {
            nav { padding: var(--spacing-s) var(--spacing-m); justify-content: center; }
            nav .nav-brand { margin-bottom: var(--spacing-s); width: 100%; text-align: center; }
            nav ul { gap: var(--spacing-s); justify-content: center; width: 100%; margin-top: var(--spacing-s); }
            #app { padding: var(--spacing-m); }
            .content-section { padding: var(--spacing-m); }
            input[type="range"] { width: calc(100% - 40px); }
            output { min-width: 25px; }
            #hypnose-session .timer { font-size: 2em; }
            #hypnose-session .controls label { min-width: auto; /* Permet de r√©duire si besoin */ }
            #hypnose-session .controls input[type="range"] { width: 100px; }
            #quick-entry-widget { bottom: 5px; right: 5px; padding: var(--spacing-xs) var(--spacing-s); }
        }
        @media (max-width: 480px) {
            nav ul { gap: var(--spacing-xs); }
            nav a { padding: var(--spacing-xs) var(--spacing-s); font-size: 0.9em; }
            button, .button { font-size: 0.95em; padding: var(--spacing-s) var(--spacing-m); }
            .chart-text { font-size: 9px; }
            #quick-entry-widget label { display: none; /* Cache le label sur tr√®s petit √©cran */ }
            #quick-entry-widget input[type="range"] { width: 80px; }
        }

        /* Theme Toggle */
        #theme-toggle { cursor: pointer; background: none; border: none; font-size: 1.6em; padding: 0 var(--spacing-s); color: var(--text-color); margin-left: auto; order: 3; }
        @media (max-width: 768px) { #theme-toggle { margin-left: 0; } }

    </style>
</head>
<body>
    <div id="app">
        <nav id="main-nav">
             <a href="#home" class="nav-brand">Acouph√®nes Zen</a>
            <ul>
                <li><a href="#home" title="Accueil">üè†</a></li>
                <li><a href="#evaluation" title="√âvaluation">üìù</a></li>
                <li><a href="#hypnose" title="Auto-Hypnose">üßò</a></li>
                <li><a href="#sounds" title="Sons">üîä</a></li>
                <li><a href="#tracking" title="Suivi">üìä</a></li>
                <li><a href="#resources" title="Ressources">üìö</a></li>
            </ul>
             <button id="theme-toggle" title="Changer le th√®me">‚òÄÔ∏è</button>
        </nav>

        <main id="main-content">
            <!-- Contenu inject√© ici -->
        </main>

        <footer>
            <!-- Widget d'Entr√©e Rapide -->
            <div id="quick-entry-widget">
                 <label for="quick-intensity-slider">Intensit√©:</label>
                 <input type="range" id="quick-intensity-slider" name="quick-intensity" min="0" max="10" value="5" step="1" oninput="document.getElementById('quick-intensity-output').textContent = this.value">
                 <output id="quick-intensity-output">5</output>
                 <button id="quick-intensity-submit" class="button-secondary" title="Noter l'intensit√© actuelle">üíæ</button>
            </div>

            <p>Acouph√®nes Zen &copy; 2025 - Outil de gestion non m√©dical.</p>
            <p style="font-size: 0.8em; margin-top: 5px;"><strong>Important:</strong> Cette application ne remplace pas un avis m√©dical. Consultez un professionnel de sant√©.</p>
			<p class="more-apps-link"><a href="https://ericsotoca.github.io/" target="_blank" rel="noopener noreferrer">Plus d'Applis ? Cliquez ici !</a></p>
        </footer>
    </div>

    <!-- --- Mod√®les HTML --- -->

    <template id="template-home">
         <section class="content-section">
            <h1>Bienvenue sur Acouph√®nes Zen</h1>
            <p class="lead" style="font-size: 1.1em;">Votre compagnon pour mieux comprendre et g√©rer vos acouph√®nes au quotidien gr√¢ce √† l'auto-hypnose et aux sons th√©rapeutiques.</p>
            <div class="alert alert-warning mt-l mb-l">
                <strong>Avertissement Important :</strong> Acouph√®nes Zen est un outil d'accompagnement et de gestion. Il n'est pas destin√© √† diagnostiquer, traiter ou gu√©rir les acouph√®nes. Consultez <strong>toujours</strong> un m√©decin ou un sp√©cialiste ORL pour un diagnostic pr√©cis et un plan de traitement adapt√© √† votre situation.
            </div>
            <h2 class="mt-l">Comment cette application peut vous aider :</h2>
            <ul>
                <li><strong>Comprendre :</strong> Acc√©dez √† des informations claires sur les acouph√®nes (<a href="#resources">üìö Ressources</a>).</li>
                <li><strong>√âvaluer :</strong> Faites une premi√®re √©valuation de vos acouph√®nes (<a href="#evaluation">üìù √âvaluation</a>).</li>
                <li><strong>Apaiser :</strong> Utilisez des sessions guid√©es d'auto-hypnose avec lecture vocale optionnelle (<a href="#hypnose">üßò Auto-Hypnose</a>).</li>
                <li><strong>Masquer :</strong> G√©n√©rez des sons th√©rapeutiques et sauvegardez vos favoris (<a href="#sounds">üîä Sons</a>).</li>
                <li><strong>Suivre :</strong> Tenez un journal, visualisez votre progression et notez rapidement votre intensit√© (<a href="#tracking">üìä Suivi</a>).</li>
            </ul>
            <h2 class="mt-l">Pour commencer :</h2>
            <p>Nous vous recommandons de commencer par la section <a href="#evaluation">üìù √âvaluation</a>. Ensuite, explorez les sessions d'<a href="#hypnose">üßò Auto-Hypnose</a> ou le <a href="#sounds">üîä G√©n√©rateur de Sons</a>.</p>
            <p class="mt-m" style="font-style: italic;">Toutes vos donn√©es sont stock√©es <strong>uniquement sur votre appareil</strong> et ne sont jamais envoy√©es sur un serveur.</p>
            <div class="text-center mt-l">
                <a href="#evaluation" class="button">Commencer l'√©valuation üìù</a>
            </div>
        </section>
    </template>

    <template id="template-evaluation">
         <section class="content-section">
            <h2>üìù √âvaluation Initiale des Acouph√®nes</h2>
            <form id="evaluation-form">
                <p>Ce questionnaire aide √† mieux comprendre vos acouph√®nes et leur impact. Vos r√©ponses sont confidentielles et stock√©es localement.</p>
                <fieldset class="mb-l">
                    <legend>Caract√©ristiques</legend>
                    <label for="sound-type">Quel type de son entendez-vous principalement ?</label>
                    <input type="text" id="sound-type" name="sound-type" required placeholder="Ex: Sifflement aigu, bourdonnement...">
                    <label class="mt-m">Le son est-il per√ßu dans :</label>
                    <div class="radio-group"> <input type="radio" id="ear-left" name="ear-location" value="left"> <label for="ear-left">Oreille G</label> <input type="radio" id="ear-right" name="ear-location" value="right"> <label for="ear-right">Oreille D</label> <input type="radio" id="ear-both" name="ear-location" value="both" checked> <label for="ear-both">Les deux</label> <input type="radio" id="ear-head" name="ear-location" value="head"> <label for="ear-head">T√™te</label> </div>
                    <label for="intensity-avg" class="mt-m">Intensit√© <strong>moyenne</strong> (0-10) ?</label>
                    <input type="range" id="intensity-avg" name="intensity-avg" min="0" max="10" value="5" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>5</output>
                    <label for="variation" class="mt-m">L'intensit√© varie-t-elle beaucoup ?</label>
                    <select id="variation" name="variation"> <option value="peu">Peu</option> <option value="moderee">Mod√©r√©ment</option> <option value="beaucoup">Beaucoup</option> </select>
                </fieldset>
                 <fieldset class="mb-l">
                     <legend>Impact sur le quotidien (0=aucun, 10=majeur)</legend>
                     <label for="impact-sleep">Impact sur le <strong>sommeil</strong> ?</label>
                    <input type="range" id="impact-sleep" name="impact-sleep" min="0" max="10" value="3" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>3</output>
                     <label for="impact-concentration" class="mt-m">Impact sur la <strong>concentration</strong> ?</label>
                    <input type="range" id="impact-concentration" name="impact-concentration" min="0" max="10" value="3" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>3</output>
                    <label for="impact-mood" class="mt-m">Impact sur l'<strong>humeur</strong> ?</label>
                    <input type="range" id="impact-mood" name="impact-mood" min="0" max="10" value="3" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>3</output>
                     <label for="impact-hearing" class="mt-m">Interf√©rence avec l'<strong>audition</strong> ?</label>
                    <input type="range" id="impact-hearing" name="impact-hearing" min="0" max="10" value="2" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>2</output>
                 </fieldset>
                 <fieldset>
                    <legend>Facteurs d'influence (Optionnel)</legend>
                    <label for="triggers">Ce qui semble <strong>aggraver</strong> :</label>
                    <textarea id="triggers" name="triggers" rows="3" placeholder="Stress, fatigue, bruit, silence..."></textarea>
                     <label for="reducers" class="mt-m">Ce qui semble <strong>att√©nuer / aider</strong> :</label>
                    <textarea id="reducers" name="reducers" rows="3" placeholder="Bruit de fond, musique, relaxation..."></textarea>
                 </fieldset>
                <div id="evaluation-result" class="mt-l mb-m"></div>
                <button type="submit" class="mt-m">üíæ Enregistrer / Mettre √† jour</button>
            </form>
        </section>
    </template>

    <template id="template-hypnose">
        <section class="content-section">
            <h2>üßò Auto-Hypnose Guid√©e</h2>
            <p>Choisissez une session. Installez-vous au calme. Utilisez des √©couteurs si possible.</p>
             <div class="alert alert-info mt-m"> <strong>Conseil :</strong> Activez la lecture vocale (si dispo) pour fermer les yeux. La r√©gularit√© est la cl√©. </div>
            <div id="hypnose-menu" class="mt-l">
                <h3 class="mb-m">S√©lectionnez une session :</h3>
                <button class="button mb-m" data-session="debutant">D√©butant (~10 min)</button>
                <button class="button mb-m" data-session="intermediaire">Interm√©diaire (~15 min)</button>
                <button class="button mb-m" data-session="avance">Avanc√© (~20 min)</button>
            </div>
            <div id="hypnose-session" class="hidden mt-l">
                <h3 id="session-title" class="mb-m"></h3>
                <div class="timer">--:--</div>
                <!-- Barre de progression -->
                <div class="progress-bar-container"><div class="progress-bar" id="session-progress-bar"></div></div>
                <p id="session-step-indicator" class="text-center" style="font-style: italic; margin-bottom: var(--spacing-m);"></p>
                <div class="session-text" id="session-text-content"> <p>Chargement...</p> </div>
                <div class="controls mt-l">
                     <div>
                         <label for="hypno-noise">Bruit fond:</label>
                         <select id="hypno-noise"> <option value="none">Aucun</option> <option value="white">Blanc</option> <option value="pink">Rose</option> <option value="brown">Brun</option> </select>
                         <label for="hypno-volume" class="ml-m">Vol:</label>
                         <input type="range" id="hypno-volume" min="0" max="0.5" step="0.01" value="0.05">
                     </div>
                     <div class="checkbox-group">
                         <input type="checkbox" id="hypno-tts-enable">
                         <label for="hypno-tts-enable">üó£Ô∏è Lecture vocale</label>
                         <select id="hypno-voice-select" class="ml-m" title="Choisir la voix (si support√©)"> <option value="">Voix par d√©faut</option> </select>
                         <span id="tts-status" class="tts-status"></span>
                     </div>
                    <div class="mt-l session-main-controls">
                        <button id="start-session-btn" class="button-secondary" disabled>‚ñ∂Ô∏è D√©marrer</button>
                        <button id="pause-session-btn" class="button-secondary hidden" title="Pause">‚è∏Ô∏è</button>
                        <button id="resume-session-btn" class="button-secondary hidden" title="Reprendre">‚ñ∂Ô∏è</button>
                        <button id="stop-session-btn" class="button-danger hidden" title="Arr√™ter">‚èπÔ∏è</button>
                    </div>
                </div>
            </div>
        </section>
    </template>

    <template id="template-sounds">
         <section class="content-section">
            <h2>üîä G√©n√©rateur de Sons Th√©rapeutiques</h2>
            <p>Utilisez ces sons pour cr√©er un environnement sonore plus confortable.</p>
             <div class="alert alert-info mt-m"> <strong>Conseil :</strong> Exp√©rimentez. Un volume juste sous le niveau de l'acouph√®ne est souvent recommand√© (TRT). </div>

             <!-- Favoris -->
             <fieldset id="favorite-sounds">
                 <legend>‚ù§Ô∏è Vos Favoris</legend>
                 <ul id="favorite-sounds-list">
                     <li id="no-favorites-msg">Aucun favori enregistr√©.</li>
                     <!-- Les favoris seront ajout√©s ici par JS -->
                 </ul>
             </fieldset>

            <div class="sound-generator-controls mt-l">
                 <div class="mb-m">
                    <label for="sound-type-select">Type de son :</label>
                     <select id="sound-type-select"> <option value="white">Bruit Blanc</option> <option value="pink">Bruit Rose</option> <option value="brown">Bruit Brun</option> </select>
                 </div>
                <div class="mb-m">
                    <label for="sound-volume">Volume :</label>
                    <input type="range" id="sound-volume" min="0" max="0.7" step="0.01" value="0.1" oninput="this.nextElementSibling.textContent = parseFloat(this.value).toFixed(2)"> <output>0.10</output>
                     <button id="save-favorite-btn" class="button-icon" title="‚ù§Ô∏è Enregistrer ce r√©glage comme favori" style="margin-left: 10px; background-color: var(--accent-color); color: var(--bg-color); padding: 6px 8px;">‚ù§Ô∏è</button>
                </div>
                 <div class="mb-l">
                    <label for="sound-timer">‚è±Ô∏è Arr√™t auto (min, 0=‚àû) :</label>
                    <input type="number" id="sound-timer" min="0" step="5" value="0" style="width: 80px; display: inline-block; vertical-align: middle;">
                     <span id="sound-timer-status" style="margin-left: var(--spacing-s); vertical-align: middle; font-style: italic;"></span>
                 </div>
                <div class="mt-l text-center">
                    <button id="play-sound-btn" class="button">‚ñ∂Ô∏è Jouer</button>
                    <button id="stop-sound-btn" class="button-danger hidden">‚èπÔ∏è Arr√™ter</button>
                </div>
            </div>
        </section>
    </template>

    <template id="template-tracking">
         <section class="content-section">
            <h2>üìä Suivi Quotidien</h2>
            <p>Notez r√©guli√®rement l'intensit√© pour identifier des tendances.</p>
            <form id="tracking-form" class="mb-l">
                 <fieldset>
                     <legend>Ajouter une entr√©e</legend>
                     <div class="alert alert-info mb-m">La date/heure actuelles sont enregistr√©es.</div>
                    <label for="tracking-intensity">Intensit√© <strong>maintenant</strong> (0-10) ?</label>
                    <input type="range" id="tracking-intensity" name="intensity" min="0" max="10" value="5" step="1" required oninput="this.nextElementSibling.textContent = this.value"> <output>5</output>
                    <label for="tracking-notes" class="mt-m">Notes (optionnel) :</label>
                    <textarea id="tracking-notes" name="notes" rows="3" placeholder="Ex: Stress, fatigue, activit√©s, humeur..."></textarea>
                    <button type="submit" class="mt-m">üíæ Ajouter au journal</button>
                 </fieldset>
            </form>
            <hr style="margin: var(--spacing-l) 0; border: none; border-top: 1px solid var(--border-color);">
             <fieldset id="tracking-history" class="mb-l">
                <legend>üìì Historique</legend>
                 <div class="controls mb-m" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--spacing-m);">
                     <label for="history-limit">Afficher :</label>
                     <select id="history-limit"> <option value="10">10 dern.</option> <option value="30" selected>30 dern.</option> <option value="100">100 dern.</option> <option value="all">Toutes</option> </select>
                 </div>
                <p id="history-loading" class="text-center italic">Chargement...</p>
                <ul></ul>
            </fieldset>
             <fieldset id="tracking-chart-container">
                <legend>üìà Graphique d'√âvolution</legend>
                <div class="controls mb-m" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--spacing-m);">
                     <label for="chart-limit">P√©riode :</label>
                     <select id="chart-limit"> <option value="7">7 j</option> <option value="30" selected>30 j</option> <option value="90">90 j</option> <option value="all">Tout</option> </select>
                 </div>
                 <div id="tracking-chart"></div>
                 <div id="chart-no-data" class="chart-no-data hidden">Pas assez de donn√©es pour afficher le graphique.</div>
            </fieldset>
             <div class="mt-l text-center">
                 <button id="export-data-btn" class="button-secondary" title="Exporter les donn√©es en JSON">Exporter (JSON)</button>
                 <button id="export-csv-btn" class="button-secondary" title="Exporter le journal en CSV">Exporter (CSV)</button>
                 <button id="clear-data-btn" class="button-danger" title="Supprimer toutes vos donn√©es">üóëÔ∏è TOUT Supprimer</button>
             </div>
        </section>
    </template>

    <template id="template-resources">
         <section class="content-section">
            <h2>üìö Ressources √âducatives</h2>
            <p>Mieux comprendre est une √©tape importante.</p>
             <div class="alert alert-warning mt-m mb-l"> <strong>Rappel :</strong> Infos √©ducatives, non m√©dicales. Consultez un pro. </div>
            <article class="mb-l">
                <h3>Qu'est-ce que l'Acouph√®ne ?</h3>
                <p>Perception d'un son sans source externe. Sympt√¥me, pas maladie. Causes multiples :</p>
                <ul> <li>Exposition bruit fort</li> <li>Perte auditive (√¢ge)</li> <li>Infections, bouchon</li> <li>Maladies (M√©ni√®re...)</li> <li>Traumatismes</li> <li>M√©dicaments</li> <li>Stress, fatigue</li> <li>Probl√®mes vasculaires...</li> </ul>
                <p><strong>Consultez un m√©decin/ORL pour diagnostic.</strong></p>
            </article>
            <article class="mb-l">
                <h3>üßò L'Auto-Hypnose</h3>
                <p>Technique de relaxation profonde et concentration. Ne supprime pas le son mais aide √† :</p>
                <ul> <li>R√©duire Stress/Anxi√©t√©</li> <li>Modifier la Perception (son neutre, moins intrusif)</li> <li>D√©tourner l'Attention</li> <li>Am√©liorer le Sommeil</li> <li>Reprendre du Contr√¥le</li> </ul>
                <p><strong>R√©gularit√© = cl√©.</strong> Lecture vocale aide.</p>
            </article>
             <article class="mb-l">
                <h3>üîä Th√©rapie par le Son</h3>
                <p>Utilisation de sons externes (bruits color√©s, nature...). Objectifs :</p>
                <ul> <li><strong>Masquage :</strong> Couvrir l'acouph√®ne.</li> <li><strong>Distraction :</strong> Focaliser sur autre chose.</li> <li><strong>Habituation (TRT) :</strong> Aider le cerveau √† ignorer l'acouph√®ne (son faible, sur dur√©e, souvent avec pro).</li> </ul>
                 <p>Exp√©rimentez avec le g√©n√©rateur.</p>
             </article>
            <article>
                <h3>üí° Conseils Compl√©mentaires</h3>
                <ul> <li>Prot√©gez votre audition (bouchons).</li> <li>G√©rez votre stress (relaxation, hobbies).</li> <li>Soignez votre sommeil.</li> <li>Activit√© physique r√©guli√®re.</li> <li>Alimentation √©quilibr√©e (attention caf√©ine, alcool, sel si lien not√©).</li> <li>√âvitez le silence complet (fond sonore l√©ger).</li> <li>Restez inform√© mais pas obs√©d√©.</li> <li>Cherchez du soutien (proches, associations).</li> </ul>
            </article>
             <article class="mt-l">
                 <h3>‚ùì FAQ</h3>
                 <p><strong>Q: Gu√©rit l'acouph√®ne ?</strong> R: Non, outil de gestion.</p>
                 <p class="mt-m"><strong>Q: Auto-hypnose s√ªre ?</strong> R: Oui (relaxation/stress). Pas en conduisant.</p>
                 <p class="mt-m"><strong>Q: Lecture vocale marche partout ?</strong> R: D√©pend navigateur/OS. Voix varient.</p>
                 <p class="mt-m"><strong>Q: Quel bruit (blanc, rose, brun) ?</strong> R: Testez ! Blanc=aigu/sifflant, Rose=moyen/cascade, Brun=grave/grondement.</p>
                 <p class="mt-m"><strong>Q: Donn√©es s√©curis√©es ?</strong> R: Stock√©es localement sur VOTRE appareil uniquement. Supprimables via Suivi.</p>
             </article>
        </section>
    </template>


    <!-- --- JavaScript Int√©gr√© --- -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            console.log("Acouph√®nes Zen App Initializing v1.1 Enhanced...");

            // --- MODULE: Utilitaires Globaux ---
            const Utils = (() => {
                 function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return unsafe; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
                 function formatTime(seconds) { if (isNaN(seconds) || seconds < 0) return "--:--"; const mins = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
                 function updateBodyPadding() { const nav = document.getElementById('main-nav'); if (nav) { const navHeight = nav.offsetHeight; const buffer = 5; document.body.style.paddingTop = `${navHeight + buffer}px`; document.documentElement.style.setProperty('--nav-height', `${navHeight + buffer}px`); } }
                 function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }
                 function generateUUID() { // Simple UUID generator
                    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
                    );
                 }
                 return { escapeHtml, formatTime, updateBodyPadding, debounce, generateUUID };
            })();


            // --- MODULE: √âtat Global & Stockage Local ---
            const Store = (() => {
                const STORAGE_KEY = 'acouphenesZenData_v1.2'; // Incr√©ment√© pour nouvelles prefs
                const MAX_JOURNAL_ENTRIES = 365;

                const defaultPreferences = {
                    theme: 'light',
                    hypnoTtsEnabled: false,
                    preferredVoiceURI: null, // Ajout pr√©f√©rence Voix
                    favoriteSounds: [] // Ajout favoris sons
                };

                let state = {
                    userProfile: {
                        initialAssessment: null,
                        preferences: { ...defaultPreferences }
                    },
                    sessions: [], // { timestamp: ISOString, sessionKey: string, duration: number, completed: boolean }
                    journal: [],  // { date: ISOString, intensity: number, notes: string }
                    lastActive: null
                };

                function load() {
                    const storedData = localStorage.getItem(STORAGE_KEY);
                    if (storedData) {
                        try {
                            const parsedData = JSON.parse(storedData);
                            state = {
                                userProfile: {
                                    initialAssessment: parsedData.userProfile?.initialAssessment || null,
                                    preferences: {
                                        ...defaultPreferences, // Assure que les nouvelles cl√©s existent
                                        ...(parsedData.userProfile?.preferences || {})
                                     }
                                },
                                sessions: Array.isArray(parsedData.sessions) ? parsedData.sessions : [],
                                journal: Array.isArray(parsedData.journal) ? parsedData.journal.map(entry => ({...entry, intensity: parseInt(entry.intensity, 10) || 0})) : [], // Assure intensity est un nombre
                                lastActive: parsedData.lastActive || null
                            };
                             // Nettoyage favoris (assurer ID unique si manque)
                             if (state.userProfile.preferences.favoriteSounds) {
                                state.userProfile.preferences.favoriteSounds = state.userProfile.preferences.favoriteSounds.map(fav => ({
                                    ...fav,
                                    id: fav.id || Utils.generateUUID(), // Ajoute un ID si manquant
                                    volume: parseFloat(fav.volume) || 0.1 // Assure que volume est un nombre
                                }));
                             } else {
                                 state.userProfile.preferences.favoriteSounds = [];
                             }

                            state.journal.sort((a, b) => new Date(a.date) - new Date(b.date));
                            console.log('Donn√©es charg√©es depuis localStorage.');
                        } catch (e) { console.error("Erreur chargement localStorage:", e); state.userProfile.preferences = { ...defaultPreferences }; state.journal = []; state.sessions = []; } // Reset en cas d'erreur grave
                    } else { console.log('Aucune donn√©e locale trouv√©e, √©tat initial.'); }
                    applyThemePreference(); // Applique th√®me charg√© ou par d√©faut
                }

                function save() {
                    state.lastActive = new Date().toISOString();
                    try {
                        state.journal.sort((a, b) => new Date(a.date) - new Date(b.date));
                        if (state.journal.length > MAX_JOURNAL_ENTRIES) state.journal = state.journal.slice(state.journal.length - MAX_JOURNAL_ENTRIES);
                        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                    } catch (e) { console.error("Erreur sauvegarde localStorage:", e); UI.showToast("Erreur sauvegarde donn√©es.", "error"); }
                }

                function getState() { return JSON.parse(JSON.stringify(state)); }
                function updateProfile(profileData) { state.userProfile.initialAssessment = profileData; save(); }
                function addJournalEntry(entry) {
                     if (typeof entry.intensity === 'undefined' || entry.intensity === null) return null;
                     const newEntry = {
                        date: new Date().toISOString(),
                        intensity: parseInt(entry.intensity, 10), // Assurer que c'est un nombre
                        notes: (entry.notes || "").trim()
                     };
                     state.journal.push(newEntry);
                     save();
                     return newEntry;
                 }
                function getJournalEntries(limit = null) { const sortedJournal = [...state.journal].sort((a, b) => new Date(b.date) - new Date(a.date)); if (limit && typeof limit === 'number' && limit > 0) { return sortedJournal.slice(0, limit); } return sortedJournal; }
                function addSessionLog(logData) { logData.timestamp = new Date().toISOString(); state.sessions.push(logData); save(); }

                // --- Pr√©f√©rences ---
                function updateThemePreference(theme) { state.userProfile.preferences.theme = theme; save(); applyThemePreference(); }
                function getThemePreference() { return state.userProfile.preferences.theme || 'light'; }
                function setTtsPreference(enabled) { state.userProfile.preferences.hypnoTtsEnabled = !!enabled; save(); }
                function getTtsPreference() { return !!state.userProfile.preferences.hypnoTtsEnabled; }
                function setPreferredVoiceURI(uri) { state.userProfile.preferences.preferredVoiceURI = uri; save(); }
                function getPreferredVoiceURI() { return state.userProfile.preferences.preferredVoiceURI; }

                // --- Favoris Sons ---
                function addFavoriteSound(preset) {
                    const name = prompt(`Nommez ce favori (ex: Pluie douce):`, `${preset.type} (${preset.volume.toFixed(2)})`);
                    if (name && name.trim()) {
                        const newFav = { ...preset, id: Utils.generateUUID(), name: name.trim() };
                        state.userProfile.preferences.favoriteSounds.push(newFav);
                        save();
                        return newFav;
                    }
                    return null;
                }
                function removeFavoriteSound(id) { state.userProfile.preferences.favoriteSounds = state.userProfile.preferences.favoriteSounds.filter(fav => fav.id !== id); save(); }
                function getFavoriteSounds() { return state.userProfile.preferences.favoriteSounds || []; }

                function clearAllData() {
                     if (confirm("ATTENTION !\n\n√ätes-vous s√ªr de vouloir supprimer TOUTES vos donn√©es (√©valuation, journal, sessions, favoris, pr√©f√©rences) ?\n\nIRR√âVERSIBLE.")) {
                        const prefsToKeep = { ...state.userProfile.preferences }; // Sauvegarde temporaire
                        localStorage.removeItem(STORAGE_KEY);
                        state = { // Reset complet
                            userProfile: { initialAssessment: null, preferences: { ...defaultPreferences } },
                            sessions: [], journal: [], lastActive: null
                        };
                        // R√©tablir certaines pr√©f√©rences si on veut (ex: theme)
                        state.userProfile.preferences.theme = prefsToKeep.theme;
                         // state.userProfile.preferences.preferredVoiceURI = prefsToKeep.preferredVoiceURI; // Garder la voix ? A d√©battre
                         save(); // Sauver l'√©tat r√©initialis√©
                        console.log("Toutes les donn√©es utilisateur ont √©t√© supprim√©es.");
                        window.location.hash = '#home';
                        window.location.reload(); // Force rechargement pour appliquer partout
                        return true;
                    }
                    return false;
                 }

                 function applyThemePreference() {
                     const theme = getThemePreference();
                     document.body.classList.toggle('dark-mode', theme === 'dark');
                     const toggleButton = document.getElementById('theme-toggle');
                     if (toggleButton) {
                        toggleButton.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
                        toggleButton.title = `Passer au th√®me ${theme === 'dark' ? 'clair' : 'sombre'}`;
                     }
                 }
                 load(); // Charger au d√©marrage

                return { getState, updateProfile, addJournalEntry, getJournalEntries, addSessionLog, updateThemePreference, getThemePreference, applyThemePreference, setTtsPreference, getTtsPreference, setPreferredVoiceURI, getPreferredVoiceURI, addFavoriteSound, removeFavoriteSound, getFavoriteSounds, clearAllData };
            })();

            // --- MODULE: UI (Manipulation du DOM & Feedback) ---
            const UI = (() => {
                const uiElements = { mainContent: document.getElementById('main-content'), navLinks: document.querySelectorAll('#main-nav a[href^="#"]') };
                function renderTemplate(templateId) { const template = document.getElementById(templateId); if (!template) { console.error(`Template ${templateId} non trouv√©`); uiElements.mainContent.innerHTML = `<section class="content-section"><p class="alert alert-danger">Erreur contenu page.</p></section>`; setActiveNavLink(''); return null; } try { const content = template.content.cloneNode(true); uiElements.mainContent.innerHTML = ''; uiElements.mainContent.appendChild(content); setActiveNavLink(templateId.replace('template-', '')); window.scrollTo({ top: 0, behavior: 'smooth' }); return uiElements.mainContent.firstChild; } catch (error) { console.error(`Erreur rendu ${templateId}:`, error); uiElements.mainContent.innerHTML = `<section class="content-section"><p class="alert alert-danger">Erreur affichage section.</p></section>`; setActiveNavLink(''); return null; } }
                function setActiveNavLink(hash) { uiElements.navLinks.forEach(link => { link.classList.remove('active'); if (link.getAttribute('href') === `#${hash}`) link.classList.add('active'); }); }
                function displayEvaluationResult(score, message) { const resultDiv = document.getElementById('evaluation-result'); if (resultDiv) { let alertClass = 'alert-success'; if (score >= 25) alertClass = 'alert-danger'; else if (score >= 15) alertClass = 'alert-warning'; else alertClass = 'alert-info'; resultDiv.innerHTML = `<div class="alert ${alertClass}"><strong>R√©sultat :</strong> ${Utils.escapeHtml(message)} (Score d'impact: ${score})</div>`; resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } }
                function renderJournalEntry(entry) { const li = document.createElement('li'); const entryDate = new Date(entry.date); const formattedDateTime = entryDate.toLocaleString('fr-FR', { dateStyle: 'short', timeStyle: 'short' }); li.innerHTML = `<strong>${formattedDateTime}</strong> - Intensit√©: <span style="font-weight: bold; color: var(--primary-color);">${entry.intensity}/10</span> ${entry.notes ? `<br><em>${Utils.escapeHtml(entry.notes)}</em>` : ''}`; return li; }
                function displayJournalHistory(entries) { const historyList = document.querySelector('#tracking-history ul'); const loadingMsg = document.getElementById('history-loading'); if (!historyList || !loadingMsg) return; historyList.innerHTML = ''; if (!entries || entries.length === 0) { loadingMsg.textContent = "Journal vide."; loadingMsg.style.display = 'block'; } else { loadingMsg.style.display = 'none'; entries.forEach(entry => { const li = renderJournalEntry(entry); if (li) historyList.appendChild(li); }); } }
                function showToast(message, type = 'info', duration = 3000) { const toast = document.createElement('div'); toast.className = `toast toast-${type}`; toast.textContent = message; document.body.appendChild(toast); requestAnimationFrame(() => { toast.classList.add('show'); }); setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => { if (toast.parentNode) toast.parentNode.removeChild(toast); }, { once: true }); }, duration); }
                // Nouvelle fonction pour afficher les favoris
                function displayFavoriteSounds(favorites, playCallback, deleteCallback) {
                    const list = document.getElementById('favorite-sounds-list');
                    const msg = document.getElementById('no-favorites-msg');
                    if (!list || !msg) return;
                    list.innerHTML = ''; // Clear existing
                    if (!favorites || favorites.length === 0) {
                        msg.style.display = 'list-item'; // Show "Aucun favori" message
                        list.appendChild(msg); // Re-add it if it was cleared
                    } else {
                        msg.style.display = 'none'; // Hide "Aucun favori" message
                        favorites.forEach(fav => {
                            const li = document.createElement('li');
                            const playBtn = document.createElement('button');
                            playBtn.className = 'play-fav-btn';
                            playBtn.textContent = fav.name;
                            playBtn.title = `Jouer ${fav.name} (${fav.type}, Vol ${fav.volume.toFixed(2)})`;
                            playBtn.onclick = () => playCallback(fav);

                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'delete-fav-btn button-icon';
                            deleteBtn.innerHTML = 'üóëÔ∏è';
                            deleteBtn.title = `Supprimer ${fav.name}`;
                            deleteBtn.setAttribute('aria-label', `Supprimer ${fav.name}`);
                            deleteBtn.onclick = () => deleteCallback(fav.id);

                            li.appendChild(playBtn);
                            li.appendChild(deleteBtn);
                            list.appendChild(li);
                        });
                    }
                }

                return { renderTemplate, setActiveNavLink, displayEvaluationResult, displayJournalHistory, showToast, displayFavoriteSounds };
             })();

            // --- MODULE: Audio (Web Audio API) - Avec Fondu ---
            const AudioManager = (() => {
                let audioContext; let masterGainNode; let currentNoiseSource = null; let currentFilterNode = null; let currentNoiseType = null; let noiseTimer = null;
                const FADE_DURATION = 0.5; // Dur√©e du fondu en secondes

                function getContext() { if (!audioContext) { try { window.AudioContext = window.AudioContext || window.webkitAudioContext; if (!window.AudioContext) throw new Error("Web Audio API non support√©e"); audioContext = new AudioContext(); masterGainNode = audioContext.createGain(); masterGainNode.connect(audioContext.destination); masterGainNode.gain.setValueAtTime(0, audioContext.currentTime); /* Start at 0 volume */ console.log("AudioContext cr√©√©."); } catch(e) { console.error("Erreur AudioContext:", e); UI.showToast("Audio non support√©.", "error"); return null; } } if (audioContext.state === 'suspended') audioContext.resume().catch(err => console.error("Erreur reprise:", err)); return audioContext; }
                function initContextOnInteraction() { const initAudio = () => { const context = getContext(); if (context && context.state === 'running') { console.log("Audio activ√©."); document.body.removeEventListener('click', initAudio, { capture: true }); document.body.removeEventListener('touchstart', initAudio, { capture: true }); document.body.removeEventListener('keydown', initAudio, { capture: true }); } }; document.body.addEventListener('click', initAudio, { once: true, capture: true }); document.body.addEventListener('touchstart', initAudio, { once: true, capture: true }); document.body.addEventListener('keydown', initAudio, { once: true, capture: true }); }
                function createWhiteNoiseSource(context) { const bufferSize = context.sampleRate * 2; const buffer = context.createBuffer(1, bufferSize, context.sampleRate); const output = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1; const source = context.createBufferSource(); source.buffer = buffer; source.loop = true; return source; }
                function createPinkFilter(context) { const filter = context.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(800, context.currentTime); filter.Q.setValueAtTime(0.707, context.currentTime); return filter; }
                function createBrownFilter(context) { const filter = context.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(300, context.currentTime); filter.Q.setValueAtTime(1, context.currentTime); return filter; }

                function playNoise(type, volume, durationMinutes = 0) {
                    stopNoise(); // Nettoyage AVANT
                    const context = getContext();
                    if (!context || context.state !== 'running') { if (context?.state === 'suspended') { context.resume().then(() => playNoise(type, volume, durationMinutes)).catch(err => UI.showToast("Activez l'audio (clic?).", "warning")); } else UI.showToast("Audio non pr√™t (cliquez?).", "warning"); return false; }

                    try {
                        currentNoiseSource = null; currentFilterNode = null; currentNoiseType = type;
                        const whiteSource = createWhiteNoiseSource(context);
                        currentNoiseSource = whiteSource; let nodeToConnect = whiteSource;
                        if (type === 'pink') { currentFilterNode = createPinkFilter(context); whiteSource.connect(currentFilterNode); nodeToConnect = currentFilterNode; }
                        else if (type === 'brown') { currentFilterNode = createBrownFilter(context); whiteSource.connect(currentFilterNode); nodeToConnect = currentFilterNode; }
                        nodeToConnect.connect(masterGainNode);
                        currentNoiseSource.start(0);
                        // Fade In
                        masterGainNode.gain.cancelScheduledValues(context.currentTime);
                        masterGainNode.gain.setValueAtTime(0, context.currentTime); // Start at 0
                        masterGainNode.gain.linearRampToValueAtTime(volume, context.currentTime + FADE_DURATION);
                        console.log(`Bruit ${type} d√©marr√© avec fondu vers ${volume}.`);

                        if (durationMinutes > 0) { const s = durationMinutes * 60; noiseTimer = setTimeout(() => { console.log("Timer atteint."); stopNoise(); UI.showToast("Son arr√™t√© (timer).", "info"); document.dispatchEvent(new CustomEvent('audiotimerend')); }, s * 1000); document.dispatchEvent(new CustomEvent('audiotimerstart', { detail: { durationMinutes } })); } else { document.dispatchEvent(new CustomEvent('audiotimerclear')); }
                        return true;
                    } catch (error) { console.error(`Erreur lecture ${type}:`, error); UI.showToast(`Erreur lecture audio (${type}).`, "error"); stopNoise(); return false; }
                }

                function stopNoise(immediate = false) {
                    if (noiseTimer) { clearTimeout(noiseTimer); noiseTimer = null; document.dispatchEvent(new CustomEvent('audiotimerclear')); }
                    if (!currentNoiseSource || !audioContext) return false; // Nothing to stop

                    const sourceToStop = currentNoiseSource;
                    const filterToDisconnect = currentFilterNode;
                    const stoppedType = currentNoiseType;

                    // Clear current references immediately
                    currentNoiseSource = null; currentFilterNode = null; currentNoiseType = null;

                    const fadeOutTime = audioContext.currentTime + (immediate ? 0.01 : FADE_DURATION);

                    // Fade Out
                    masterGainNode.gain.cancelScheduledValues(audioContext.currentTime);
                    masterGainNode.gain.setValueAtTime(masterGainNode.gain.value, audioContext.currentTime); // Start from current volume
                    masterGainNode.gain.linearRampToValueAtTime(0.0001, fadeOutTime); // Ramp down to near zero

                    // Stop the source slightly after the fade completes
                    sourceToStop.stop(fadeOutTime + 0.05);

                    // Disconnect after stopping
                    setTimeout(() => {
                        try {
                            if (filterToDisconnect) filterToDisconnect.disconnect();
                            sourceToStop.disconnect();
                            console.log(`Bruit ${stoppedType} arr√™t√© et d√©connect√© apr√®s fondu.`);
                        } catch(e) { console.warn("Erreur d√©connexion post-arr√™t:", e); }
                    }, (fadeOutTime - audioContext.currentTime + 0.1) * 1000); // Delay slightly longer than stop time

                    return true;
                }

                function setVolume(volume) { volume = Math.max(0, Math.min(1, volume)); if (masterGainNode && audioContext && currentNoiseSource) { masterGainNode.gain.cancelScheduledValues(audioContext.currentTime); masterGainNode.gain.setTargetAtTime(volume, audioContext.currentTime, 0.015); } }
                function isPlaying() { return !!currentNoiseSource; }
                // Ajout pour pause/resume audio (utilis√© par hypnose)
                function suspendAudio() { if (audioContext && audioContext.state === 'running') return audioContext.suspend(); return Promise.resolve(); }
                function resumeAudio() { if (audioContext && audioContext.state === 'suspended') return audioContext.resume(); return Promise.resolve(); }

                return { initContextOnInteraction, playNoise, stopNoise, setVolume, isPlaying, getContext, suspendAudio, resumeAudio };
             })();

            // --- MODULE: Synth√®se Vocale (TTS) - Avec s√©lection de voix ---
			const TTSManager = (() => {
				let synthesis = window.speechSynthesis;
				let voices = [];
				let isSupported = false;
				let currentUtterance = null;
				let isCurrentlySpeakingInternal = false;

				function init() {
					if ('speechSynthesis' in window) {
						isSupported = true;
						console.log("TTS support√©.");
						synthesis.onvoiceschanged = populateVoiceList; // Important!
						populateVoiceList(); // Premier essai
					} else { console.warn("TTS non support√©."); }
				}

                function populateVoiceList() {
                    if (!isSupported) return;
                    try {
                        voices = synthesis.getVoices().filter(v => v.lang.startsWith('fr')); // Filtre voix FR
                        console.log("Voix FR trouv√©es:", voices.length);
                        // Mise √† jour du select dans la page hypnose (si elle est affich√©e)
                         const voiceSelect = document.getElementById('hypno-voice-select');
                         if (voiceSelect) {
                             const currentVal = voiceSelect.value; // Sauver la valeur actuelle
                             voiceSelect.innerHTML = '<option value="">Voix par d√©faut</option>'; // Reset options
                             voices.forEach(voice => {
                                 const option = document.createElement('option');
                                 option.value = voice.voiceURI;
                                 option.textContent = `${voice.name} (${voice.lang})`;
                                 option.selected = (voice.voiceURI === currentVal); // Res√©lectionner si possible
                                 voiceSelect.appendChild(option);
                             });
                             // Tenter de s√©lectionner la voix pr√©f√©r√©e sauvegard√©e
                             const preferredURI = Store.getPreferredVoiceURI();
                             if (preferredURI && voices.some(v => v.voiceURI === preferredURI)) {
                                 voiceSelect.value = preferredURI;
                             }
                         }
                    } catch (e) { console.error("Erreur getVoices:", e); }
                 }

                function speak(text) {
                    const audioCtx = AudioManager.getContext();
                    if (!audioCtx || audioCtx.state !== 'running') { console.warn("TTS speak ignor√©: AudioContext non actif."); audioCtx?.resume().then(() => speak(text)).catch(err => { UI.showToast("Activez l'audio (clic?) pour la lecture vocale.", "warning"); }); return false; }
                    if (!isSupported || !text) { console.warn("TTS speak ignor√©: non support√© ou vide"); return false; }
                    if (isCurrentlySpeakingInternal) { cancel(); } // Annule la pr√©c√©dente si elle parle encore

                    currentUtterance = new SpeechSynthesisUtterance(text);
                    const preferredURI = Store.getPreferredVoiceURI();
                    const selectedVoice = voices.find(v => v.voiceURI === preferredURI);

                    if (selectedVoice) {
                        currentUtterance.voice = selectedVoice;
                        console.log("Voix TTS s√©lectionn√©e:", selectedVoice.name);
                    } else {
                         let defaultFrVoice = voices.find(v => v.lang === 'fr-FR') || voices[0]; // Fallback sur la premi√®re FR
                         if (defaultFrVoice) {
                             currentUtterance.voice = defaultFrVoice;
                             console.log("Voix TTS FR par d√©faut utilis√©e:", defaultFrVoice.name);
                         } else { console.warn("Aucune voix FR trouv√©e, utilise d√©faut syst√®me."); }
                    }
                    currentUtterance.lang = 'fr-FR';
                    currentUtterance.pitch = 1;
                    currentUtterance.rate = 0.9;

                    currentUtterance.onstart = () => { console.log("TTS: onstart"); isCurrentlySpeakingInternal = true; };
                    currentUtterance.onend = () => { console.log("TTS: onend"); isCurrentlySpeakingInternal = false; currentUtterance = null; };
					currentUtterance.onerror = (e) => {
						const errorMsg = e.error || 'unknown';
						// **Modification Log**
						if (errorMsg === 'interrupted' || errorMsg === 'canceled') {
							 console.log(`TTS: Lecture interrompue (${errorMsg}) - Normal si arr√™t/pause/changement page/√©tape.`);
						} else {
							 console.error('Erreur TTS:', errorMsg);
							 UI.showToast(`Erreur lecture vocale (${errorMsg}).`, "error");
						}
						isCurrentlySpeakingInternal = false;
						currentUtterance = null; // Assurer le nettoyage
					};

                    try { synthesis.speak(currentUtterance); console.log("TTS: Demande de lecture:", text.substring(0,30)+"..."); return true; }
                    catch (e) { console.error("Erreur synthesis.speak:", e); UI.showToast("Impossible d√©marrer lecture.", "error"); isCurrentlySpeakingInternal = false; currentUtterance = null; return false; }
                 }

				function cancel() { if (synthesis && (synthesis.speaking || synthesis.pending || isCurrentlySpeakingInternal)) { console.log("TTS: cancel() demand√©."); synthesis.cancel(); isCurrentlySpeakingInternal = false; currentUtterance = null; } }
				function isSpeaking() { return isCurrentlySpeakingInternal; }
                // Pause/Resume pour TTS sont peu fiables, on utilisera cancel/speak
                function pause() { if(synthesis && synthesis.speaking) synthesis.pause(); }
                function resume() { if(synthesis && synthesis.paused) synthesis.resume(); }

				init(); // Doit √™tre appel√© pour que onvoiceschanged fonctionne
				return { isSupported: () => isSupported, populateVoiceList, speak, cancel, pause, resume, isSpeaking }; // Expose populate
			})();

            // --- D√©claration Globale des Handlers ---
            const pageHandlers = {};

            // --- MODULE: Routage ---
            const Router = (() => {
                let currentPageInitFunction = null; let currentPageCleanupFunction = null;
                function handleRouteChange() {
                    const hash = window.location.hash || '#home'; let route = hash.substring(1);
                    console.log(`Routing vers: ${route}`);
                    if (typeof currentPageCleanupFunction === 'function') { try { currentPageCleanupFunction(); } catch (e) { console.error(`Erreur cleanup:`, e); } }
                    currentPageCleanupFunction = null; currentPageInitFunction = null;
                    // Arr√™t syst√©matique sons/tts au changement de page
                    if (AudioManager.isPlaying()) AudioManager.stopNoise(true); // Arr√™t imm√©diat
                    if (TTSManager.isSpeaking()) TTSManager.cancel();

                    const templateId = `template-${route}`; if (!document.getElementById(templateId)) { route = 'home'; window.location.hash = '#home'; }
                    const renderedElement = UI.renderTemplate(`template-${route}`);
                    if (renderedElement) {
                        switch (route) {
                            case 'evaluation': currentPageInitFunction = initEvaluationPage; currentPageCleanupFunction = cleanupEvaluationPage; break;
                            case 'hypnose': currentPageInitFunction = initHypnosePage; currentPageCleanupFunction = cleanupHypnosePage; break;
                            case 'sounds': currentPageInitFunction = initSoundsPage; currentPageCleanupFunction = cleanupSoundsPage; break;
                            case 'tracking': currentPageInitFunction = initTrackingPage; currentPageCleanupFunction = cleanupTrackingPage; break;
                            case 'resources': currentPageInitFunction = initResourcesPage; currentPageCleanupFunction = cleanupResourcesPage; break;
                            case 'home': default: currentPageInitFunction = initHomePage; currentPageCleanupFunction = cleanupHomePage; break;
                        }
                        if (typeof currentPageInitFunction === 'function') { try { currentPageInitFunction(); console.log(`Init ${route} OK.`); } catch(e) { console.error(`Erreur init ${route}:`, e); UI.showToast(`Erreur chargement ${route}.`, "error"); } }
                    }
                 }
                function init() { window.addEventListener('hashchange', handleRouteChange); AudioManager.initContextOnInteraction(); initThemeToggle(); initQuickEntry(); Utils.updateBodyPadding(); window.addEventListener('resize', Utils.debounce(Utils.updateBodyPadding, 150)); handleRouteChange(); } // Init Quick Entry
                return { init };
            })();

            // --- Fonctions Init/Cleanup des Pages ---

            function initHomePage() { console.log("Init Home"); }
            function cleanupHomePage() { console.log("Cleanup Home"); }

            function initEvaluationPage() {
                console.log("Init Evaluation"); const form = document.getElementById('evaluation-form'); const resultDiv = document.getElementById('evaluation-result'); const savedProfile = Store.getState().userProfile.initialAssessment; if (form && savedProfile) { Object.keys(savedProfile).forEach(key => { const input = form.elements[key]; if (input) { if (input.type === 'radio') form.querySelectorAll(`input[name="${key}"]`).forEach(radio => { radio.checked = (radio.value === savedProfile[key]); }); else if (input.type === 'range') { input.value = savedProfile[key]; if (input.nextElementSibling?.tagName === 'OUTPUT') input.nextElementSibling.textContent = input.value; } else if (input.tagName === 'SELECT') input.value = savedProfile[key]; else input.value = savedProfile[key]; } }); resultDiv.innerHTML = `<div class="alert alert-info">Infos charg√©es.</div>`; } else if (resultDiv) resultDiv.innerHTML = '';
                pageHandlers.evaluationSubmit = handleEvaluationSubmit;
                form?.addEventListener('submit', pageHandlers.evaluationSubmit);
             }
            function handleEvaluationSubmit(e) { e.preventDefault(); const form = e.target; const formData = new FormData(form); const data = {}; let score = 0; const impactKeys = ['intensity-avg', 'impact-sleep', 'impact-concentration', 'impact-mood', 'impact-hearing']; formData.forEach((value, key) => { data[key] = Utils.escapeHtml(value.trim()); if (impactKeys.includes(key)) score += parseInt(value, 10) || 0; }); Store.updateProfile(data); let msg = "√âval enregistr√©e. "; if (score >= 25) msg += "Impact significatif."; else if (score >= 15) msg += "Impact mod√©r√©."; else msg += "Impact l√©ger."; UI.displayEvaluationResult(score, msg); UI.showToast("√âval enregistr√©e !", "success"); }
            function cleanupEvaluationPage() { const form = document.getElementById('evaluation-form'); if(form && pageHandlers.evaluationSubmit) form.removeEventListener('submit', pageHandlers.evaluationSubmit); delete pageHandlers.evaluationSubmit; console.log("Cleanup √âval"); }

            // --- Page Auto-Hypnose (MAJ Majeure) ---
             let hypnoTimerInterval = null;
             let hypnoSessionEndTime = 0;
             let hypnoCurrentSessionData = null;
             let hypnoIsPaused = false;
             let hypnoPauseStartTime = 0;
             let hypnoTotalPauseDuration = 0;
             let hypnoNoiseType = 'none';
             let hypnoVolume = 0.05;
             let hypnoTtsEnabled = false;
             let hypnoSessionCompleted = false;
             let hypnoLastSpokenText = null; // Garder trace du texte courant pour reprise

             const sessionsData = { // Contenu des sessions inchang√©, repris de votre code original
                debutant: { title: "D√©butant (env. 10 min) - Relaxation et Prise de Conscience", duration: 600, script: [ { time: 0, text: "Commencez par trouver une position confortable, assise ou allong√©e, o√π vous ne serez pas d√©rang√©. Fermez doucement les yeux ou fixez un point devant vous sans effort." }, { time: 20, text: "Prenez maintenant trois respirations profondes et calmes. Inspirez par le nez en gonflant le ventre... et expirez lentement par la bouche, en rel√¢chant les tensions..." }, { time: 45, text: "R√©p√©tez encore deux fois √† votre rythme... Sentez votre corps commencer √† se d√©tendre √† chaque expiration..." }, { time: 75, text: "Portez maintenant votre attention sur les sensations de votre corps. Ressentez le contact de vos pieds avec le sol ou le support... le poids de votre corps..." }, { time: 120, text: "Scannez mentalement votre corps, des pieds √† la t√™te. Remarquez simplement les sensations, sans jugement. S'il y a des tensions, imaginez qu'elles se rel√¢chent √† chaque expiration..." }, { time: 180, text: "Portez maintenant votre attention sur votre respiration naturelle. Observez le va-et-vient de l'air, sans chercher √† la contr√¥ler... C'est votre point d'ancrage dans le moment pr√©sent..." }, { time: 240, text: "Les pens√©es peuvent venir, c'est normal. Laissez-les passer comme des nuages dans le ciel, sans vous y accrocher, et revenez doucement √† la sensation de votre respiration..." }, { time: 300, text: "Maintenant, portez une attention douce et curieuse aux sons autour de vous... Ceux de la pi√®ce... ceux de l'ext√©rieur... Accueillez-les sans jugement..." }, { time: 360, text: "Remarquez aussi la pr√©sence de votre acouph√®ne, s'il est l√†. Essayez de le percevoir comme un son parmi d'autres, sans lui donner plus d'importance. Juste une sensation sonore..." }, { time: 420, text: "Imaginez que vous pouvez cr√©er un espace mental autour de ce son. Il est l√†, mais il y a aussi de l'espace, du calme autour..." }, { time: 480, text: "Revenez √† la sensation globale de votre corps d√©tendu... Appr√©ciez ce moment de calme int√©rieur..." }, { time: 540, text: "Sachez que vous pouvez retrouver cet √©tat de calme quand vous le souhaitez. C'est une capacit√© en vous." }, { time: 570, text: "Dans quelques instants, cette session va se terminer. Commencez √† reprendre conscience de votre environnement... Bougez doucement les doigts, les orteils..." }, { time: 590, text: "Quand vous serez pr√™t, √† votre rythme, ouvrez les yeux en gardant avec vous cette sensation de calme. √âtirez-vous si vous le souhaitez." } ] },
                 intermediaire: { title: "Interm√©diaire (env. 15 min) - D√©tournement de l'Attention", duration: 900, script: [ { time: 0, text: "Installez-vous confortablement, fermez les yeux. Prenez quelques respirations profondes pour signaler √† votre corps qu'il peut se d√©tendre." }, { time: 30, text: "Imaginez une lumi√®re douce et apaisante au sommet de votre t√™te. Sentez sa chaleur et sa d√©tente descendre lentement... sur votre front... vos yeux... vos m√¢choires qui se desserrent..." }, { time: 60, text: "Cette vague de d√©tente descend dans votre cou, vos √©paules... le long de vos bras jusqu'au bout de vos doigts... Sentez la lourdeur agr√©able de la relaxation..." }, { time: 120, text: "Elle continue dans votre poitrine, votre ventre... votre dos se rel√¢che... Sentez votre respiration devenir plus calme, plus profonde..." }, { time: 180, text: "La d√©tente atteint vos jambes... vos genoux... vos mollets... jusqu'√† vos pieds. Tout votre corps est maintenant agr√©ablement lourd et d√©tendu." }, { time: 240, text: "Maintenant, portez votre attention sur votre ou√Øe. √âcoutez les sons autour de vous... sans les analyser, juste les percevoir..." }, { time: 300, text: "Peut-√™tre entendez-vous votre acouph√®ne. Accueillez-le un instant, sans jugement. Puis, choisissez consciemment de porter votre attention ailleurs." }, { time: 360, text: "Imaginez que vous √™tes dans un endroit que vous aimez, un lieu paisible. Une plage, une for√™t, un jardin... Visualisez cet endroit avec le plus de d√©tails possible." }, { time: 420, text: "Quelles sont les couleurs ? Les formes ? Y a-t-il une odeur particuli√®re ? Une brise l√©g√®re sur votre peau ?" }, { time: 480, text: "Quels sont les sons agr√©ables de cet endroit ? Le bruit des vagues ? Le chant des oiseaux ? Le vent dans les feuilles ? Concentrez-vous sur ces sons imaginaires apaisants." }, { time: 540, text: "Si votre attention revient √† l'acouph√®ne, c'est normal. Remarquez-le simplement, puis redirigez doucement mais fermement votre attention vers les sons agr√©ables de votre lieu paisible." }, { time: 660, text: "Imaginez que vous pouvez ajuster le volume des sons. Augmentez le volume des sons agr√©ables... et diminuez mentalement le volume de l'acouph√®ne, le rendant plus lointain, moins pertinent." }, { time: 780, text: "Restez dans cet √©tat d'absorption agr√©able, en vous concentrant sur les sensations positives de votre lieu de calme." }, { time: 840, text: "Sachez que votre capacit√© √† diriger votre attention est une comp√©tence puissante que vous pouvez entra√Æner." }, { time: 870, text: "Pr√©parez-vous maintenant √† revenir. Ramenez progressivement votre conscience √† votre corps, √† la pi√®ce o√π vous √™tes. Prenez une respiration plus profonde." }, { time: 890, text: "Bougez doucement, √©tirez-vous, et ouvrez les yeux quand vous √™tes pr√™t, en emportant avec vous le calme et la capacit√© √† choisir votre focus." } ] },
                 avance: { title: "Avanc√© (env. 20 min) - Modification de la Perception", duration: 1200, script: [ { time: 0, text: "Installez-vous confortablement. Fermez les yeux et prenez quelques instants pour entrer dans un √©tat de relaxation profonde, en utilisant la technique qui vous convient le mieux (respiration, scan corporel...)." }, { time: 60, text: "Une fois bien d√©tendu, portez votre attention sur votre acouph√®ne. Observez-le avec une curiosit√© d√©tach√©e, comme un scientifique observe un ph√©nom√®ne." }, { time: 120, text: "Quelles sont ses caract√©ristiques ? Est-il aigu, grave ? Continu, pulsatile ? Est-il stable ou changeant ? Essayez de le d√©crire mentalement, sans jugement de valeur ('g√™nant', 'horrible')." }, { time: 180, text: "Imaginez maintenant que vous avez des 'cadrans de contr√¥le' mentaux pour ce son." }, { time: 240, text: "Visualisez un cadran pour le volume. Imaginez que vous tournez ce cadran tr√®s lentement vers le bas. M√™me si le son r√©el ne change pas, notez toute modification dans votre perception ou votre r√©action √©motionnelle." }, { time: 330, text: "Visualisez un cadran pour la 'tonalit√©' ou la 'qualit√©' du son. Imaginez que vous pouvez le rendre l√©g√®rement plus grave, ou plus doux, ou plus diffus. Jouez mentalement avec ces caract√©ristiques." }, { time: 420, text: "Imaginez un cadran pour la 'localisation'. Pouvez-vous mentalement d√©placer le son ? Le rendre plus externe, plus lointain ? Le laisser flotter hors de votre t√™te ?" }, { time: 510, text: "Visualisez un cadran pour l''√©motion' associ√©e au son. Imaginez tourner ce cadran de 'g√™ne' ou 'anxi√©t√©' vers 'neutre' ou m√™me 'acceptation'." }, { time: 600, text: "Maintenant, laissez les cadrans et portez votre attention sur une sensation agr√©able dans votre corps. Peut-√™tre la chaleur de vos mains, la d√©tente de vos √©paules, ou le calme de votre respiration." }, { time: 690, text: "Amplifiez cette sensation agr√©able. Laissez-la grandir et se diffuser dans tout votre corps, cr√©ant un sentiment g√©n√©ral de bien-√™tre." }, { time: 780, text: "Imaginez que ce bien-√™tre est comme une bulle protectrice autour de vous. L'acouph√®ne peut √™tre l√†, √† l'ext√©rieur ou √† l'int√©rieur de la bulle, mais il ne perturbe pas le calme √† l'int√©rieur." }, { time: 900, text: "L'acouph√®ne est juste un son. Il n'a que le pouvoir que vous lui donnez. Vous apprenez √† lui retirer ce pouvoir √©motionnel." }, { time: 1020, text: "Ancrez cette sensation de contr√¥le et de calme en vous. Prenez une profonde inspiration et expirez lentement." }, { time: 1140, text: "Rappelez-vous que cette capacit√© √† modifier votre perception s'affine avec la pratique r√©guli√®re." }, { time: 1170, text: "Commencez maintenant √† revenir progressivement √† votre √©tat de conscience habituel. Sentez l'√©nergie revenir dans votre corps. Bougez les doigts, les orteils." }, { time: 1190, text: "Quand vous √™tes pr√™t, ouvrez les yeux, en gardant ce sentiment de perspective et de calme int√©rieur renouvel√©." } ] }
             };

			// *** REMPLACEZ ENCORE VOTRE FONCTION updateHypnoTimer PAR CELLE-CI ***
			function updateHypnoTimer() {
				if (!hypnoCurrentSessionData || hypnoIsPaused) return;

				const now = Date.now();
				const elapsedSinceStart = (now - (hypnoSessionEndTime - hypnoCurrentSessionData.duration * 1000));
				const effectiveElapsed = elapsedSinceStart - hypnoTotalPauseDuration;
				const remaining = Math.max(0, hypnoCurrentSessionData.duration - effectiveElapsed / 1000);

				const timerDisplay = document.querySelector('#hypnose-session .timer');
				const progressBar = document.getElementById('session-progress-bar');
				const textContent = document.getElementById('session-text-content');
				const stepIndicator = document.getElementById('session-step-indicator');

				if (!timerDisplay || !progressBar || !textContent || !stepIndicator) { return; }

				timerDisplay.textContent = Utils.formatTime(remaining);
				const progressPercent = Math.min(100, (effectiveElapsed / 1000 / hypnoCurrentSessionData.duration) * 100);
				progressBar.style.width = `${progressPercent}%`;

				const currentStepIndex = hypnoCurrentSessionData.script.slice().reverse().findIndex(step => (effectiveElapsed / 1000) >= step.time);
				const currentStep = currentStepIndex !== -1 ? hypnoCurrentSessionData.script[hypnoCurrentSessionData.script.length - 1 - currentStepIndex] : null;

				if (currentStep) {
					const currentStepTextRaw = currentStep.text; // Texte de l'√©tape actuelle venant du script

					// *** NOUVELLE LOGIQUE DE COMPARAISON ICI ***
					// On compare le texte brut de l'√©tape actuelle avec le dernier texte qu'on a demand√© de lire
					if (currentStepTextRaw !== hypnoLastSpokenText) {
						console.log(`[updateHypnoTimer] NOUVEAU texte d√©tect√©. Pr√©c√©dent: "${(hypnoLastSpokenText || 'null').substring(0,15)}...", Nouveau: "${currentStepTextRaw.substring(0,15)}..."`);

						// 1. Mettre √† jour l'affichage DOM
						const currentStepTextEscaped = Utils.escapeHtml(currentStepTextRaw);
						textContent.innerHTML = `<p data-raw-text="${currentStepTextEscaped}">${currentStepTextEscaped}</p>`;
						textContent.scrollTop = textContent.scrollHeight;

						// 2. Mettre √† jour notre r√©f√©rence interne *apr√®s* avoir confirm√© que c'est nouveau
						hypnoLastSpokenText = currentStepTextRaw;

						// 3. Demander la lecture du nouveau texte (si activ√© et non en pause)
						if (hypnoTtsEnabled && TTSManager.isSupported() && !hypnoIsPaused) {
							 console.log(`[updateHypnoTimer] Demande lecture pour: "${hypnoLastSpokenText.substring(0,30)}..."`);
							 TTSManager.speak(hypnoLastSpokenText);
						} else if (hypnoIsPaused) {
							console.log("[updateHypnoTimer] Nouveau texte mais session en pause.");
						}
					} // *** Fin de la nouvelle logique de comparaison ***

					// Mise √† jour de l'indicateur d'√©tape (toujours fait si une √©tape existe)
					const totalSteps = hypnoCurrentSessionData.script.length;
					const currentStepNumber = hypnoCurrentSessionData.script.length - currentStepIndex;
					stepIndicator.textContent = `√âtape ${currentStepNumber} / ${totalSteps}`;

				} else {
					stepIndicator.textContent = 'Pr√©paration...';
					// Si aucune √©tape n'est trouv√©e, on pourrait r√©initialiser hypnoLastSpokenText
					// pour forcer la relecture si on revient √† la premi√®re √©tape ? (√† voir si n√©cessaire)
					// hypnoLastSpokenText = null;
				}

				if (remaining <= 0 && hypnoTimerInterval) {
					 console.log("Session hypnose termin√©e naturellement.");
					 hypnoSessionCompleted = true;
					 stopHypnoSession();
				 }
			}
			// *** FIN DU REMPLACEMENT POUR updateHypnoTimer ***

            function startHypnoSession(sessionKey) {
                console.log(`D√©marrage session: ${sessionKey}`);
                hypnoCurrentSessionData = sessionsData[sessionKey]; if (!hypnoCurrentSessionData) { UI.showToast("Erreur session.", "error"); return; }

                // R√©cup√©ration des √©l√©ments UI
                const menu = document.getElementById('hypnose-menu');
                const sessionView = document.getElementById('hypnose-session');
                const startBtn = document.getElementById('start-session-btn');
                const stopBtn = document.getElementById('stop-session-btn');
                const pauseBtn = document.getElementById('pause-session-btn');
                const resumeBtn = document.getElementById('resume-session-btn');
                const timerDisplay = sessionView?.querySelector('.timer');
                const progressBar = document.getElementById('session-progress-bar');
                const sessionTextContent = document.getElementById('session-text-content');
                const stepIndicator = document.getElementById('session-step-indicator');
                const noiseSelect = document.getElementById('hypno-noise');
                const volumeSlider = document.getElementById('hypno-volume');
                const ttsToggle = document.getElementById('hypno-tts-enable');
                const voiceSelect = document.getElementById('hypno-voice-select');


                // Initialisation √©tat
                hypnoIsPaused = false;
                hypnoPauseStartTime = 0;
                hypnoTotalPauseDuration = 0;
                hypnoSessionCompleted = false;
                hypnoLastSpokenText = null;
                hypnoNoiseType = noiseSelect.value;
                hypnoVolume = parseFloat(volumeSlider.value);
                hypnoTtsEnabled = ttsToggle.checked;

                // Mise √† jour UI initiale
                const firstStepText = hypnoCurrentSessionData.script[0]?.text || 'Pr√©paration...';
                const firstStepTextEscaped = Utils.escapeHtml(firstStepText);
                hypnoLastSpokenText = firstStepText; // D√©finit texte initial
                sessionTextContent.innerHTML = `<p data-raw-text="${firstStepTextEscaped}">${firstStepTextEscaped}</p>`;
                stepIndicator.textContent = `√âtape 1 / ${hypnoCurrentSessionData.script.length}`;
                timerDisplay.textContent = Utils.formatTime(hypnoCurrentSessionData.duration);
                progressBar.style.width = '0%';

                // Affichage/Masquage + D√©sactivation contr√¥les
                menu.classList.add('hidden');
                sessionView.classList.remove('hidden');
                startBtn.classList.add('hidden');
                stopBtn.classList.remove('hidden');
                pauseBtn.classList.remove('hidden');
                resumeBtn.classList.add('hidden'); // Resume cach√© au d√©but
                noiseSelect.disabled = true; volumeSlider.disabled = true; ttsToggle.disabled = true; voiceSelect.disabled = true;

                console.log(`Audio: ${hypnoNoiseType} vol ${hypnoVolume}. TTS: ${hypnoTtsEnabled}`);
                if (hypnoNoiseType !== 'none' && hypnoVolume > 0) AudioManager.playNoise(hypnoNoiseType, hypnoVolume);
                if (hypnoTtsEnabled && TTSManager.isSupported() && hypnoLastSpokenText) TTSManager.speak(hypnoLastSpokenText); // Lecture 1ere √©tape

                hypnoSessionEndTime = Date.now() + hypnoCurrentSessionData.duration * 1000;
                if(hypnoTimerInterval) clearInterval(hypnoTimerInterval);
                hypnoTimerInterval = setInterval(updateHypnoTimer, 500); // D√©marrage timer

                UI.showToast(`Session '${sessionKey}' d√©marr√©e.`, "info");
            }

            function pauseHypnoSession() {
                 if (!hypnoCurrentSessionData || hypnoIsPaused) return;
                 hypnoIsPaused = true;
                 hypnoPauseStartTime = Date.now();
                 if(hypnoTimerInterval) clearInterval(hypnoTimerInterval); // Arr√™te le timer JS
                 AudioManager.suspendAudio().catch(e => console.warn("Echec suspend audio context", e)); // Met l'audio en pause
                 if (TTSManager.isSpeaking()) TTSManager.cancel(); // Arr√™te la parole en cours

                 document.getElementById('pause-session-btn')?.classList.add('hidden');
                 document.getElementById('resume-session-btn')?.classList.remove('hidden');
                 UI.showToast("Session en pause.", "info");
             }

            function resumeHypnoSession() {
                 if (!hypnoCurrentSessionData || !hypnoIsPaused) return;
                 const pauseDuration = Date.now() - hypnoPauseStartTime;
                 hypnoTotalPauseDuration += pauseDuration; // Ajoute dur√©e pause au total
                 hypnoIsPaused = false;
                 hypnoPauseStartTime = 0;

                 AudioManager.resumeAudio().catch(e => console.warn("Echec resume audio context", e)); // Reprend l'audio
                 if (hypnoTtsEnabled && TTSManager.isSupported() && hypnoLastSpokenText) {
                    TTSManager.speak(hypnoLastSpokenText); // Relit le texte o√π on s'est arr√™t√©
                 }

                 if(hypnoTimerInterval) clearInterval(hypnoTimerInterval);
                 updateHypnoTimer(); // Appel imm√©diat pour rafra√Æchir affichage
                 hypnoTimerInterval = setInterval(updateHypnoTimer, 500); // Red√©marre le timer

                 document.getElementById('pause-session-btn')?.classList.remove('hidden');
                 document.getElementById('resume-session-btn')?.classList.add('hidden');
                 UI.showToast("Session reprise.", "info");
             }

            function stopHypnoSession(forced = false) {
                console.log("Arr√™t session hypnose.", forced ? "(Forc√©)" : "");
                const sessionEndedNaturally = !forced && hypnoSessionCompleted;
                if(hypnoTimerInterval) clearInterval(hypnoTimerInterval); hypnoTimerInterval = null;
                AudioManager.stopNoise(); // Arr√™te avec fondu par d√©faut
                if (TTSManager.isSpeaking()) TTSManager.cancel();

                if (hypnoCurrentSessionData) {
                     const sessionKey = Object.keys(sessionsData).find(key => sessionsData[key] === hypnoCurrentSessionData);
                     if(sessionKey) Store.addSessionLog({ sessionKey, duration: hypnoCurrentSessionData.duration, completed: sessionEndedNaturally });
                 }

                // R√©initialisation √©tat et UI
                hypnoCurrentSessionData = null; hypnoSessionCompleted = false; hypnoIsPaused = false; hypnoTotalPauseDuration = 0; hypnoLastSpokenText = null;

                const menu = document.getElementById('hypnose-menu');
                const sessionView = document.getElementById('hypnose-session');
                const startBtn = document.getElementById('start-session-btn');
                const stopBtn = document.getElementById('stop-session-btn');
                const pauseBtn = document.getElementById('pause-session-btn');
                const resumeBtn = document.getElementById('resume-session-btn');
                const noiseSelect = document.getElementById('hypno-noise');
                const volumeSlider = document.getElementById('hypno-volume');
                const ttsToggle = document.getElementById('hypno-tts-enable');
                const voiceSelect = document.getElementById('hypno-voice-select');
                const progressBar = document.getElementById('session-progress-bar');

                if (sessionView) sessionView.classList.add('hidden');
                if (menu) menu.classList.remove('hidden');
                if (stopBtn) stopBtn.classList.add('hidden');
                if (pauseBtn) pauseBtn.classList.add('hidden');
                if (resumeBtn) resumeBtn.classList.add('hidden');
                if (startBtn) { startBtn.classList.remove('hidden'); startBtn.textContent = "‚ñ∂Ô∏è S√©lectionner"; startBtn.disabled = true; startBtn.onclick = null; }
                if (noiseSelect) noiseSelect.disabled = false;
                if (volumeSlider) volumeSlider.disabled = false;
                if (ttsToggle) ttsToggle.disabled = !TTSManager.isSupported();
                if (voiceSelect) voiceSelect.disabled = !TTSManager.isSupported();
                if (progressBar) progressBar.style.width = '0%';

                if (!forced) UI.showToast(sessionEndedNaturally ? "Session termin√©e !" : "Session arr√™t√©e.", sessionEndedNaturally ? "success" : "warning");
            }

            function initHypnosePage() {
                 console.log("Init Hypnose");
                 const menu = document.getElementById('hypnose-menu');
                 const sessionView = document.getElementById('hypnose-session');
                 const startBtn = document.getElementById('start-session-btn');
                 const stopBtn = document.getElementById('stop-session-btn');
                 const pauseBtn = document.getElementById('pause-session-btn');
                 const resumeBtn = document.getElementById('resume-session-btn');
                 const ttsToggle = document.getElementById('hypno-tts-enable');
                 const voiceSelect = document.getElementById('hypno-voice-select');
                 const ttsStatus = document.getElementById('tts-status');

                 // Reset UI
                 menu?.classList.remove('hidden');
                 sessionView?.classList.add('hidden');
                 startBtn?.classList.remove('hidden'); startBtn.textContent = "‚ñ∂Ô∏è S√©lectionner"; startBtn.disabled = true; startBtn.onclick = null;
                 stopBtn?.classList.add('hidden');
                 pauseBtn?.classList.add('hidden');
                 resumeBtn?.classList.add('hidden');

                 // Setup TTS Controls
                 if (ttsToggle && ttsStatus && voiceSelect) {
                     const isTtsSupported = TTSManager.isSupported();
                     ttsToggle.disabled = !isTtsSupported;
                     voiceSelect.disabled = !isTtsSupported;
                     ttsStatus.textContent = isTtsSupported ? '' : "(Lecture vocale non support√©e par votre appareil/navigateur)";
                     if (isTtsSupported) {
                         ttsToggle.checked = Store.getTtsPreference();
                         TTSManager.populateVoiceList(); // Assure que la liste est √† jour
                         voiceSelect.value = Store.getPreferredVoiceURI() || ""; // Select saved voice or default

                         pageHandlers.ttsToggleChange = handleTtsToggleChange;
                         pageHandlers.voiceSelectChange = handleVoiceSelectChange;
                         ttsToggle.removeEventListener('change', pageHandlers.ttsToggleChange); ttsToggle.addEventListener('change', pageHandlers.ttsToggleChange);
                         voiceSelect.removeEventListener('change', pageHandlers.voiceSelectChange); voiceSelect.addEventListener('change', pageHandlers.voiceSelectChange);
                     } else { ttsToggle.checked = false; }
                 }

                 // Attach button listeners using pageHandlers
                 pageHandlers.hypnoMenuClick = handleHypnoMenuClick;
                 pageHandlers.hypnoPauseClick = pauseHypnoSession;
                 pageHandlers.hypnoResumeClick = resumeHypnoSession;
                 pageHandlers.hypnoStopClick = () => stopHypnoSession(); // Need wrapper lambda

                 menu?.removeEventListener('click', pageHandlers.hypnoMenuClick); menu?.addEventListener('click', pageHandlers.hypnoMenuClick);
                 pauseBtn?.removeEventListener('click', pageHandlers.hypnoPauseClick); pauseBtn?.addEventListener('click', pageHandlers.hypnoPauseClick);
                 resumeBtn?.removeEventListener('click', pageHandlers.hypnoResumeClick); resumeBtn?.addEventListener('click', pageHandlers.hypnoResumeClick);
                 stopBtn?.removeEventListener('click', pageHandlers.hypnoStopClick); stopBtn?.addEventListener('click', pageHandlers.hypnoStopClick);

                 console.log("Hypnose listeners attach√©s.");
             }

            function handleHypnoMenuClick(e) {
                if (e.target.tagName === 'BUTTON' && e.target.dataset.session) {
                    const sessionKey = e.target.dataset.session;
                    console.log(`Session s√©lectionn√©e: ${sessionKey}`);
                    const sessionData = sessionsData[sessionKey]; if (!sessionData) return;
                    const startBtn = document.getElementById('start-session-btn');
                    const sessionTitle = document.getElementById('session-title');
                    const sessionView = document.getElementById('hypnose-session');
                    const timerDisplay = sessionView?.querySelector('.timer');
                    const sessionTextContent = document.getElementById('session-text-content');
                    const stepIndicator = document.getElementById('session-step-indicator');
                    const progressBar = document.getElementById('session-progress-bar');

                    if (sessionTitle) sessionTitle.textContent = sessionData.title + " (Pr√™t)";
                    if (timerDisplay) timerDisplay.textContent = Utils.formatTime(sessionData.duration);
                    if (sessionTextContent) sessionTextContent.innerHTML = `<p>Pr√©parez-vous. Cliquez sur "D√©marrer".</p>`;
                    if (stepIndicator) stepIndicator.textContent = `Dur√©e: ${Math.round(sessionData.duration / 60)} min`;
                    if (progressBar) progressBar.style.width = '0%';

                    if (startBtn) {
                        startBtn.textContent = `‚ñ∂Ô∏è D√©marrer`;
                        // Nettoyer ancien listener avant d'ajouter le nouveau
                        startBtn.onclick = null;
                        startBtn.onclick = () => { console.log(`D√©marrage session ${sessionKey} via bouton.`); startHypnoSession(sessionKey); };
                        startBtn.disabled = false;
                    }
                    sessionView?.classList.remove('hidden');
                    sessionView?.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Assurer que les bons boutons sont visibles/cach√©s
                    document.getElementById('stop-session-btn')?.classList.add('hidden');
                    document.getElementById('pause-session-btn')?.classList.add('hidden');
                    document.getElementById('resume-session-btn')?.classList.add('hidden');
                     // Activer les contr√¥les audio/tts (qui √©taient peut-√™tre d√©sactiv√©s)
                     document.getElementById('hypno-noise').disabled = false;
                     document.getElementById('hypno-volume').disabled = false;
                     const ttsToggle = document.getElementById('hypno-tts-enable');
                     const voiceSelect = document.getElementById('hypno-voice-select');
                     const isTtsSupported = TTSManager.isSupported();
                     if (ttsToggle) ttsToggle.disabled = !isTtsSupported;
                     if (voiceSelect) voiceSelect.disabled = !isTtsSupported;

                }
            }
            function handleTtsToggleChange(e) { Store.setTtsPreference(e.target.checked); console.log("Pref TTS:", e.target.checked); }
            function handleVoiceSelectChange(e) { Store.setPreferredVoiceURI(e.target.value); console.log("Pref Voix:", e.target.value); }
            function cleanupHypnosePage() {
                 console.log("Cleanup Hypnose");
                 if (hypnoCurrentSessionData) stopHypnoSession(true); // Arr√™t forc√© si on quitte la page

                 // Retrait listeners
                 const menu = document.getElementById('hypnose-menu');
                 const stopBtn = document.getElementById('stop-session-btn');
                 const pauseBtn = document.getElementById('pause-session-btn');
                 const resumeBtn = document.getElementById('resume-session-btn');
                 const ttsToggle = document.getElementById('hypno-tts-enable');
                 const voiceSelect = document.getElementById('hypno-voice-select');
                 const startBtn = document.getElementById('start-session-btn');

                 if(menu && pageHandlers.hypnoMenuClick) menu.removeEventListener('click', pageHandlers.hypnoMenuClick);
                 if(stopBtn && pageHandlers.hypnoStopClick) stopBtn.removeEventListener('click', pageHandlers.hypnoStopClick);
                 if(pauseBtn && pageHandlers.hypnoPauseClick) pauseBtn.removeEventListener('click', pageHandlers.hypnoPauseClick);
                 if(resumeBtn && pageHandlers.hypnoResumeClick) resumeBtn.removeEventListener('click', pageHandlers.hypnoResumeClick);
                 if(ttsToggle && pageHandlers.ttsToggleChange) ttsToggle.removeEventListener('change', pageHandlers.ttsToggleChange);
                 if(voiceSelect && pageHandlers.voiceSelectChange) voiceSelect.removeEventListener('change', pageHandlers.voiceSelectChange);
                 if(startBtn) startBtn.onclick = null; // Important

                 // Nettoyage des r√©f√©rences
                 delete pageHandlers.hypnoMenuClick; delete pageHandlers.hypnoPauseClick; delete pageHandlers.hypnoResumeClick; delete pageHandlers.hypnoStopClick; delete pageHandlers.ttsToggleChange; delete pageHandlers.voiceSelectChange;
             }

            // --- Page G√©n√©rateur de Sons (MAJ Favoris) ---
            let soundTimerInterval_page = null; let soundTimerEndTime_page = 0;
            function updateSoundTimerDisplay_page() { const statusSpan = document.getElementById('sound-timer-status'); if (!statusSpan || !AudioManager.isPlaying() || !noiseTimer) { if (statusSpan) statusSpan.textContent = ''; clearInterval(soundTimerInterval_page); soundTimerInterval_page = null; return; } const now = Date.now(); const remainingSeconds = Math.max(0, Math.round((soundTimerEndTime_page - now) / 1000)); if (remainingSeconds > 0) statusSpan.textContent = `Arr√™t dans: ${Utils.formatTime(remainingSeconds)}`; else { statusSpan.textContent = ''; clearInterval(soundTimerInterval_page); soundTimerInterval_page = null; } }

            function initSoundsPage() {
                console.log("Init Sounds");
                const playBtn = document.getElementById('play-sound-btn');
                const stopBtn = document.getElementById('stop-sound-btn');
                const volumeSlider = document.getElementById('sound-volume');
                const saveFavBtn = document.getElementById('save-favorite-btn');

                pageHandlers.soundPlay = handlePlaySound_page;
                pageHandlers.soundStop = handleStopSound_page;
                pageHandlers.soundVolumeInput = handleSoundVolumeInput_page;
                pageHandlers.soundVolumeChange = handleSoundVolumeChange_page;
                pageHandlers.audioTimerStart = handleAudioTimerStart_page;
                pageHandlers.audioTimerEnd = handleAudioTimerEnd_page;
                pageHandlers.audioTimerClear = handleAudioTimerClear_page;
                pageHandlers.saveFavorite = handleSaveFavoriteSound_page;
                pageHandlers.playFavorite = handlePlayFavoriteSound_page;
                pageHandlers.deleteFavorite = handleDeleteFavoriteSound_page;

                playBtn?.removeEventListener('click', pageHandlers.soundPlay); playBtn?.addEventListener('click', pageHandlers.soundPlay);
                stopBtn?.removeEventListener('click', pageHandlers.soundStop); stopBtn?.addEventListener('click', pageHandlers.soundStop);
                volumeSlider?.removeEventListener('input', pageHandlers.soundVolumeInput); volumeSlider?.addEventListener('input', pageHandlers.soundVolumeInput);
                volumeSlider?.removeEventListener('change', pageHandlers.soundVolumeChange); volumeSlider?.addEventListener('change', pageHandlers.soundVolumeChange);
                saveFavBtn?.removeEventListener('click', pageHandlers.saveFavorite); saveFavBtn?.addEventListener('click', pageHandlers.saveFavorite);
                document.removeEventListener('audiotimerstart', pageHandlers.audioTimerStart); document.addEventListener('audiotimerstart', pageHandlers.audioTimerStart);
                document.removeEventListener('audiotimerend', pageHandlers.audioTimerEnd); document.addEventListener('audiotimerend', pageHandlers.audioTimerEnd);
                document.removeEventListener('audiotimerclear', pageHandlers.audioTimerClear); document.addEventListener('audiotimerclear', pageHandlers.audioTimerClear);

                // Affichage initial favoris
                updateFavoriteSoundsList_page();

                // Reset UI
                 stopBtn?.classList.add('hidden');
                 playBtn?.classList.remove('hidden');
                 document.getElementById('sound-type-select').disabled = false;
                 document.getElementById('sound-timer').disabled = false;
                 document.getElementById('sound-timer-status').textContent = '';
                 if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); soundTimerInterval_page = null;

                console.log("Sounds page listeners attach√©s.");
             }

            function updateFavoriteSoundsList_page() {
                const favorites = Store.getFavoriteSounds();
                UI.displayFavoriteSounds(favorites, pageHandlers.playFavorite, pageHandlers.deleteFavorite);
            }
            function handleSaveFavoriteSound_page() {
                const type = document.getElementById('sound-type-select').value;
                const volume = parseFloat(document.getElementById('sound-volume').value);
                const newFav = Store.addFavoriteSound({ type, volume });
                if (newFav) {
                    updateFavoriteSoundsList_page();
                    UI.showToast(`Favori "${newFav.name}" enregistr√© !`, "success");
                }
            }
            function handlePlayFavoriteSound_page(fav) {
                console.log("Lecture favori:", fav);
                document.getElementById('sound-type-select').value = fav.type;
                const volSlider = document.getElementById('sound-volume');
                volSlider.value = fav.volume;
                // Mettre √† jour l'output du slider
                if (volSlider.nextElementSibling?.tagName === 'OUTPUT') volSlider.nextElementSibling.textContent = fav.volume.toFixed(2);
                // Laisser le timer √† 0 (infini) par d√©faut pour un favori
                document.getElementById('sound-timer').value = 0;
                document.getElementById('sound-timer-status').textContent = '';
                if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); soundTimerInterval_page = null;

                handlePlaySound_page(); // Lance la lecture avec les nouveaux r√©glages
                UI.showToast(`Lecture favori: ${fav.name}`, "info");
            }
            function handleDeleteFavoriteSound_page(id) {
                const fav = Store.getFavoriteSounds().find(f => f.id === id);
                if (fav && confirm(`Supprimer le favori "${fav.name}" ?`)) {
                    Store.removeFavoriteSound(id);
                    updateFavoriteSoundsList_page();
                    UI.showToast(`Favori "${fav.name}" supprim√©.`, "info");
                }
            }

            function handlePlaySound_page() { const type = document.getElementById('sound-type-select').value; const volume = parseFloat(document.getElementById('sound-volume').value); const durationMinutes = parseInt(document.getElementById('sound-timer').value, 10) || 0; const success = AudioManager.playNoise(type, volume, durationMinutes); if (success) { document.getElementById('play-sound-btn')?.classList.add('hidden'); document.getElementById('stop-sound-btn')?.classList.remove('hidden'); document.getElementById('sound-type-select').disabled = true; document.getElementById('sound-timer').disabled = true; } }
            function handleStopSound_page(immediate = false) { const stopped = AudioManager.stopNoise(immediate); if (stopped) { document.getElementById('play-sound-btn')?.classList.remove('hidden'); document.getElementById('stop-sound-btn')?.classList.add('hidden'); document.getElementById('sound-type-select').disabled = false; document.getElementById('sound-timer').disabled = false; handleAudioTimerClear_page(); /* Assure nettoyage timer UI */ } }
            function handleSoundVolumeInput_page(e) { const volumeOutput = e.target.nextElementSibling; if (volumeOutput?.tagName === 'OUTPUT') volumeOutput.textContent = parseFloat(e.target.value).toFixed(2); if (AudioManager.isPlaying()) AudioManager.setVolume(parseFloat(e.target.value)); }
            function handleSoundVolumeChange_page(e) { if (AudioManager.isPlaying()) AudioManager.setVolume(parseFloat(e.target.value)); } // Peut-√™tre redondant avec input, mais garde pour 'change'
            function handleAudioTimerStart_page(e) { const durationMinutes = e.detail.durationMinutes; soundTimerEndTime_page = Date.now() + durationMinutes * 60 * 1000; if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); updateSoundTimerDisplay_page(); soundTimerInterval_page = setInterval(updateSoundTimerDisplay_page, 1000); }
            function handleAudioTimerEnd_page() { handleStopSound_page(); }
            function handleAudioTimerClear_page() { if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); soundTimerInterval_page = null; const statusSpan = document.getElementById('sound-timer-status'); if (statusSpan) statusSpan.textContent = ''; }

            function cleanupSoundsPage() {
                 console.log("Cleanup Sounds");
                 if (AudioManager.isPlaying()) handleStopSound_page(true); // Arr√™t imm√©diat

                 const playBtn = document.getElementById('play-sound-btn');
                 const stopBtn = document.getElementById('stop-sound-btn');
                 const volumeSlider = document.getElementById('sound-volume');
                 const saveFavBtn = document.getElementById('save-favorite-btn');

                 if(pageHandlers.soundPlay) playBtn?.removeEventListener('click', pageHandlers.soundPlay);
                 if(pageHandlers.soundStop) stopBtn?.removeEventListener('click', pageHandlers.soundStop);
                 if(pageHandlers.soundVolumeInput) volumeSlider?.removeEventListener('input', pageHandlers.soundVolumeInput);
                 if(pageHandlers.soundVolumeChange) volumeSlider?.removeEventListener('change', pageHandlers.soundVolumeChange);
                 if(pageHandlers.saveFavorite) saveFavBtn?.removeEventListener('click', pageHandlers.saveFavorite);
                 if(pageHandlers.audioTimerStart) document.removeEventListener('audiotimerstart', pageHandlers.audioTimerStart);
                 if(pageHandlers.audioTimerEnd) document.removeEventListener('audiotimerend', pageHandlers.audioTimerEnd);
                 if(pageHandlers.audioTimerClear) document.removeEventListener('audiotimerclear', pageHandlers.audioTimerClear);
                 // Nettoyer la liste des favoris pour enlever les listeners (si ajout√©s dynamiquement sur les boutons)
                 const favList = document.getElementById('favorite-sounds-list');
                 if (favList) favList.innerHTML = '<li id="no-favorites-msg">Aucun favori enregistr√©.</li>'; // Reset simple

                 delete pageHandlers.soundPlay; delete pageHandlers.soundStop; delete pageHandlers.soundVolumeInput; delete pageHandlers.soundVolumeChange; delete pageHandlers.saveFavorite; delete pageHandlers.playFavorite; delete pageHandlers.deleteFavorite; delete pageHandlers.audioTimerStart; delete pageHandlers.audioTimerEnd; delete pageHandlers.audioTimerClear;

                 if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); soundTimerInterval_page = null;
                 console.log("Sounds page listeners removed.");
             }

            // --- Page Suivi (MAJ Graphique) ---
            function initTrackingPage() {
                console.log("Init Tracking");
                const form = document.getElementById('tracking-form'); const clearDataBtn = document.getElementById('clear-data-btn'); const exportJsonBtn = document.getElementById('export-data-btn'); const exportCsvBtn = document.getElementById('export-csv-btn'); const historyLimitSelect = document.getElementById('history-limit'); const chartLimitSelect = document.getElementById('chart-limit');

                pageHandlers.trackingSubmit = handleTrackingSubmit;
                pageHandlers.clearData = handleClearData;
                pageHandlers.exportJson = handleExportJson;
                pageHandlers.exportCsv = handleExportCsv;
                pageHandlers.updateTracking = updateTrackingDisplay;

                form?.removeEventListener('submit', pageHandlers.trackingSubmit); form?.addEventListener('submit', pageHandlers.trackingSubmit);
                clearDataBtn?.removeEventListener('click', pageHandlers.clearData); clearDataBtn?.addEventListener('click', pageHandlers.clearData);
                exportJsonBtn?.removeEventListener('click', pageHandlers.exportJson); exportJsonBtn?.addEventListener('click', pageHandlers.exportJson);
                exportCsvBtn?.removeEventListener('click', pageHandlers.exportCsv); exportCsvBtn?.addEventListener('click', pageHandlers.exportCsv);
                historyLimitSelect?.removeEventListener('change', pageHandlers.updateTracking); historyLimitSelect?.addEventListener('change', pageHandlers.updateTracking);
                chartLimitSelect?.removeEventListener('change', pageHandlers.updateTracking); chartLimitSelect?.addEventListener('change', pageHandlers.updateTracking);

                updateTrackingDisplay();
                console.log("Tracking page listeners attached.");
             }

            function updateTrackingDisplay() { const historyLimit = document.getElementById('history-limit')?.value || '30'; const chartLimit = document.getElementById('chart-limit')?.value || '30'; let limitHistoryNum = historyLimit === 'all' ? null : parseInt(historyLimit, 10); let limitChartDays = chartLimit === 'all' ? null : parseInt(chartLimit, 10); const entries = Store.getJournalEntries(limitHistoryNum); UI.displayJournalHistory(entries); const allJournalData = Store.getState().journal; drawIntensityChart(allJournalData, limitChartDays); }
            function handleTrackingSubmit(e) { e.preventDefault(); const form = e.target; const formData = new FormData(form); const newEntry = { intensity: formData.get('intensity'), notes: formData.get('notes') }; const savedEntry = Store.addJournalEntry(newEntry); if (savedEntry) { form.reset(); const intensityRange = document.getElementById('tracking-intensity'); if(intensityRange && intensityRange.nextElementSibling) intensityRange.nextElementSibling.textContent = intensityRange.defaultValue || '5'; UI.showToast('Entr√©e ajout√©e.', 'success'); updateTrackingDisplay(); } else { UI.showToast("Erreur ajout entr√©e.", 'error'); } }
            function handleClearData() { Store.clearAllData(); }
            function handleExportJson() { try { const data = Store.getState(); const dataStr = JSON.stringify(data, null, 2); const blob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `acouphenes_zen_data_${new Date().toISOString().split('T')[0]}.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); UI.showToast("Export JSON OK.", "success"); } catch (e) { console.error("Erreur export JSON:", e); UI.showToast("Erreur export JSON.", "error"); } }
            function handleExportCsv() { try { const journal = Store.getState().journal; if (!journal || journal.length === 0) { UI.showToast("Journal vide.", "warning"); return; } const header = "DateHeureISO;Intensite;Notes\n"; const rows = journal.map(entry => { const date = entry.date; const intensity = entry.intensity; let notes = entry.notes || ""; if (notes.includes('"') || notes.includes(';') || notes.includes('\n')) { notes = `"${notes.replace(/"/g, '""')}"`; } return `${date};${intensity};${notes}`; }); const csvContent = "\uFEFF" + header + rows.join("\n"); /* Ajout BOM pour Excel FR */ const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `acouphenes_zen_journal_${new Date().toISOString().split('T')[0]}.csv`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); UI.showToast("Export CSV OK.", "success"); } catch (e) { console.error("Erreur export CSV:", e); UI.showToast("Erreur export CSV.", "error"); } }

            function drawIntensityChart(data, limitDays) {
                const container = document.getElementById('tracking-chart');
                const noDataMsg = document.getElementById('chart-no-data');
                if (!container || !noDataMsg) return;
                container.innerHTML = ''; noDataMsg.classList.add('hidden');

                let filteredData = data;
                if (limitDays !== null && limitDays > 0) {
                    const limitDate = new Date(); limitDate.setDate(limitDate.getDate() - limitDays);
                    filteredData = data.filter(entry => new Date(entry.date) >= limitDate);
                }

                if (filteredData.length < 2) { noDataMsg.classList.remove('hidden'); return; }
                filteredData.sort((a, b) => new Date(a.date) - new Date(b.date));

                // Calculer la moyenne
                const sumIntensity = filteredData.reduce((sum, entry) => sum + entry.intensity, 0);
                const averageIntensity = sumIntensity / filteredData.length;

                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, "svg");
                const containerRect = container.getBoundingClientRect();
                const svgWidth = containerRect.width || 600;
                const svgHeight = 250;
                const margin = { top: 20, right: 30, bottom: 40, left: 40 };
                const width = svgWidth - margin.left - margin.right;
                const height = svgHeight - margin.top - margin.bottom;
                svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
                svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
                svg.style.width = "100%"; svg.style.height = `${svgHeight}px`;
                const g = document.createElementNS(svgNS, "g");
                g.setAttribute("transform", `translate(${margin.left},${margin.top})`);
                svg.appendChild(g);

                const firstDate = new Date(filteredData[0].date);
                const lastDate = new Date(filteredData[filteredData.length - 1].date);
                const totalTimeDiff = Math.max(1, lastDate.getTime() - firstDate.getTime()); // Avoid division by zero
                const xScale = (date) => ((new Date(date).getTime() - firstDate.getTime()) / totalTimeDiff) * width;
                const yScale = (intensity) => height - (intensity / 10) * height;

                // Axes et Grille (comme avant)
                const yAxis = document.createElementNS(svgNS, "line"); yAxis.setAttribute("x1", 0); yAxis.setAttribute("y1", 0); yAxis.setAttribute("x2", 0); yAxis.setAttribute("y2", height); yAxis.setAttribute("class", "chart-axis"); g.appendChild(yAxis);
                [0, 2, 4, 6, 8, 10].forEach(val => { const y = yScale(val); const label = document.createElementNS(svgNS, "text"); label.setAttribute("x", -margin.left / 2 + 10); label.setAttribute("y", y); label.setAttribute("dy", "0.32em"); label.setAttribute("class", "chart-text axis-label-y"); label.textContent = val; g.appendChild(label); const gridLine = document.createElementNS(svgNS, "line"); gridLine.setAttribute("x1", 0); gridLine.setAttribute("y1", y); gridLine.setAttribute("x2", width); gridLine.setAttribute("y2", y); gridLine.setAttribute("class", "chart-grid"); g.appendChild(gridLine); });
                const xAxis = document.createElementNS(svgNS, "line"); xAxis.setAttribute("x1", 0); xAxis.setAttribute("y1", height); xAxis.setAttribute("x2", width); xAxis.setAttribute("y2", height); xAxis.setAttribute("class", "chart-axis"); g.appendChild(xAxis);
                const formatDateLabel = (date) => date.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit'});
                [firstDate, lastDate].forEach((date, index) => { if(!date) return; const x = index === 0 ? 0 : width; const label = document.createElementNS(svgNS, "text"); label.setAttribute("x", x); label.setAttribute("y", height + margin.bottom / 2); label.setAttribute("dy", "0.71em"); label.setAttribute("class", "chart-text axis-label-x"); label.style.textAnchor = index === 0 ? "start" : "end"; label.textContent = formatDateLabel(date); g.appendChild(label); });

                 // Ligne de donn√©es principale
                 const linePath = document.createElementNS(svgNS, "path");
                 const pathData = filteredData.map((d, i) => { const x = xScale(d.date); const y = yScale(d.intensity); return `${i === 0 ? 'M' : 'L'} ${x.toFixed(2)} ${y.toFixed(2)}`; }).join(" ");
                 linePath.setAttribute("d", pathData);
                 linePath.setAttribute("class", "chart-line");
                 g.appendChild(linePath);

                 // Points de donn√©es (comme avant)
                 filteredData.forEach(d => { const x = xScale(d.date); const y = yScale(d.intensity); const point = document.createElementNS(svgNS, "circle"); point.setAttribute("cx", x); point.setAttribute("cy", y); point.setAttribute("r", 4); point.setAttribute("class", "chart-point"); const title = document.createElementNS(svgNS, "title"); const pointDate = new Date(d.date); title.textContent = `${pointDate.toLocaleDateString('fr-FR')} ${pointDate.toLocaleTimeString('fr-FR',{hour:'2-digit', minute:'2-digit'})} - Intensit√©: ${d.intensity}`; point.appendChild(title); g.appendChild(point); });

                // *** NOUVEAU: Ligne Moyenne ***
                if (averageIntensity >= 0 && averageIntensity <= 10) {
                    const yAvg = yScale(averageIntensity);
                    const avgLine = document.createElementNS(svgNS, "line");
                    avgLine.setAttribute("x1", 0);
                    avgLine.setAttribute("y1", yAvg);
                    avgLine.setAttribute("x2", width);
                    avgLine.setAttribute("y2", yAvg);
                    avgLine.setAttribute("class", "chart-average-line");
                    g.appendChild(avgLine);
                    // Label pour la moyenne
                    const avgLabel = document.createElementNS(svgNS, "text");
                    avgLabel.setAttribute("x", width + 5); // Position √† droite
                    avgLabel.setAttribute("y", yAvg);
                    avgLabel.setAttribute("dy", "0.32em");
                    avgLabel.setAttribute("class", "chart-text");
                    avgLabel.style.fill = "var(--accent-color)";
                    avgLabel.style.textAnchor = "start";
                    avgLabel.textContent = `Moy: ${averageIntensity.toFixed(1)}`;
                    g.appendChild(avgLabel);
                }

                container.appendChild(svg);
            }

            function cleanupTrackingPage() {
                 console.log("Cleanup Tracking");
                 const form = document.getElementById('tracking-form'); const clearDataBtn = document.getElementById('clear-data-btn'); const exportJsonBtn = document.getElementById('export-data-btn'); const exportCsvBtn = document.getElementById('export-csv-btn'); const historyLimitSelect = document.getElementById('history-limit'); const chartLimitSelect = document.getElementById('chart-limit');
                 if(pageHandlers.trackingSubmit) form?.removeEventListener('submit', pageHandlers.trackingSubmit);
                 if(pageHandlers.clearData) clearDataBtn?.removeEventListener('click', pageHandlers.clearData);
                 if(pageHandlers.exportJson) exportJsonBtn?.removeEventListener('click', pageHandlers.exportJson);
                 if(pageHandlers.exportCsv) exportCsvBtn?.removeEventListener('click', pageHandlers.exportCsv);
                 if(pageHandlers.updateTracking) { historyLimitSelect?.removeEventListener('change', pageHandlers.updateTracking); chartLimitSelect?.removeEventListener('change', pageHandlers.updateTracking); }
                 const container = document.getElementById('tracking-chart'); if (container) container.innerHTML = '';
                 delete pageHandlers.trackingSubmit; delete pageHandlers.clearData; delete pageHandlers.exportJson; delete pageHandlers.exportCsv; delete pageHandlers.updateTracking;
                 console.log("Tracking listeners removed.");
             }

            // --- Page Ressources ---
            function initResourcesPage() { console.log("Init Ressources"); }
            function cleanupResourcesPage() { console.log("Cleanup Ressources"); }

            // --- Initialisation G√©n√©rale & Widgets ---
             function initThemeToggle() { const toggleButton = document.getElementById('theme-toggle'); if (toggleButton) { toggleButton.addEventListener('click', () => { const currentTheme = Store.getThemePreference(); const newTheme = currentTheme === 'dark' ? 'light' : 'dark'; Store.updateThemePreference(newTheme); /* applyThemePreference est appel√© dans update */ }); Store.applyThemePreference(); } }

             // Init Widget Entr√©e Rapide
             function initQuickEntry() {
                 const slider = document.getElementById('quick-intensity-slider');
                 const output = document.getElementById('quick-intensity-output');
                 const submitBtn = document.getElementById('quick-intensity-submit');

                 if (slider && output && submitBtn) {
                     pageHandlers.quickEntrySubmit = () => {
                         const intensity = slider.value;
                         const saved = Store.addJournalEntry({ intensity: intensity, notes: "Entr√©e rapide" });
                         if (saved) {
                             UI.showToast(`Intensit√© ${intensity}/10 not√©e.`, 'success');
                             // Optionnel: Mettre √† jour l'historique/graphique si la page suivi est active
                             if (window.location.hash === '#tracking') {
                                 updateTrackingDisplay();
                             }
                             // Reset slider to default? Or keep value? Let's reset.
                             slider.value = 5;
                             output.textContent = 5;
                         } else {
                             UI.showToast("Erreur notation rapide.", 'error');
                         }
                     };
                     // Nettoyer listener pr√©c√©dent si existe
                     submitBtn.removeEventListener('click', pageHandlers.quickEntrySubmit);
                     submitBtn.addEventListener('click', pageHandlers.quickEntrySubmit);
                     // Assurer que l'output initial est correct
                     output.textContent = slider.value;

                 } else {
                     console.warn("Widget d'entr√©e rapide non trouv√©.");
                 }
             }

            // --- D√âMARRAGE DE L'APPLICATION ---
            Router.init();
            console.log("Acouph√®nes Zen App Ready v1.1 Enhanced.");

        }); // Fin de DOMContentLoaded
    </script>
</body>
</html>
