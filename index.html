<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Titre mis à jour pour refléter la finalisation -->
    <title>Acouphènes Zen v1.0 - Gestion & Auto-hypnose</title>
    <style>
        /* --- CSS Intégré --- */

        /* Variables (Thème Clair par défaut) */
        :root {
            --bg-color: #f4f7f9;
            --text-color: #333;
            --primary-color: #4a90e2; /* Bleu doux */
            --secondary-color: #7cb342; /* Vert apaisant */
            --accent-color: #f7b731; /* Jaune doux */
            --card-bg: #ffffff;
            --border-color: #e0e0e0;
            --input-bg: #ffffff;
            --button-text: #ffffff;
            --link-color: #4a90e2;
            --disabled-color: #cccccc;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --danger-color: #e74c3c; /* Rouge pour suppression */

            /* Nouvelle variable pour le padding dynamique */
            --nav-height: 70px; /* Valeur par défaut, sera ajustée par JS */

            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-size-base: 16px;
            --line-height-base: 1.6;

            --spacing-xs: 4px;
            --spacing-s: 8px;
            --spacing-m: 16px;
            --spacing-l: 24px;
            --spacing-xl: 32px;

            --border-radius: 4px;
            --shadow: 0 2px 5px var(--shadow-color);
        }

        /* Thème Sombre */
        body.dark-mode {
            --bg-color: #2c3e50; /* Bleu nuit */
            --text-color: #ecf0f1; /* Blanc cassé */
            --primary-color: #5dade2; /* Bleu plus clair */
            --secondary-color: #82e0aa; /* Vert plus clair */
            --accent-color: #f4d03f; /* Jaune plus clair */
            --card-bg: #34495e; /* Bleu gris foncé */
            --border-color: #4b6584; /* Gris bleu */
            --input-bg: #4b6584;
            --button-text: #2c3e50; /* Texte sombre pour boutons clairs */
            --link-color: #5dade2;
            --disabled-color: #7f8c8d; /* Gris sombre */
            --shadow-color: rgba(0, 0, 0, 0.3);
            --danger-color: #f1948a; /* Rouge plus clair */
        }

        /* Reset et Styles Globaux */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: var(--font-size-base);
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: var(--line-height-base);
            transition: background-color 0.3s ease, color 0.3s ease;
            /* Le padding-top est maintenant défini dynamiquement par JS */
            /* padding-top: var(--nav-height); */
        }

        #app {
            max-width: 900px;
            margin: 0 auto;
            padding: var(--spacing-l);
        }

        /* Navigation */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: var(--card-bg);
            box-shadow: var(--shadow);
            padding: var(--spacing-s) var(--spacing-l);
            z-index: 1000;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            /* Transition pour la hauteur si elle devait changer dynamiquement */
            /* transition: height 0.3s ease; */
        }
         nav .nav-brand {
            font-weight: bold;
            font-size: 1.3em;
            color: var(--primary-color);
            text-decoration: none;
            margin-right: var(--spacing-l);
         }

        nav ul {
            list-style: none;
            display: flex;
            gap: var(--spacing-m);
            flex-wrap: wrap;
             align-items: center;
        }

        nav a {
            text-decoration: none;
            color: var(--link-color);
            font-weight: 500;
            transition: color 0.2s ease, background-color 0.2s ease;
            padding: var(--spacing-s) var(--spacing-m);
            border-radius: var(--border-radius);
        }

        nav a:hover,
        nav a.active {
            color: var(--primary-color);
            background-color: color-mix(in srgb, var(--primary-color) 10%, transparent);
        }

        /* Contenu Principal */
        main {
            /* Pas besoin de padding-top ici, car le body l'a déjà */
            min-height: calc(100vh - var(--nav-height) - 80px); /* Ajuster pour footer */
        }

        .content-section {
            background-color: var(--card-bg);
            padding: var(--spacing-l);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: var(--spacing-l);
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Éléments de Formulaire */
        fieldset {
            border: 1px solid var(--border-color);
            padding: var(--spacing-m);
            border-radius: var(--border-radius);
            margin-bottom: var(--spacing-l); /* Ajout marge en bas */
        }
        legend {
            font-weight: 600;
            padding: 0 var(--spacing-s);
            color: var(--primary-color);
            margin-bottom: var(--spacing-m); /* Ajout marge en bas */
        }
        label {
            display: block;
            margin-bottom: var(--spacing-s);
            font-weight: 500;
        }
        /* Style pour les groupes de radio boutons */
        .radio-group label,
        .checkbox-group label { /* Ajout pour checkbox TTS */
            display: inline-block;
            margin-right: var(--spacing-m);
            font-weight: normal;
            vertical-align: middle;
            cursor: pointer;
        }
        .radio-group input[type="radio"],
        .checkbox-group input[type="checkbox"] { /* Ajout pour checkbox TTS */
            margin-right: var(--spacing-xs);
            vertical-align: middle;
            cursor: pointer;
        }


        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: var(--spacing-s) var(--spacing-m);
            margin-bottom: var(--spacing-m);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: inherit;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

         /* Style pour les sliders */
        input[type="range"] {
            width: calc(100% - 50px); /* Laisser de la place pour l'output */
            vertical-align: middle;
             cursor: pointer;
             margin-bottom: var(--spacing-m); /* Assurer espace en bas */
        }
        output {
            display: inline-block;
            min-width: 30px;
            text-align: right;
            font-weight: bold;
            color: var(--primary-color);
            vertical-align: middle;
            margin-left: var(--spacing-s);
        }

        button,
        .button {
            display: inline-block;
            background-color: var(--primary-color);
            color: var(--button-text);
            border: none;
            padding: var(--spacing-m) var(--spacing-l);
            border-radius: var(--border-radius);
            font-size: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            text-align: center;
            text-decoration: none;
             margin-right: var(--spacing-s); /* Espace entre boutons */
             margin-bottom: var(--spacing-s); /* Espace si wrap */
        }
         button:last-child, .button:last-child {
             margin-right: 0;
         }

        button:hover,
        .button:hover {
            background-color: color-mix(in srgb, var(--primary-color) 90%, black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        button:disabled,
        .button:disabled {
            background-color: var(--disabled-color);
            color: color-mix(in srgb, var(--text-color) 50%, var(--disabled-color));
            cursor: not-allowed;
            box-shadow: none;
        }

        .button-secondary {
            background-color: var(--secondary-color);
        }
         .button-secondary:hover {
            background-color: color-mix(in srgb, var(--secondary-color) 90%, black);
        }
        .button-danger {
            background-color: var(--danger-color);
        }
         .button-danger:hover {
            background-color: color-mix(in srgb, var(--danger-color) 80%, black);
         }

        /* Utilitaires */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .mt-s { margin-top: var(--spacing-s); }
        .mt-m { margin-top: var(--spacing-m); }
        .mt-l { margin-top: var(--spacing-l); }
        .mb-s { margin-bottom: var(--spacing-s); }
        .mb-m { margin-bottom: var(--spacing-m); }
        .mb-l { margin-bottom: var(--spacing-l); }
        .mr-m { margin-right: var(--spacing-m); }
         .alert {
             padding: var(--spacing-m);
             margin-top: var(--spacing-m); /* Ajout espace au dessus */
             margin-bottom: var(--spacing-m);
             border-radius: var(--border-radius);
             border: 1px solid transparent;
         }
         .alert-info {
             color: #0c5460;
             background-color: #d1ecf1;
             border-color: #bee5eb;
         }
         .alert-warning {
            color: #856404;
            background-color: #fff3cd;
            border-color: #ffeeba;
         }
         .alert-success {
            color: #155724;
            background-color: #d4edda;
            border-color: #c3e6cb;
         }
         .alert-danger {
             color: #721c24;
             background-color: #f8d7da;
             border-color: #f5c6cb;
         }
         /* Style pour Toast (Notifications) */
         .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            border-radius: 25px; /* Plus arrondi */
            color: white;
            z-index: 1001;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            opacity: 0;
            transition: opacity 0.5s ease, bottom 0.5s ease;
            font-size: 0.95em;
            text-align: center;
         }
         .toast-info { background-color: #3498db; }
         .toast-success { background-color: #2ecc71; }
         .toast-warning { background-color: #f39c12; color: #333; }
         .toast-error { background-color: #e74c3c; }
         .toast.show {
             opacity: 1;
             bottom: 30px; /* Remonte un peu */
         }


        /* Styles spécifiques aux modules */
        #hypnose-session .timer {
            font-size: 2.5em;
            font-weight: bold;
            text-align: center;
            margin: var(--spacing-l) 0;
            color: var(--secondary-color);
             font-variant-numeric: tabular-nums;
        }
        #hypnose-session .session-text {
            background-color: color-mix(in srgb, var(--bg-color) 95%, var(--text-color));
            padding: var(--spacing-m) var(--spacing-l);
            border-radius: var(--border-radius);
            min-height: 180px;
            border-left: 5px solid var(--primary-color);
            font-size: 1.1em;
            line-height: 1.7;
            overflow-y: auto;
            max-height: 300px;
            margin-bottom: var(--spacing-l); /* Espace avant controles */
        }
        #hypnose-session .controls {
            border-top: 1px solid var(--border-color);
            padding-top: var(--spacing-m);
            text-align: left; /* Aligner les contrôles à gauche */
        }
        #hypnose-session .controls > div { margin-bottom: var(--spacing-m); } /* Espace entre lignes de contrôles */
        #hypnose-session .controls label { display: inline-block; margin-right: var(--spacing-s); min-width: 100px; }
        #hypnose-session .controls input[type="range"] { width: 120px; vertical-align: middle; }
        #hypnose-session .controls select { width: auto; display: inline-block; margin-right: var(--spacing-m); vertical-align: middle; }
        #hypnose-session .controls .checkbox-group { margin-top: var(--spacing-s); } /* Espace pour le toggle TTS */
        #hypnose-session .tts-status { /* Style pour message support TTS */
            font-size: 0.9em;
            font-style: italic;
            margin-left: var(--spacing-s);
            color: var(--disabled-color);
        }

        /* Suivi */
        #tracking-history { margin-bottom: var(--spacing-l); }
        #tracking-history ul {
            list-style: none;
            padding-left: 0;
             max-height: 400px;
             overflow-y: auto;
             border: 1px solid var(--border-color);
             padding: var(--spacing-m);
             border-radius: var(--border-radius);
             margin-top: var(--spacing-s); /* Espace après select */
        }
        #tracking-history li {
            border-bottom: 1px dashed var(--border-color);
            padding: var(--spacing-m) 0;
            margin-bottom: var(--spacing-s);
        }
         #tracking-history li:last-child {
            border-bottom: none;
            margin-bottom: 0;
         }
         #tracking-history strong { color: var(--primary-color); }
         #tracking-history em { color: color-mix(in srgb, var(--text-color) 70%, var(--bg-color));}
         #tracking-history .controls label, #tracking-chart-container .controls label { margin-right: var(--spacing-s); }
         #tracking-history .controls select, #tracking-chart-container .controls select { width: auto; vertical-align: middle; }

         /* Graphique SVG */
        #tracking-chart-container {
            margin-top: var(--spacing-l);
             min-height: 280px; /* Un peu plus haut */
             border: 1px solid var(--border-color);
             border-radius: var(--border-radius);
             padding: var(--spacing-m);
             position: relative;
        }
         #tracking-chart-container svg {
             display: block;
             width: 100%;
             height: 100%;
             min-height: 240px; /* Hauteur min du SVG */
         }
         .chart-line {
            fill: none;
            stroke: var(--secondary-color);
            stroke-width: 2.5px; /* Ligne un peu plus épaisse */
         }
         .chart-point {
            fill: var(--primary-color);
            stroke: var(--card-bg);
            stroke-width: 1.5px;
             cursor: pointer; /* Indiquer cliquable (même si pas d'action) */
             transition: r 0.2s ease;
         }
         .chart-point:hover {
             r: 6; /* Grossir au survol */
         }
         .chart-axis {
            stroke: var(--border-color);
            stroke-width: 1px;
         }
         .chart-grid { /* Style pour les lignes de grille */
             stroke: var(--border-color);
             stroke-width: 1px;
             opacity: 0.3;
             stroke-dasharray: 2,2; /* Pointillés */
         }
         .chart-text {
            font-size: 11px; /* Légèrement plus grand */
            fill: var(--text-color);
            text-anchor: middle;
         }
         .chart-text.axis-label-y { text-anchor: end; }
         .chart-text.axis-label-x { text-anchor: middle; }
         .chart-no-data {
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             color: var(--disabled-color);
             font-style: italic;
         }

         /* Footer */
         footer {
             text-align: center;
             padding: var(--spacing-l); /* Plus d'espace */
             margin-top: var(--spacing-l);
             font-size: 0.9em;
             color: color-mix(in srgb, var(--text-color) 60%, var(--bg-color));
             border-top: 1px solid var(--border-color);
         }


        /* Responsive */
        @media (max-width: 768px) {
            body {
                /* Le padding est géré par JS, pas besoin de le changer ici */
            }
            nav {
                padding: var(--spacing-s) var(--spacing-m);
                justify-content: center;
            }
            nav .nav-brand { margin-bottom: var(--spacing-s); width: 100%; text-align: center; }
            nav ul {
                 gap: var(--spacing-s);
                 justify-content: center;
                 width: 100%;
                 margin-top: var(--spacing-s);
            }
            #app {
                 padding: var(--spacing-m);
            }
            .content-section {
                 padding: var(--spacing-m);
            }
             input[type="range"] { width: calc(100% - 40px); }
             output { min-width: 25px; }
             #hypnose-session .timer { font-size: 2em; }
             #hypnose-session .controls label { min-width: 80px; } /* Réduire largeur min label */
             #hypnose-session .controls input[type="range"] { width: 100px; }
        }
        @media (max-width: 480px) {
            /* Ajustements fins pour très petits écrans */
             nav ul { gap: var(--spacing-xs); }
             nav a { padding: var(--spacing-xs) var(--spacing-s); font-size: 0.9em; }
             button, .button { font-size: 0.95em; padding: var(--spacing-s) var(--spacing-m); }
             .chart-text { font-size: 9px; }
        }

        /* Theme Toggle */
        #theme-toggle {
            cursor: pointer;
            background: none;
            border: none;
            font-size: 1.6em;
            padding: 0 var(--spacing-s);
            color: var(--text-color);
             margin-left: auto; /* Pousse le bouton vers la droite */
             order: 3; /* S'assurer qu'il reste à droite même si nav wrap */
        }
        @media (max-width: 768px) {
            #theme-toggle { margin-left: 0; order: 0; /* Remettre au début ou fin ? */ }
        }

    </style>
</head>
<body>
    <!-- Le contenu de l'app -->
    <div id="app">
        <!-- Navigation (reste identique) -->
        <nav id="main-nav">
             <a href="#home" class="nav-brand">Acouphènes Zen</a>
            <ul>
                <li><a href="#home">Accueil</a></li>
                <li><a href="#evaluation">Évaluation</a></li>
                <li><a href="#hypnose">Auto-Hypnose</a></li>
                <li><a href="#sounds">Sons</a></li>
                <li><a href="#tracking">Suivi</a></li>
                <li><a href="#resources">Ressources</a></li>
            </ul>
             <button id="theme-toggle" title="Changer le thème">☀️</button>
        </nav>

        <!-- Contenu principal -->
        <main id="main-content">
            <!-- Le contenu des templates sera injecté ici -->
        </main>

        <!-- Footer (reste identique) -->
        <footer>
            <p>Acouphènes Zen &copy; 2024 - Outil de gestion non médical.</p>
            <p style="font-size: 0.8em; margin-top: 5px;"><strong>Important:</strong> Cette application ne remplace pas un avis médical. Consultez un professionnel de santé.</p>
        </footer>
    </div>

    <!-- --- Modèles HTML (Contenu interne principalement identique, sauf template-hypnose) --- -->

    <template id="template-home">
        <!-- Contenu de template-home (inchangé par rapport à la version précédente) -->
         <section class="content-section">
            <h1>Bienvenue sur Acouphènes Zen</h1>
            <p class="lead" style="font-size: 1.1em;">Votre compagnon pour mieux comprendre et gérer vos acouphènes au quotidien grâce à l'auto-hypnose et aux sons thérapeutiques.</p>

            <div class="alert alert-warning mt-l mb-l">
                <strong>Avertissement Important :</strong> Acouphènes Zen est un outil d'accompagnement et de gestion. Il n'est pas destiné à diagnostiquer, traiter ou guérir les acouphènes. Consultez <strong>toujours</strong> un médecin ou un spécialiste ORL pour un diagnostic précis et un plan de traitement adapté à votre situation.
            </div>

            <h2 class="mt-l">Comment cette application peut vous aider :</h2>
            <ul>
                <li><strong>Comprendre :</strong> Accédez à des informations claires sur les acouphènes et l'approche par l'auto-hypnose (<a href="#resources">Ressources</a>).</li>
                <li><strong>Évaluer :</strong> Faites une première évaluation de vos acouphènes et de leur impact (<a href="#evaluation">Évaluation</a>).</li>
                <li><strong>Apaiser :</strong> Utilisez des sessions guidées d'auto-hypnose conçues pour la relaxation et la gestion de la perception des acouphènes (<a href="#hypnose">Auto-Hypnose</a>). Celles-ci peuvent maintenant être lues à voix haute !</li>
                <li><strong>Masquer :</strong> Générez des sons thérapeutiques (bruit blanc, rose, brun) pour potentiellement réduire la gêne occasionnée par les acouphènes (<a href="#sounds">Sons</a>).</li>
                <li><strong>Suivre :</strong> Tenez un journal de l'intensité de vos acouphènes et visualisez votre progression (<a href="#tracking">Suivi</a>).</li>
            </ul>

            <h2 class="mt-l">Pour commencer :</h2>
            <p>Nous vous recommandons de commencer par la section <a href="#evaluation">Évaluation</a> pour mieux cerner votre situation. Ensuite, explorez les sessions d'<a href="#hypnose">Auto-Hypnose</a> ou le <a href="#sounds">Générateur de Sons</a>.</p>

            <p class="mt-m" style="font-style: italic;">Toutes vos données sont stockées <strong>uniquement sur votre appareil</strong> (dans le stockage local de votre navigateur) et ne sont jamais envoyées sur un serveur.</p>

            <div class="text-center mt-l">
                <a href="#evaluation" class="button">Commencer l'évaluation</a>
            </div>
        </section>
    </template>

    <template id="template-evaluation">
        <!-- Contenu de template-evaluation (inchangé) -->
         <section class="content-section">
            <h2>Évaluation Initiale des Acouphènes</h2>
            <form id="evaluation-form">
                <p>Ce questionnaire aide à mieux comprendre vos acouphènes et leur impact. Vos réponses sont confidentielles et stockées localement.</p>

                <fieldset class="mb-l">
                    <legend>Caractéristiques des acouphènes</legend>
                    <label for="sound-type">Quel type de son entendez-vous principalement ? (Ex: Sifflement aigu, bourdonnement grave, pulsation, cliquetis...)</label>
                    <input type="text" id="sound-type" name="sound-type" required placeholder="Décrivez le son principal">

                    <label class="mt-m">Le son est-il perçu dans :</label>
                    <div class="radio-group">
                        <input type="radio" id="ear-left" name="ear-location" value="left"> <label for="ear-left">Oreille gauche</label>
                        <input type="radio" id="ear-right" name="ear-location" value="right"> <label for="ear-right">Oreille droite</label>
                        <input type="radio" id="ear-both" name="ear-location" value="both" checked> <label for="ear-both">Les deux oreilles</label>
                        <input type="radio" id="ear-head" name="ear-location" value="head"> <label for="ear-head">Dans la tête</label>
                    </div>

                    <label for="intensity-avg" class="mt-m">Sur une échelle de 0 (pas d'acouphène audible) à 10 (insupportablement fort), quelle est l'intensité <strong>moyenne</strong> de vos acouphènes quand vous y prêtez attention ?</label>
                    <input type="range" id="intensity-avg" name="intensity-avg" min="0" max="10" value="5" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>5</output>

                    <label for="variation" class="mt-m">L'intensité de vos acouphènes varie-t-elle beaucoup au cours de la journée ou des jours ?</label>
                    <select id="variation" name="variation">
                        <option value="peu">Peu ou pas</option>
                        <option value="moderee">Modérément</option>
                        <option value="beaucoup">Beaucoup</option>
                    </select>
                </fieldset>

                 <fieldset class="mb-l">
                     <legend>Impact sur votre quotidien</legend>
                     <label for="impact-sleep">Sur une échelle de 0 (aucun impact) à 10 (impact majeur), à quel point vos acouphènes affectent-ils votre <strong>sommeil</strong> (endormissement, réveils) ?</label>
                    <input type="range" id="impact-sleep" name="impact-sleep" min="0" max="10" value="3" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>3</output>

                     <label for="impact-concentration" class="mt-m">À quel point affectent-ils votre capacité de <strong>concentration</strong> ou votre attention (travail, lecture...) ? (0=aucun, 10=majeur)</label>
                    <input type="range" id="impact-concentration" name="impact-concentration" min="0" max="10" value="3" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>3</output>

                    <label for="impact-mood" class="mt-m">À quel point affectent-ils votre <strong>humeur</strong> (stress, anxiété, irritabilité, moral) ? (0=aucun, 10=majeur)</label>
                    <input type="range" id="impact-mood" name="impact-mood" min="0" max="10" value="3" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>3</output>

                     <label for="impact-hearing" class="mt-m">À quel point pensez-vous que vos acouphènes interfèrent avec votre capacité à <strong>entendre</strong> les sons extérieurs ? (0=aucun, 10=majeur)</label>
                    <input type="range" id="impact-hearing" name="impact-hearing" min="0" max="10" value="2" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>2</output>
                 </fieldset>

                 <fieldset>
                    <legend>Facteurs d'influence (Optionnel)</legend>
                    <label for="triggers">Y a-t-il des facteurs qui semblent <strong>aggraver</strong> vos acouphènes ? (Ex: Stress, fatigue, bruit fort, silence, caféine, alcool, certains aliments, posture...)</label>
                    <textarea id="triggers" name="triggers" rows="3" placeholder="Notez ici ce qui semble augmenter vos acouphènes"></textarea>

                     <label for="reducers" class="mt-m">Y a-t-il des facteurs qui semblent les <strong>atténuer</strong> ou vous aider à mieux les gérer ? (Ex: Bruit de fond, musique douce, relaxation, activité physique, concentration sur une tâche...)</label>
                    <textarea id="reducers" name="reducers" rows="3" placeholder="Notez ici ce qui semble vous aider"></textarea>
                 </fieldset>

                <div id="evaluation-result" class="mt-l mb-m"></div>

                <button type="submit" class="mt-m">Enregistrer ou Mettre à jour</button>
            </form>
        </section>
    </template>

    <template id="template-hypnose">
        <!-- Modifié pour inclure le toggle TTS -->
        <section class="content-section">
            <h2>Auto-Hypnose Guidée</h2>
            <p>Choisissez une session ci-dessous. Installez-vous confortablement dans un endroit calme. Utilisez des écouteurs si possible.</p>
             <div class="alert alert-info mt-m">
                <strong>Conseil :</strong> Activez la lecture vocale pour pouvoir fermer les yeux et vous laisser guider. La régularité est la clé.
             </div>

            <div id="hypnose-menu" class="mt-l">
                <h3 class="mb-m">Sélectionnez une session :</h3>
                <button class="button mb-m" data-session="debutant">Débutant (env. 10 min)</button>
                <button class="button mb-m" data-session="intermediaire">Intermédiaire (env. 15 min)</button>
                <button class="button mb-m" data-session="avance">Avancé (env. 20 min)</button>
            </div>

            <div id="hypnose-session" class="hidden mt-l">
                <h3 id="session-title" class="mb-m"></h3>
                <div class="timer">--:--</div>
                <p id="session-step-indicator" class="text-center" style="font-style: italic; margin-bottom: var(--spacing-m);"></p>
                <div class="session-text" id="session-text-content">
                    <p>Chargement de la session...</p>
                </div>
                <div class="controls mt-l">
                     <!-- Options Audio -->
                     <div>
                         <label for="hypno-noise">Bruit fond:</label>
                         <select id="hypno-noise">
                             <option value="none">Aucun</option>
                             <option value="white">Bruit Blanc</option>
                             <option value="pink">Bruit Rose</option>
                             <option value="brown">Bruit Brun</option>
                         </select>
                         <label for="hypno-volume" class="ml-m">Volume:</label>
                         <input type="range" id="hypno-volume" min="0" max="0.5" step="0.01" value="0.05">
                     </div>
                     <!-- Option TTS -->
                     <div class="checkbox-group">
                         <input type="checkbox" id="hypno-tts-enable">
                         <label for="hypno-tts-enable">Activer la lecture vocale des instructions</label>
                         <span id="tts-status" class="tts-status"></span> <!-- Pour état support TTS -->
                     </div>
                     <!-- Boutons de contrôle Session -->
                    <div class="mt-l text-center">
                        <button id="start-session-btn" class="button-secondary">Démarrer la session</button>
                        <button id="stop-session-btn" class="button-danger hidden">Arrêter la session</button>
                    </div>
                </div>
            </div>
        </section>
    </template>

    <template id="template-sounds">
        <!-- Contenu de template-sounds (inchangé) -->
         <section class="content-section">
            <h2>Générateur de Sons Thérapeutiques</h2>
            <p>Utilisez ces sons pour créer un environnement sonore plus confortable. Ils peuvent aider à masquer l'acouphène ou à détourner votre attention.</p>
             <div class="alert alert-info mt-m">
                <strong>Conseil :</strong> Expérimentez avec différents types de sons et volumes. L'objectif n'est pas de couvrir complètement l'acouphène, mais de trouver un niveau où il devient moins perceptible ou moins gênant. Un volume juste en dessous ou au niveau de votre acouphène est souvent recommandé (thérapie par le bruit / TRT).
             </div>

            <div class="sound-generator-controls mt-l">
                 <div class="mb-m">
                    <label for="sound-type-select">Type de son :</label>
                     <select id="sound-type-select">
                         <option value="white">Bruit Blanc</option>
                         <option value="pink">Bruit Rose</option>
                         <option value="brown">Bruit Brun</option>
                     </select>
                 </div>

                <div class="mb-m">
                    <label for="sound-volume">Volume :</label>
                    <input type="range" id="sound-volume" min="0" max="0.7" step="0.01" value="0.1"> <output>0.10</output>
                </div>

                 <div class="mb-l">
                    <label for="sound-timer">Minuteur d'arrêt (minutes, 0 = infini) :</label>
                    <input type="number" id="sound-timer" min="0" step="5" value="0" style="width: 100px; display: inline-block; vertical-align: middle;">
                     <span id="sound-timer-status" style="margin-left: var(--spacing-s); vertical-align: middle;"></span>
                 </div>

                <div class="mt-l text-center">
                    <button id="play-sound-btn" class="button">▶️ Jouer</button>
                    <button id="stop-sound-btn" class="button-danger hidden">⏹️ Arrêter</button>
                </div>

            </div>
        </section>
    </template>

    <template id="template-tracking">
        <!-- Contenu de template-tracking (inchangé) -->
         <section class="content-section">
            <h2>Suivi Quotidien de vos Acouphènes</h2>
            <p>Noter régulièrement l'intensité de vos acouphènes et les facteurs associés peut vous aider à identifier des tendances et à mieux comprendre ce qui influence votre perception.</p>

            <form id="tracking-form" class="mb-l">
                 <fieldset>
                     <legend>Ajouter une entrée au journal</legend>
                     <div class="alert alert-info mb-m">Date et heure actuelles seront enregistrées automatiquement.</div>
                    <label for="tracking-intensity">Sur une échelle de 0 (pas d'acouphène audible) à 10 (insupportablement fort), comment évaluez-vous l'intensité de vos acouphènes <strong>en ce moment</strong> ?</label>
                    <input type="range" id="tracking-intensity" name="intensity" min="0" max="10" value="5" step="1" required oninput="this.nextElementSibling.textContent = this.value"> <output>5</output>

                    <label for="tracking-notes" class="mt-m">Notes (optionnel) : Qu'avez-vous remarqué aujourd'hui ? (Ex: Niveau de stress, fatigue, activités, sessions effectuées, humeur, environnement sonore...)</label>
                    <textarea id="tracking-notes" name="notes" rows="4" placeholder="Ex: Journée stressante, acouphènes plus forts. Session de relaxation aidé un peu."></textarea>

                    <button type="submit" class="mt-m">Ajouter au journal</button>
                 </fieldset>
            </form>

            <hr style="margin: var(--spacing-l) 0; border: none; border-top: 1px solid var(--border-color);">

             <fieldset id="tracking-history" class="mb-l">
                <legend>Historique des Entrées</legend>
                 <div class="controls mb-m" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--spacing-m);">
                     <label for="history-limit">Afficher les :</label>
                     <select id="history-limit">
                         <option value="10">10 dernières</option>
                         <option value="30" selected>30 dernières</option>
                         <option value="100">100 dernières</option>
                         <option value="all">Toutes</option>
                     </select>
                 </div>
                <p id="history-loading" class="text-center italic">Chargement de l'historique...</p>
                <ul></ul>
            </fieldset>

             <fieldset id="tracking-chart-container">
                <legend>Graphique d'Évolution de l'Intensité</legend>
                <div class="controls mb-m" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--spacing-m);">
                     <label for="chart-limit">Période :</label>
                     <select id="chart-limit">
                         <option value="7">7 derniers jours</option>
                         <option value="30" selected>30 derniers jours</option>
                         <option value="90">90 derniers jours</option>
                         <option value="all">Tout l'historique</option>
                     </select>
                 </div>
                 <div id="tracking-chart"></div>
                 <div id="chart-no-data" class="chart-no-data hidden">Pas assez de données pour afficher le graphique.</div>
            </fieldset>

             <div class="mt-l text-center">
                 <button id="export-data-btn" class="button-secondary">Exporter (JSON)</button>
                 <button id="export-csv-btn" class="button-secondary">Exporter (CSV)</button>
                 <button id="clear-data-btn" class="button-danger">Supprimer TOUTES les données</button>
             </div>
        </section>
    </template>

    <template id="template-resources">
        <!-- Contenu de template-resources (inchangé) -->
         <section class="content-section">
            <h2>Ressources Éducatives</h2>
            <p>Mieux comprendre les acouphènes et les approches de gestion est une étape importante.</p>
             <div class="alert alert-warning mt-m mb-l">
                 <strong>Rappel :</strong> Les informations fournies ici sont à but éducatif et ne constituent pas un avis médical. Consultez un professionnel de la santé pour toute question relative à votre santé.
             </div>

            <article class="mb-l">
                <h3>Qu'est-ce que l'Acouphène ?</h3>
                <p>L'acouphène (ou tinnitus) est la perception d'un son (sifflement, bourdonnement, grésillement, pulsation...) en l'absence de toute source sonore externe correspondante. Ce n'est pas une maladie en soi, mais un symptôme dont les causes peuvent être multiples :</p>
                <ul>
                    <li>Exposition à des bruits forts (ponctuelle ou répétée).</li>
                    <li>Perte auditive liée à l'âge (presbyacousie).</li>
                    <li>Infections de l'oreille, bouchon de cérumen.</li>
                    <li>Maladies (Ménière, otosclérose...).</li>
                    <li>Traumatismes crâniens ou cervicaux.</li>
                    <li>Certains médicaments (ototoxiques).</li>
                    <li>Stress, anxiété, fatigue.</li>
                    <li>Problèmes vasculaires ou neurologiques (plus rares).</li>
                </ul>
                <p>Il est crucial de consulter un médecin ou un ORL pour déterminer la cause potentielle et écarter toute pathologie sous-jacente nécessitant un traitement spécifique.</p>
            </article>

            <article class="mb-l">
                <h3>L'Auto-Hypnose pour la Gestion des Acouphènes</h3>
                <p>L'auto-hypnose est une technique qui permet d'atteindre volontairement un état de conscience modifié, caractérisé par une relaxation profonde et une concentration focalisée. Dans le contexte des acouphènes, elle ne vise pas à "supprimer" le son, mais plutôt à :</p>
                <ul>
                    <li><strong>Réduire le Stress et l'Anxiété :</strong> Le stress est un facteur majeur d'aggravation perçue des acouphènes. L'hypnose aide à activer la réponse de relaxation du corps.</li>
                    <li><strong>Modifier la Perception :</strong> Apprendre à percevoir l'acouphène comme un son neutre, moins intrusif, moins chargé émotionnellement.</li>
                    <li><strong>Détourner l'Attention :</strong> Entraîner le cerveau à se focaliser sur d'autres sensations, pensées ou sons agréables, diminuant ainsi l'attention portée à l'acouphène.</li>
                    <li><strong>Améliorer le Sommeil :</strong> La relaxation induite peut faciliter l'endormissement malgré les acouphènes.</li>
                    <li><strong>Reprendre le Contrôle :</strong> Sentir que l'on dispose d'outils pour gérer l'impact de l'acouphène peut réduire le sentiment d'impuissance.</li>
                </ul>
                <p>La régularité de la pratique est la clé. Les sessions proposées dans cette application, avec lecture vocale optionnelle, sont progressives pour vous guider.</p>
            </article>

             <article class="mb-l">
                <h3>Thérapie par le Son (Sound Therapy)</h3>
                <p>L'utilisation de sons externes (bruit blanc, rose, brun, sons de la nature, musique) est une approche courante. L'objectif peut être :</p>
                <ul>
                    <li><strong>Masquage :</strong> Utiliser un son externe pour couvrir partiellement ou totalement l'acouphène.</li>
                    <li><strong>Distraction :</strong> Fournir un autre son sur lequel se concentrer.</li>
                    <li><strong>Habituation (TRT - Tinnitus Retraining Therapy) :</strong> Utiliser un bruit neutre (souvent du bruit blanc ou rose) à un faible volume, juste en dessous ou au niveau de l'acouphène, pour aider le cerveau à "s'habituer" à l'acouphène et à le considérer comme un son non pertinent. Cela demande du temps et souvent l'accompagnement d'un professionnel.</li>
                </ul>
                 <p>Le générateur de sons de cette application vous permet d'expérimenter avec différents bruits.</p>
             </article>

            <article>
                <h3>Conseils Complémentaires de Gestion</h3>
                <ul>
                    <li><strong>Protégez votre audition :</strong> Évitez l'exposition aux bruits forts sans protection (bouchons d'oreilles, casque anti-bruit).</li>
                    <li><strong>Gérez votre stress :</strong> Intégrez des activités relaxantes dans votre quotidien (méditation, yoga, marche dans la nature, hobbies...).</li>
                    <li><strong>Soignez votre sommeil :</strong> Couchez-vous et levez-vous à heures régulières, créez un environnement propice au sommeil (calme, sombre, frais). Un léger bruit de fond peut aider.</li>
                    <li><strong>Activité physique :</strong> L'exercice régulier aide à réduire le stress et améliore la circulation sanguine.</li>
                    <li><strong>Alimentation :</strong> Bien qu'il n'y ait pas de régime "anti-acouphènes" universel, une alimentation équilibrée est bénéfique. Certaines personnes notent une influence de la caféine, de l'alcool, du sel ou de certains additifs. Tenez un journal si vous suspectez un lien.</li>
                    <li><strong>Évitez le silence complet :</strong> Le silence peut rendre l'acouphène plus perceptible. Un fond sonore léger (radio douce, fontaine d'intérieur, application de sons) peut être utile, surtout la nuit.</li>
                     <li><strong>Restez informé mais pas obsédé :</strong> Comprendre l'acouphène est utile, mais passer des heures à chercher des informations en ligne peut augmenter l'anxiété.</li>
                     <li><strong>Cherchez du soutien :</strong> Parlez-en à vos proches, ou rejoignez des groupes de soutien (associations de patients comme France Acouphènes).</li>
                </ul>
            </article>

             <article class="mt-l">
                 <h3>FAQ (Foire Aux Questions)</h3>
                 <p><strong>Q: Cette application peut-elle guérir mes acouphènes ?</strong><br> R: Non. Acouphènes Zen est conçu comme un outil pour vous aider à gérer les symptômes et l'impact des acouphènes sur votre vie quotidienne. Il ne s'agit pas d'un traitement curatif. La guérison dépend de la cause sous-jacente, qui doit être évaluée par un professionnel.</p>
                 <p class="mt-m"><strong>Q: L'auto-hypnose est-elle sûre ?</strong><br> R: Oui, l'auto-hypnose est généralement considérée comme une technique sûre lorsqu'elle est utilisée pour la relaxation et la gestion du stress. Vous restez conscient et en contrôle. N'utilisez pas l'application en conduisant ou en effectuant des tâches nécessitant votre pleine attention.</p>
                 <p class="mt-m"><strong>Q: La lecture vocale fonctionne-t-elle sur tous les navigateurs ?</strong><br> R: La synthèse vocale (Text-to-Speech) est une fonctionnalité standard des navigateurs modernes (Chrome, Firefox, Safari, Edge). Cependant, la qualité des voix disponibles et leur disponibilité peuvent varier selon votre navigateur et votre système d'exploitation. Si l'option est grisée ou ne fonctionne pas, votre navigateur ne la supporte peut-être pas complètement.</p>
                 <p class="mt-m"><strong>Q: Quel bruit (blanc, rose, brun) est le meilleur ?</strong><br> R: Il n'y a pas de "meilleur" bruit universel. Cela dépend des préférences personnelles et des caractéristiques de votre acouphène.
                    <ul>
                        <li>Le <strong>bruit blanc</strong> contient toutes les fréquences à égale intensité, il peut être perçu comme plus "sifflant".</li>
                        <li>Le <strong>bruit rose</strong> a plus d'énergie dans les basses fréquences (son plus grave, comme une cascade ou une pluie forte), souvent perçu comme plus doux.</li>
                        <li>Le <strong>bruit brun</strong> a encore plus d'énergie dans les basses fréquences (son très grave, comme un grondement lointain ou un torrent), perçu comme le plus "profond".</li>
                    </ul>
                    Expérimentez pour voir ce qui vous convient le mieux.
                 </p>
                 <p class="mt-m"><strong>Q: Mes données sont-elles sécurisées ?</strong><br> R: Toutes les données que vous entrez (évaluation, journal) sont stockées <strong>exclusivement</strong> dans le stockage local de votre navigateur sur votre appareil. Elles ne sont jamais envoyées à un serveur externe. Vous pouvez les supprimer à tout moment via la section "Suivi".</p>
             </article>
        </section>
    </template>


    <!-- --- JavaScript Intégré --- -->
    <script>
        // Attend que le DOM soit complètement chargé
        document.addEventListener('DOMContentLoaded', () => {

            console.log("Acouphènes Zen App Initializing v1.0...");

            // --- MODULE: Utilitaires Globaux ---
            const Utils = (() => {
                // Fonction simple pour échapper le HTML
                function escapeHtml(unsafe) {
                    if (typeof unsafe !== 'string') return unsafe;
                    return unsafe
                         .replace(/&/g, "&amp;")
                         .replace(/</g, "&lt;")
                         .replace(/>/g, "&gt;")
                         .replace(/"/g, "&quot;")
                         .replace(/'/g, "&#039;");
                 }

                 // Fonction pour formater le temps en mm:ss
                 function formatTime(seconds) {
                    if (isNaN(seconds) || seconds < 0) return "--:--";
                    const mins = Math.floor(seconds / 60);
                    const secs = Math.floor(seconds % 60);
                    return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
                 }

                 // Fonction pour mettre à jour dynamiquement le padding du body
                 function updateBodyPadding() {
                    const nav = document.getElementById('main-nav');
                    if (nav) {
                        const navHeight = nav.offsetHeight;
                        // Ajouter un petit buffer pour être sûr
                        const buffer = 5;
                        document.body.style.paddingTop = `${navHeight + buffer}px`;
                        // Mettre à jour la variable CSS pour que d'autres éléments puissent l'utiliser
                        document.documentElement.style.setProperty('--nav-height', `${navHeight + buffer}px`);
                        // console.log("Body padding updated:", navHeight + buffer);
                    }
                 }

                 // Fonction Debounce (pour optimiser l'appel sur resize)
                 function debounce(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                 };


                 return {
                    escapeHtml,
                    formatTime,
                    updateBodyPadding,
                    debounce
                 };
            })();


            // --- MODULE: État Global & Stockage Local ---
            const Store = (() => {
                const STORAGE_KEY = 'acouphenesZenData_v1.1'; // Clé versionnée (incrémentée pour pref TTS)
                const MAX_JOURNAL_ENTRIES = 365;

                let state = {
                    userProfile: {
                        initialAssessment: null,
                        preferences: {
                             theme: 'light',
                             hypnoTtsEnabled: false // Nouvelle préférence pour TTS
                        }
                    },
                    sessions: [], // { timestamp: ISOString, sessionKey: string, duration: number, completed: boolean }
                    journal: [],  // { date: ISOString, intensity: number, notes: string }
                    lastActive: null
                };

                function load() {
                    const storedData = localStorage.getItem(STORAGE_KEY);
                    if (storedData) {
                        try {
                            const parsedData = JSON.parse(storedData);
                            // Fusionner prudemment, en gardant les valeurs par défaut si manquant
                            const defaultPrefs = { theme: 'light', hypnoTtsEnabled: false };
                            state = {
                                userProfile: {
                                    initialAssessment: parsedData.userProfile?.initialAssessment || null,
                                    preferences: {
                                        ...defaultPrefs,
                                        ...(parsedData.userProfile?.preferences || {})
                                     }
                                },
                                sessions: Array.isArray(parsedData.sessions) ? parsedData.sessions : [],
                                journal: Array.isArray(parsedData.journal) ? parsedData.journal : [],
                                lastActive: parsedData.lastActive || null
                            };
                            state.journal.sort((a, b) => new Date(a.date) - new Date(b.date));
                            console.log('Données chargées depuis localStorage.');
                        } catch (e) {
                            console.error("Erreur lors du chargement depuis localStorage:", e);
                        }
                    } else {
                         console.log('Aucune donnée locale trouvée, état initial.');
                    }
                    applyThemePreference();
                }

                function save() {
                    state.lastActive = new Date().toISOString();
                    try {
                        state.journal.sort((a, b) => new Date(a.date) - new Date(b.date));
                        if (state.journal.length > MAX_JOURNAL_ENTRIES) {
                            state.journal = state.journal.slice(state.journal.length - MAX_JOURNAL_ENTRIES);
                        }
                        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                    } catch (e) {
                        console.error("Erreur lors de la sauvegarde dans localStorage:", e);
                        UI.showToast("Erreur sauvegarde données.", "error");
                    }
                }

                function getState() {
                    return JSON.parse(JSON.stringify(state));
                }

                function updateProfile(profileData) { state.userProfile.initialAssessment = profileData; save(); }
                function addJournalEntry(entry) {
                     if (typeof entry.intensity === 'undefined' || entry.intensity === null) return null;
                     entry.date = new Date().toISOString();
                     entry.notes = (entry.notes || "").trim();
                     state.journal.push(entry);
                     save();
                     return entry;
                 }
                function getJournalEntries(limit = null) {
                     const sortedJournal = [...state.journal].sort((a, b) => new Date(b.date) - new Date(a.date));
                     if (limit && typeof limit === 'number' && limit > 0) { return sortedJournal.slice(0, limit); }
                     return sortedJournal;
                 }
                function addSessionLog(logData) { logData.timestamp = new Date().toISOString(); state.sessions.push(logData); save(); }
                function updateThemePreference(theme) { state.userProfile.preferences.theme = theme; save(); }
                function getThemePreference() { return (state.userProfile.preferences.theme === 'dark') ? 'dark' : 'light'; }
                // Fonctions pour la préférence TTS
                function setTtsPreference(enabled) { state.userProfile.preferences.hypnoTtsEnabled = !!enabled; save(); }
                function getTtsPreference() { return !!state.userProfile.preferences.hypnoTtsEnabled; }

                function clearAllData() {
                     if (confirm("ATTENTION !\n\nÊtes-vous absolument sûr de vouloir supprimer TOUTES vos données (évaluation, journal, historique des sessions, préférences) ?\n\nCette action est IRRÉVERSIBLE.")) {
                        localStorage.removeItem(STORAGE_KEY);
                        const currentTheme = getThemePreference(); // Garder le thème actuel
                        const currentTtsPref = getTtsPreference(); // Garder la pref TTS actuelle
                        state = {
                            userProfile: { initialAssessment: null, preferences: { theme: currentTheme, hypnoTtsEnabled: currentTtsPref } },
                            sessions: [], journal: [], lastActive: null
                        };
                        save(); // Sauver l'état réinitialisé (avec prefs conservées)
                        console.log("Toutes les données utilisateur (sauf préférences) ont été supprimées.");
                        window.location.hash = '#home';
                        window.location.reload();
                        return true;
                    }
                    return false;
                 }

                 function applyThemePreference() {
                     const theme = getThemePreference();
                     document.body.classList.toggle('dark-mode', theme === 'dark');
                     const toggleButton = document.getElementById('theme-toggle');
                     if (toggleButton) {
                        toggleButton.textContent = theme === 'dark' ? '☀️' : '🌙';
                        toggleButton.title = `Passer au thème ${theme === 'dark' ? 'clair' : 'sombre'}`;
                     }
                 }
                 load(); // Charger au démarrage

                return { getState, updateProfile, addJournalEntry, getJournalEntries, addSessionLog, updateThemePreference, getThemePreference, applyThemePreference, setTtsPreference, getTtsPreference, clearAllData };
            })();

            // --- MODULE: UI (Manipulation du DOM & Feedback) ---
            // --- MODULE: UI (Manipulation du DOM & Feedback) ---
            const UI = (() => {
                const uiElements = { mainContent: document.getElementById('main-content'), navLinks: document.querySelectorAll('#main-nav a[href^="#"]') };
                function renderTemplate(templateId, context = {}) { const template = document.getElementById(templateId); if (!template) { console.error(`Template ${templateId} non trouvé`); uiElements.mainContent.innerHTML = `<section class="content-section"><p class="alert alert-danger">Erreur contenu page.</p></section>`; setActiveNavLink(''); return null; } try { const content = template.content.cloneNode(true); uiElements.mainContent.innerHTML = ''; uiElements.mainContent.appendChild(content); setActiveNavLink(templateId.replace('template-', '')); window.scrollTo({ top: 0, behavior: 'smooth' }); return uiElements.mainContent.firstChild; } catch (error) { console.error(`Erreur rendu ${templateId}:`, error); uiElements.mainContent.innerHTML = `<section class="content-section"><p class="alert alert-danger">Erreur affichage section.</p></section>`; setActiveNavLink(''); return null; } }
                function setActiveNavLink(hash) { uiElements.navLinks.forEach(link => { link.classList.remove('active'); if (link.getAttribute('href') === `#${hash}`) link.classList.add('active'); }); }
                function displayEvaluationResult(score, message) { const resultDiv = document.getElementById('evaluation-result'); if (resultDiv) { let alertClass = 'alert-success'; if (score >= 25) alertClass = 'alert-danger'; else if (score >= 15) alertClass = 'alert-warning'; resultDiv.innerHTML = `<div class="alert ${alertClass}"><strong>Résultat :</strong> ${Utils.escapeHtml(message)} (Score d'impact: ${score})</div>`; resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } }
                function renderJournalEntry(entry) { const li = document.createElement('li'); const entryDate = new Date(entry.date); const formattedDateTime = entryDate.toLocaleString('fr-FR', { dateStyle: 'short', timeStyle: 'short' }); li.innerHTML = `<strong>${formattedDateTime}</strong> - Intensité: <span style="font-weight: bold; color: var(--primary-color);">${entry.intensity}/10</span> ${entry.notes ? `<br><em>${Utils.escapeHtml(entry.notes)}</em>` : ''}`; return li; }
                function displayJournalHistory(entries) { const historyList = document.querySelector('#tracking-history ul'); const loadingMsg = document.getElementById('history-loading'); if (!historyList || !loadingMsg) return; historyList.innerHTML = ''; if (!entries || entries.length === 0) { loadingMsg.textContent = "Journal vide."; loadingMsg.style.display = 'block'; } else { loadingMsg.style.display = 'none'; entries.forEach(entry => { const li = renderJournalEntry(entry); if (li) historyList.appendChild(li); }); } }
                function showToast(message, type = 'info', duration = 3000) { const toast = document.createElement('div'); toast.className = `toast toast-${type}`; toast.textContent = message; document.body.appendChild(toast); requestAnimationFrame(() => { toast.classList.add('show'); }); setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => { if (toast.parentNode) toast.parentNode.removeChild(toast); }, { once: true }); }, duration); }
                return { renderTemplate, setActiveNavLink, displayEvaluationResult, displayJournalHistory, showToast };
             })();

            // --- MODULE: Audio (Web Audio API) - Correction Bruit Blanc v3 ---
            const AudioManager = (() => {
                let audioContext; let masterGainNode; let currentNoiseSource = null; let currentFilterNode = null; let currentNoiseType = null; let noiseTimer = null;
                function getContext() { if (!audioContext) { try { window.AudioContext = window.AudioContext || window.webkitAudioContext; if (!window.AudioContext) throw new Error("Web Audio API non supportée"); audioContext = new AudioContext(); masterGainNode = audioContext.createGain(); masterGainNode.connect(audioContext.destination); console.log("AudioContext créé."); } catch(e) { console.error("Erreur AudioContext:", e); UI.showToast("Audio non supporté.", "error"); return null; } } if (audioContext.state === 'suspended') audioContext.resume().catch(err => console.error("Erreur reprise:", err)); return audioContext; }
                function initContextOnInteraction() { const initAudio = () => { const context = getContext(); if (context && context.state === 'running') { console.log("Audio activé."); document.body.removeEventListener('click', initAudio, { capture: true }); document.body.removeEventListener('touchstart', initAudio, { capture: true }); document.body.removeEventListener('keydown', initAudio, { capture: true }); } else if (context) { console.warn(`AudioContext interaction state: ${context.state}`); } }; console.log("Ajout listeners init audio."); document.body.addEventListener('click', initAudio, { once: true, capture: true }); document.body.addEventListener('touchstart', initAudio, { once: true, capture: true }); document.body.addEventListener('keydown', initAudio, { once: true, capture: true }); }
                function createWhiteNoiseSource(context) { console.log("[createWhiteNoiseSource] Début"); const bufferSize = context.sampleRate * 2; const buffer = context.createBuffer(1, bufferSize, context.sampleRate); const output = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1; const source = context.createBufferSource(); source.buffer = buffer; source.loop = true; console.log("[createWhiteNoiseSource] Source créée:", source); return source; }
                function createPinkFilter(context) { console.log("[createPinkFilter] Début"); const filter = context.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(800, context.currentTime); filter.Q.setValueAtTime(0.707, context.currentTime); console.log("[createPinkFilter] Filtre créé:", filter); return filter; }
                function createBrownFilter(context) { console.log("[createBrownFilter] Début"); const filter = context.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(300, context.currentTime); filter.Q.setValueAtTime(1, context.currentTime); console.log("[createBrownFilter] Filtre créé:", filter); return filter; }

                function playNoise(type, volume, durationMinutes = 0) {
                    console.log(`[playNoise] Début - Type: ${type}, Vol: ${volume}`);
                    stopNoise(); // Nettoyage IMPÉRATIF avant de commencer
                    const context = getContext();
                    if (!context || context.state !== 'running') {
                        if (context && context.state === 'suspended') { context.resume().then(() => playNoise(type, volume, durationMinutes)).catch(err => { UI.showToast("Activez l'audio (clic?).", "warning"); console.error("[playNoise] Échec reprise:", err); }); }
                        else { UI.showToast("Audio non prêt (cliquez?).", "warning"); console.warn(`Contexte audio: ${context?.state}`); }
                        return false;
                    }

                    console.log(`[playNoise] Contexte OK. Type: ${type}`);
                    try {
                        currentNoiseSource = null; currentFilterNode = null; // Reset
                        currentNoiseType = type;

                        const whiteSource = createWhiteNoiseSource(context);
                        currentNoiseSource = whiteSource; // Assigner à la variable globale

                        let nodeToConnect = whiteSource; // Par défaut: connexion directe

                        if (type === 'pink') {
                            console.log("[playNoise] Création et connexion filtre ROSE");
                            currentFilterNode = createPinkFilter(context);
                            whiteSource.connect(currentFilterNode); nodeToConnect = currentFilterNode;
                        } else if (type === 'brown') {
                            console.log("[playNoise] Création et connexion filtre BRUN");
                            currentFilterNode = createBrownFilter(context);
                            whiteSource.connect(currentFilterNode); nodeToConnect = currentFilterNode;
                        } else { console.log("[playNoise] Type BLANC, connexion directe Source -> Gain"); }

                        console.log(`[playNoise] Connexion de ${nodeToConnect.constructor.name} au masterGain...`);
                        nodeToConnect.connect(masterGainNode);
                        console.log("[playNoise] Connexion au masterGain OK.");

                        setVolume(volume);
                        console.log(`[playNoise] Démarrage source (${currentNoiseSource.constructor.name})...`);
                        currentNoiseSource.start(0);
                        console.log(`[playNoise] Bruit ${type} démarré avec succès.`);

                        if (durationMinutes > 0) { const s = durationMinutes * 60; console.log(`[playNoise] Timer: ${durationMinutes} min.`); noiseTimer = setTimeout(() => { console.log("Timer atteint."); stopNoise(); UI.showToast("Son arrêté (timer).", "info"); document.dispatchEvent(new CustomEvent('audiotimerend')); }, s * 1000); document.dispatchEvent(new CustomEvent('audiotimerstart', { detail: { durationMinutes } })); } else { document.dispatchEvent(new CustomEvent('audiotimerclear')); }
                        return true;

                    } catch (error) { console.error(`[playNoise] ERREUR GLOBALE pour ${type}:`, error); UI.showToast(`Erreur lecture audio (${type}).`, "error"); stopNoise(); return false; }
                }

                function stopNoise() {
                    console.log(`[stopNoise] Arrêt demandé pour type ${currentNoiseType}...`);
                    if (noiseTimer) { clearTimeout(noiseTimer); noiseTimer = null; document.dispatchEvent(new CustomEvent('audiotimerclear')); console.log("[stopNoise] Timer annulé."); }
                    let stoppedSomething = false;
                    if (currentFilterNode) { try { console.log("[stopNoise] Déconnexion Filtre -> MasterGain"); currentFilterNode.disconnect(masterGainNode); } catch(e) {console.warn("[stopNoise] Erreur déco filtre:", e)} }
                    if (currentNoiseSource) { try { console.log("[stopNoise] Arrêt et déconnexion Source..."); currentNoiseSource.stop(0); currentNoiseSource.disconnect(); stoppedSomething = true; console.log("[stopNoise] Source arrêtée et déconnectée."); } catch (e) { console.warn("[stopNoise] Erreur arrêt/déco source:", e) } }
                    if(stoppedSomething) console.log(`[stopNoise] Bruit ${currentNoiseType} arrêté.`);
                    currentNoiseSource = null; currentFilterNode = null; currentNoiseType = null; return stoppedSomething;
                }

                function setVolume(volume) { volume = Math.max(0, Math.min(1, volume)); if (masterGainNode && audioContext) masterGainNode.gain.setTargetAtTime(volume, audioContext.currentTime, 0.015); }
                function isPlaying() { return !!currentNoiseSource; }
                return { initContextOnInteraction, playNoise, stopNoise, setVolume, isPlaying, getContext };
             })();

            // --- MODULE: Synthèse Vocale (TTS) ---
			const TTSManager = (() => {
				let synthesis = window.speechSynthesis;
				let isSupported = false;
				let currentUtterance = null;
				let isCurrentlySpeakingInternal = false; // Notre propre état

				function init() {
					if ('speechSynthesis' in window) {
						isSupported = true;
						console.log("TTS supporté.");
						try { synthesis.getVoices(); } catch(e) { console.warn("Erreur accès voices:", e); }
						if (synthesis.onvoiceschanged !== undefined) synthesis.onvoiceschanged = () => console.log("Voix TTS màj.");
					} else {
						console.warn("TTS non supporté.");
					}
				}

				function speak(text) {
					const audioCtx = AudioManager.getContext();
					// ... (vérification contexte audio comme avant) ...
					if (!isSupported || !text) { console.warn("TTS speak ignoré: non supporté ou vide"); return false; }

					// On utilise notre état interne pour voir si on doit cancel
					if (isCurrentlySpeakingInternal) {
						 cancel(); // Annule si notre état dit qu'on parle encore
					}

					currentUtterance = new SpeechSynthesisUtterance(text);
					// ... (configuration voix, lang, pitch, rate comme avant) ...

					currentUtterance.onstart = () => { // Utiliser onstart si disponible
						console.log("TTS: onstart event");
						isCurrentlySpeakingInternal = true;
					};

					currentUtterance.onend = () => {
						console.log("TTS: onend event");
						isCurrentlySpeakingInternal = false;
						currentUtterance = null;
						 // Optionnel: Déclencher un événement pour signifier la fin
						 // document.dispatchEvent(new CustomEvent('ttssegmentend'));
					};

					currentUtterance.onerror = (e) => {
						console.error('Erreur TTS:', e.error);
						UI.showToast("Erreur lecture vocale.", "error");
						isCurrentlySpeakingInternal = false; // S'assurer que l'état est false en cas d'erreur
						currentUtterance = null;
					};

					try {
						// Mise à jour état AVANT speak, au cas où 'onstart' ne se déclencherait pas vite
						// isCurrentlySpeakingInternal = true; // Peut-être redondant avec onstart mais plus sûr ? Testons SANS d'abord.
						synthesis.speak(currentUtterance);
						console.log("TTS: synthesis.speak() appelé.");
						// ATTENTION: 'speaking' peut ne pas être vrai immédiatement ici.
						// On se fie maintenant à nos callbacks onstart/onend/onerror
						return true;
					}
					catch (e) {
						console.error("Erreur synthesis.speak:", e);
						UI.showToast("Impossible démarrer lecture.", "error");
						isCurrentlySpeakingInternal = false; // Reset état si échec
						return false;
					}
				 }

				function cancel() {
					if (synthesis && (synthesis.speaking || synthesis.pending || isCurrentlySpeakingInternal)) { // Vérifier plusieurs états
						console.log("TTS: cancel() demandé.");
						synthesis.cancel(); // Appel API
						isCurrentlySpeakingInternal = false; // Forcer notre état interne à false
						currentUtterance = null; // Nettoyer référence
					}
				}

				// Notre fonction d'état interne
				function isSpeaking() {
					// On pourrait retourner :
					// return isCurrentlySpeakingInternal; // Option 1: Se fier uniquement à notre état
					// return synthesis.speaking; // Option 2: Utiliser l'état natif (ce qui était fait avant)
					// Option 3: Combiner? Peut-être trop complexe.
					// Essayons Option 1: Se fier à notre état géré par les événements.
					return isCurrentlySpeakingInternal;
				}

				init();
				return { isSupported: () => isSupported, speak, cancel, isSpeaking };
			})();

            // --- Déclaration Globale des Handlers ---
            const pageHandlers = {}; // Déclarer l'objet ici

            // --- MODULE: Routage ---
            const Router = (() => {
                let currentPageInitFunction = null; let currentPageCleanupFunction = null;
                // Pas besoin de 'pageHandlers' ici, il est global

                function handleRouteChange() {
                    const hash = window.location.hash || '#home'; let route = hash.substring(1);
                    console.log(`Routing: Current hash is ${hash}`);
                    if (typeof currentPageCleanupFunction === 'function') { try { currentPageCleanupFunction(); console.log(`Cleanup OK for previous page`); } catch (e) { console.error(`Erreur cleanup:`, e); } }
                    currentPageCleanupFunction = null; currentPageInitFunction = null;
                    if (AudioManager.isPlaying()) AudioManager.stopNoise(); if (TTSManager.isSpeaking()) TTSManager.cancel();
                    const templateId = `template-${route}`; if (!document.getElementById(templateId)) { route = 'home'; window.location.hash = '#home'; }
                    console.log(`Navigating to: ${route}`);
                    const renderedElement = UI.renderTemplate(`template-${route}`);
                    if (renderedElement) {
                        switch (route) {
                            case 'evaluation': currentPageInitFunction = initEvaluationPage; currentPageCleanupFunction = cleanupEvaluationPage; break;
                            case 'hypnose': currentPageInitFunction = initHypnosePage; currentPageCleanupFunction = cleanupHypnosePage; break;
                            case 'sounds': currentPageInitFunction = initSoundsPage; currentPageCleanupFunction = cleanupSoundsPage; break;
                            case 'tracking': currentPageInitFunction = initTrackingPage; currentPageCleanupFunction = cleanupTrackingPage; break;
                            case 'resources': currentPageInitFunction = initResourcesPage; currentPageCleanupFunction = cleanupResourcesPage; break;
                            case 'home': default: currentPageInitFunction = initHomePage; currentPageCleanupFunction = cleanupHomePage; break;
                        }
                        if (typeof currentPageInitFunction === 'function') { try { currentPageInitFunction(); console.log(`Init ${route} OK.`); } catch(e) { console.error(`Erreur init ${route}:`, e); UI.showToast(`Erreur chargement ${route}.`, "error"); } }
                        else { console.warn(`No init function found for route: ${route}`); }
                    }
                 }
                function init() { window.addEventListener('hashchange', handleRouteChange); AudioManager.initContextOnInteraction(); initThemeToggle(); Utils.updateBodyPadding(); window.addEventListener('resize', Utils.debounce(Utils.updateBodyPadding, 150)); handleRouteChange(); }
                // Retourner UNIQUEMENT init
                return { init };
            })();

            // --- Fonctions d'initialisation et de nettoyage spécifiques aux pages ---

            function initHomePage() { console.log("Init Home"); }
            function cleanupHomePage() { console.log("Cleanup Home"); }

            function initEvaluationPage() {
                console.log("Init Evaluation"); const form = document.getElementById('evaluation-form'); const resultDiv = document.getElementById('evaluation-result'); const savedProfile = Store.getState().userProfile.initialAssessment; if (form && savedProfile) { Object.keys(savedProfile).forEach(key => { const input = form.elements[key]; if (input) { if (input.type === 'radio') form.querySelectorAll(`input[name="${key}"]`).forEach(radio => { radio.checked = (radio.value === savedProfile[key]); }); else if (input.type === 'range') { input.value = savedProfile[key]; if (input.nextElementSibling?.tagName === 'OUTPUT') input.nextElementSibling.textContent = input.value; } else if (input.tagName === 'SELECT') input.value = savedProfile[key]; else input.value = savedProfile[key]; } }); resultDiv.innerHTML = `<div class="alert alert-info">Infos chargées.</div>`; } else if (resultDiv) resultDiv.innerHTML = '';
                pageHandlers.evaluationSubmit = handleEvaluationSubmit; // Utilise pageHandlers global
                form?.addEventListener('submit', pageHandlers.evaluationSubmit);
             }
            function handleEvaluationSubmit(e) { e.preventDefault(); const form = e.target; const formData = new FormData(form); const data = {}; let score = 0; const impactKeys = ['intensity-avg', 'impact-sleep', 'impact-concentration', 'impact-mood', 'impact-hearing']; formData.forEach((value, key) => { data[key] = Utils.escapeHtml(value.trim()); if (impactKeys.includes(key)) score += parseInt(value, 10) || 0; }); console.log('Eval:', data, 'Score:', score); Store.updateProfile(data); let msg = "Éval enregistrée. "; if (score >= 25) msg += "Impact significatif."; else if (score >= 15) msg += "Impact modéré."; else msg += "Impact léger."; UI.displayEvaluationResult(score, msg); UI.showToast("Éval enregistrée !", "success"); }
            function cleanupEvaluationPage() { const form = document.getElementById('evaluation-form'); if(form && pageHandlers.evaluationSubmit) form.removeEventListener('submit', pageHandlers.evaluationSubmit); delete pageHandlers.evaluationSubmit; console.log("Cleanup Éval"); }

            // Page d'Auto-Hypnose
             let hypnoTimerInterval = null; let hypnoSessionEndTime = 0; let hypnoCurrentSessionData = null;
             let hypnoNoiseType = 'none'; let hypnoVolume = 0.05; let hypnoSessionCompleted = false; let hypnoTtsEnabled = false;
             const sessionsData = {
                debutant: { title: "Débutant (env. 10 min) - Relaxation et Prise de Conscience", duration: 600, script: [ { time: 0, text: "Commencez par trouver une position confortable, assise ou allongée, où vous ne serez pas dérangé. Fermez doucement les yeux ou fixez un point devant vous sans effort." }, { time: 20, text: "Prenez maintenant trois respirations profondes et calmes. Inspirez par le nez en gonflant le ventre... et expirez lentement par la bouche, en relâchant les tensions..." }, { time: 45, text: "Répétez encore deux fois à votre rythme... Sentez votre corps commencer à se détendre à chaque expiration..." }, { time: 75, text: "Portez maintenant votre attention sur les sensations de votre corps. Ressentez le contact de vos pieds avec le sol ou le support... le poids de votre corps..." }, { time: 120, text: "Scannez mentalement votre corps, des pieds à la tête. Remarquez simplement les sensations, sans jugement. S'il y a des tensions, imaginez qu'elles se relâchent à chaque expiration..." }, { time: 180, text: "Portez maintenant votre attention sur votre respiration naturelle. Observez le va-et-vient de l'air, sans chercher à la contrôler... C'est votre point d'ancrage dans le moment présent..." }, { time: 240, text: "Les pensées peuvent venir, c'est normal. Laissez-les passer comme des nuages dans le ciel, sans vous y accrocher, et revenez doucement à la sensation de votre respiration..." }, { time: 300, text: "Maintenant, portez une attention douce et curieuse aux sons autour de vous... Ceux de la pièce... ceux de l'extérieur... Accueillez-les sans jugement..." }, { time: 360, text: "Remarquez aussi la présence de votre acouphène, s'il est là. Essayez de le percevoir comme un son parmi d'autres, sans lui donner plus d'importance. Juste une sensation sonore..." }, { time: 420, text: "Imaginez que vous pouvez créer un espace mental autour de ce son. Il est là, mais il y a aussi de l'espace, du calme autour..." }, { time: 480, text: "Revenez à la sensation globale de votre corps détendu... Appréciez ce moment de calme intérieur..." }, { time: 540, text: "Sachez que vous pouvez retrouver cet état de calme quand vous le souhaitez. C'est une capacité en vous." }, { time: 570, text: "Dans quelques instants, cette session va se terminer. Commencez à reprendre conscience de votre environnement... Bougez doucement les doigts, les orteils..." }, { time: 590, text: "Quand vous serez prêt, à votre rythme, ouvrez les yeux en gardant avec vous cette sensation de calme. Étirez-vous si vous le souhaitez." } ] },
                 intermediaire: { title: "Intermédiaire (env. 15 min) - Détournement de l'Attention", duration: 900, script: [ { time: 0, text: "Installez-vous confortablement, fermez les yeux. Prenez quelques respirations profondes pour signaler à votre corps qu'il peut se détendre." }, { time: 30, text: "Imaginez une lumière douce et apaisante au sommet de votre tête. Sentez sa chaleur et sa détente descendre lentement... sur votre front... vos yeux... vos mâchoires qui se desserrent..." }, { time: 60, text: "Cette vague de détente descend dans votre cou, vos épaules... le long de vos bras jusqu'au bout de vos doigts... Sentez la lourdeur agréable de la relaxation..." }, { time: 120, text: "Elle continue dans votre poitrine, votre ventre... votre dos se relâche... Sentez votre respiration devenir plus calme, plus profonde..." }, { time: 180, text: "La détente atteint vos jambes... vos genoux... vos mollets... jusqu'à vos pieds. Tout votre corps est maintenant agréablement lourd et détendu." }, { time: 240, text: "Maintenant, portez votre attention sur votre ouïe. Écoutez les sons autour de vous... sans les analyser, juste les percevoir..." }, { time: 300, text: "Peut-être entendez-vous votre acouphène. Accueillez-le un instant, sans jugement. Puis, choisissez consciemment de porter votre attention ailleurs." }, { time: 360, text: "Imaginez que vous êtes dans un endroit que vous aimez, un lieu paisible. Une plage, une forêt, un jardin... Visualisez cet endroit avec le plus de détails possible." }, { time: 420, text: "Quelles sont les couleurs ? Les formes ? Y a-t-il une odeur particulière ? Une brise légère sur votre peau ?" }, { time: 480, text: "Quels sont les sons agréables de cet endroit ? Le bruit des vagues ? Le chant des oiseaux ? Le vent dans les feuilles ? Concentrez-vous sur ces sons imaginaires apaisants." }, { time: 540, text: "Si votre attention revient à l'acouphène, c'est normal. Remarquez-le simplement, puis redirigez doucement mais fermement votre attention vers les sons agréables de votre lieu paisible." }, { time: 660, text: "Imaginez que vous pouvez ajuster le volume des sons. Augmentez le volume des sons agréables... et diminuez mentalement le volume de l'acouphène, le rendant plus lointain, moins pertinent." }, { time: 780, text: "Restez dans cet état d'absorption agréable, en vous concentrant sur les sensations positives de votre lieu de calme." }, { time: 840, text: "Sachez que votre capacité à diriger votre attention est une compétence puissante que vous pouvez entraîner." }, { time: 870, text: "Préparez-vous maintenant à revenir. Ramenez progressivement votre conscience à votre corps, à la pièce où vous êtes. Prenez une respiration plus profonde." }, { time: 890, text: "Bougez doucement, étirez-vous, et ouvrez les yeux quand vous êtes prêt, en emportant avec vous le calme et la capacité à choisir votre focus." } ] },
                 avance: { title: "Avancé (env. 20 min) - Modification de la Perception", duration: 1200, script: [ { time: 0, text: "Installez-vous confortablement. Fermez les yeux et prenez quelques instants pour entrer dans un état de relaxation profonde, en utilisant la technique qui vous convient le mieux (respiration, scan corporel...)." }, { time: 60, text: "Une fois bien détendu, portez votre attention sur votre acouphène. Observez-le avec une curiosité détachée, comme un scientifique observe un phénomène." }, { time: 120, text: "Quelles sont ses caractéristiques ? Est-il aigu, grave ? Continu, pulsatile ? Est-il stable ou changeant ? Essayez de le décrire mentalement, sans jugement de valeur ('gênant', 'horrible')." }, { time: 180, text: "Imaginez maintenant que vous avez des 'cadrans de contrôle' mentaux pour ce son." }, { time: 240, text: "Visualisez un cadran pour le volume. Imaginez que vous tournez ce cadran très lentement vers le bas. Même si le son réel ne change pas, notez toute modification dans votre perception ou votre réaction émotionnelle." }, { time: 330, text: "Visualisez un cadran pour la 'tonalité' ou la 'qualité' du son. Imaginez que vous pouvez le rendre légèrement plus grave, ou plus doux, ou plus diffus. Jouez mentalement avec ces caractéristiques." }, { time: 420, text: "Imaginez un cadran pour la 'localisation'. Pouvez-vous mentalement déplacer le son ? Le rendre plus externe, plus lointain ? Le laisser flotter hors de votre tête ?" }, { time: 510, text: "Visualisez un cadran pour l''émotion' associée au son. Imaginez tourner ce cadran de 'gêne' ou 'anxiété' vers 'neutre' ou même 'acceptation'." }, { time: 600, text: "Maintenant, laissez les cadrans et portez votre attention sur une sensation agréable dans votre corps. Peut-être la chaleur de vos mains, la détente de vos épaules, ou le calme de votre respiration." }, { time: 690, text: "Amplifiez cette sensation agréable. Laissez-la grandir et se diffuser dans tout votre corps, créant un sentiment général de bien-être." }, { time: 780, text: "Imaginez que ce bien-être est comme une bulle protectrice autour de vous. L'acouphène peut être là, à l'extérieur ou à l'intérieur de la bulle, mais il ne perturbe pas le calme à l'intérieur." }, { time: 900, text: "L'acouphène est juste un son. Il n'a que le pouvoir que vous lui donnez. Vous apprenez à lui retirer ce pouvoir émotionnel." }, { time: 1020, text: "Ancrez cette sensation de contrôle et de calme en vous. Prenez une profonde inspiration et expirez lentement." }, { time: 1140, text: "Rappelez-vous que cette capacité à modifier votre perception s'affine avec la pratique régulière." }, { time: 1170, text: "Commencez maintenant à revenir progressivement à votre état de conscience habituel. Sentez l'énergie revenir dans votre corps. Bougez les doigts, les orteils." }, { time: 1190, text: "Quand vous êtes prêt, ouvrez les yeux, en gardant ce sentiment de perspective et de calme intérieur renouvelé." } ] }
             };

            // Fonction updateHypnoTimer MISE A JOUR v2

            // Variable externe (à réinitialiser dans start/stop)
            let lastSpokenText = null;

            function updateHypnoTimer() {
                const now = Date.now();
                // Vérifier si hypnoCurrentSessionData existe toujours (sécurité post-arrêt)
                 if (!hypnoCurrentSessionData) {
                     if (hypnoTimerInterval) clearInterval(hypnoTimerInterval);
                     return;
                 }

                const remaining = Math.max(0, (hypnoSessionEndTime - now) / 1000);

                // --- RÉCUPÉRATION DES ÉLÉMENTS DOM ICI ---
                const timerDisplay = document.querySelector('#hypnose-session .timer');
                const textContent = document.getElementById('session-text-content');
                const stepIndicator = document.getElementById('session-step-indicator');
                // --- FIN RÉCUPÉRATION ---

                 // Vérifier si les éléments existent avant de les utiliser
                 if (!timerDisplay || !textContent || !stepIndicator) {
                     console.warn("[updateHypnoTimer] Missing required DOM elements.");
                     if (hypnoTimerInterval) clearInterval(hypnoTimerInterval); // Arrêter si l'UI est cassée
                     return;
                 }

                timerDisplay.textContent = Utils.formatTime(remaining);

                const elapsed = hypnoCurrentSessionData.duration - remaining;

                // --- CALCUL DE currentStep ICI ---
                const currentStepIndex = hypnoCurrentSessionData.script.slice().reverse().findIndex(step => elapsed >= step.time);
                const currentStep = currentStepIndex !== -1 ? hypnoCurrentSessionData.script[hypnoCurrentSessionData.script.length - 1 - currentStepIndex] : null;
                // --- FIN CALCUL ---

                if (currentStep) {
                    const currentTextElement = textContent.querySelector('p');
                    const displayedTextEscaped = currentTextElement ? currentTextElement.dataset.rawText : null;
                    const currentStepTextRaw = currentStep.text;
                    const currentStepTextEscaped = Utils.escapeHtml(currentStepTextRaw);

                    // Update display if needed
                    if (!displayedTextEscaped || displayedTextEscaped !== currentStepTextEscaped) {
                        textContent.innerHTML = `<p data-raw-text="${currentStepTextEscaped}">${currentStepTextEscaped}</p>`;
                        textContent.scrollTop = textContent.scrollHeight; // Scroll auto
                        console.log(`[updateHypnoTimer] Affichage mis à jour pour: "${currentStepTextRaw.substring(0,30)}..."`);
                    }

                    // --- Speech Logic Simplifiée ---
                    if (hypnoTtsEnabled && TTSManager.isSupported() && currentStepTextRaw !== lastSpokenText) {
                        console.log(`[updateHypnoTimer] Nouvelle étape texte détectée ("${currentStepTextRaw.substring(0, 30)}..."). Tentative lecture (speak gère cancel).`);
                        const spoken = TTSManager.speak(currentStepTextRaw); // speak() interne gère cancel() si isCurrentlySpeakingInternal est true
                        if (spoken) {
                            lastSpokenText = currentStepTextRaw;
                            console.log(`[updateHypnoTimer] Marqué "${currentStepTextRaw.substring(0, 30)}..." comme dernier texte demandé.`);
                        } else {
                            console.warn("[updateHypnoTimer] TTSManager.speak a échoué, ne met pas à jour lastSpokenText.");
                            // Si speak échoue, peut-être réinitialiser lastSpokenText pour permettre une nouvelle tentative ?
                            // lastSpokenText = null; // A tester si nécessaire
                        }
                    }

                    // --- Update step indicator ---
                    const totalSteps = hypnoCurrentSessionData.script.length;
                    const currentStepNumber = hypnoCurrentSessionData.script.length - currentStepIndex;
                    stepIndicator.textContent = `Étape ${currentStepNumber} / ${totalSteps}`;

                } else {
                    // Pas d'étape courante trouvée (peut arriver au tout début ou en cas d'erreur)
                    stepIndicator.textContent = 'Chargement étape...';
                }

                // --- Handle session end ---
                if (remaining <= 0 && hypnoTimerInterval) {
                     console.log("Hypno timer 0 détecté dans updateHypnoTimer.");
                     hypnoSessionCompleted = true;
                     stopHypnoSession(); // Arrête le timer via clearInterval dans stopHypnoSession
                 }
            }			

			
            function startHypnoSession(sessionKey) {
				lastSpokenText = null;
                console.log(`Starting session: ${sessionKey}`);
                hypnoCurrentSessionData = sessionsData[sessionKey]; if (!hypnoCurrentSessionData) { UI.showToast("Erreur session.", "error"); return; }
                const menu = document.getElementById('hypnose-menu'); const sessionView = document.getElementById('hypnose-session'); const startBtn = document.getElementById('start-session-btn'); const stopBtn = document.getElementById('stop-session-btn'); const timerDisplay = sessionView?.querySelector('.timer'); const sessionTextContent = document.getElementById('session-text-content'); const stepIndicator = document.getElementById('session-step-indicator'); const noiseSelect = document.getElementById('hypno-noise'); const volumeSlider = document.getElementById('hypno-volume'); const ttsToggle = document.getElementById('hypno-tts-enable');
                hypnoNoiseType = noiseSelect.value; hypnoVolume = parseFloat(volumeSlider.value); hypnoTtsEnabled = ttsToggle.checked;
                hypnoSessionCompleted = false;
                const firstStepText = hypnoCurrentSessionData.script[0]?.text || 'Préparation...';
                const firstStepTextEscaped = Utils.escapeHtml(firstStepText);
                sessionTextContent.innerHTML = `<p data-raw-text="${firstStepTextEscaped}">${firstStepTextEscaped}</p>`;
                stepIndicator.textContent = `Étape 1 / ${hypnoCurrentSessionData.script.length}`; timerDisplay.textContent = Utils.formatTime(hypnoCurrentSessionData.duration);
                menu.classList.add('hidden'); sessionView.classList.remove('hidden'); startBtn.classList.add('hidden'); stopBtn.classList.remove('hidden'); noiseSelect.disabled = true; volumeSlider.disabled = true; ttsToggle.disabled = true;
                console.log(`Audio: ${hypnoNoiseType} vol ${hypnoVolume}. TTS: ${hypnoTtsEnabled}`);
                if (hypnoNoiseType !== 'none' && hypnoVolume > 0) { const audioStarted = AudioManager.playNoise(hypnoNoiseType, hypnoVolume); if (!audioStarted) UI.showToast("Problème audio.", "warning"); } else AudioManager.stopNoise();
                if (hypnoTtsEnabled && TTSManager.isSupported() && hypnoCurrentSessionData.script[0]) { console.log("TTS speaking first step..."); TTSManager.speak(firstStepText); } // Speak raw text
                hypnoSessionEndTime = Date.now() + hypnoCurrentSessionData.duration * 1000;
                updateHypnoTimer(); if(hypnoTimerInterval) clearInterval(hypnoTimerInterval);
                hypnoTimerInterval = setInterval(updateHypnoTimer, 500);
                UI.showToast(`Session démarrée.`, "info");
            }

            function stopHypnoSession() {
                lastSpokenText = null
				console.log("Stopping hypno session."); const sessionEndedNaturally = hypnoSessionCompleted; if(hypnoTimerInterval) clearInterval(hypnoTimerInterval); hypnoTimerInterval = null; AudioManager.stopNoise(); TTSManager.cancel();
                if (hypnoCurrentSessionData) { const sessionKey = Object.keys(sessionsData).find(key => sessionsData[key] === hypnoCurrentSessionData); if(sessionKey) { Store.addSessionLog({ sessionKey, duration: hypnoCurrentSessionData.duration, completed: sessionEndedNaturally }); console.log(`Session log: ${sessionEndedNaturally ? 'complète' : 'arrêtée'}`); } else { console.error("Could not find session key for logging.");} }
                const menu = document.getElementById('hypnose-menu'); const sessionView = document.getElementById('hypnose-session'); const startBtn = document.getElementById('start-session-btn'); const stopBtn = document.getElementById('stop-session-btn'); const noiseSelect = document.getElementById('hypno-noise'); const volumeSlider = document.getElementById('hypno-volume'); const ttsToggle = document.getElementById('hypno-tts-enable');
                if (sessionView) sessionView.classList.add('hidden'); if (menu) menu.classList.remove('hidden'); if (stopBtn) stopBtn.classList.add('hidden'); if (startBtn) { startBtn.classList.remove('hidden'); startBtn.textContent = "Sélectionnez une session"; startBtn.disabled = true; startBtn.onclick = null; }
                if (noiseSelect) noiseSelect.disabled = false; if (volumeSlider) volumeSlider.disabled = false; if (ttsToggle) ttsToggle.disabled = !TTSManager.isSupported();
                if (sessionEndedNaturally) UI.showToast("Session terminée !", "success"); else UI.showToast("Session arrêtée.", "warning");
                hypnoCurrentSessionData = null; hypnoSessionCompleted = false;
            }

            function initHypnosePage() {
                console.log("[Init Hypnose Page] Démarrage..."); const menu = document.getElementById('hypnose-menu'); const sessionView = document.getElementById('hypnose-session'); const startBtn = document.getElementById('start-session-btn'); const stopBtn = document.getElementById('stop-session-btn'); const ttsToggle = document.getElementById('hypno-tts-enable'); const ttsStatus = document.getElementById('tts-status');
                if (menu) menu.classList.remove('hidden'); if (sessionView) sessionView.classList.add('hidden'); if (startBtn) { startBtn.textContent = "Sélectionnez une session"; startBtn.disabled = true; startBtn.classList.remove('hidden'); startBtn.onclick = null; } if (stopBtn) stopBtn.classList.add('hidden');
                if (ttsToggle && ttsStatus) { const isTtsSupported = TTSManager.isSupported(); ttsToggle.disabled = !isTtsSupported; ttsStatus.textContent = isTtsSupported ? '' : '(Lecture vocale non supportée)'; if (isTtsSupported) { ttsToggle.checked = Store.getTtsPreference(); pageHandlers.ttsToggleChange = handleTtsToggleChange; ttsToggle.removeEventListener('change', pageHandlers.ttsToggleChange); ttsToggle.addEventListener('change', pageHandlers.ttsToggleChange); console.log("[Init Hypnose Page] Listener TTS attaché."); } else { ttsToggle.checked = false; } } else { console.warn("[Init Hypnose Page] Éléments TTS introuvables."); }
                pageHandlers.hypnoMenuClick = handleHypnoMenuClick; pageHandlers.hypnoStopClick = stopHypnoSession;
                menu?.removeEventListener('click', pageHandlers.hypnoMenuClick); menu?.addEventListener('click', pageHandlers.hypnoMenuClick);
                stopBtn?.removeEventListener('click', pageHandlers.hypnoStopClick); stopBtn?.addEventListener('click', pageHandlers.hypnoStopClick);
                console.log("[Init Hypnose Page] Initialisation terminée, listeners attachés.");
            }

            function handleHypnoMenuClick(e) {
                 console.log("Menu click target:", e.target); if (e.target.tagName === 'BUTTON' && e.target.dataset.session) { const sessionKey = e.target.dataset.session; console.log(`Session selected: ${sessionKey}`); const sessionData = sessionsData[sessionKey]; if (!sessionData) { console.error("Session data not found!"); return; } const startBtn = document.getElementById('start-session-btn'); const sessionTitle = document.getElementById('session-title'); const sessionView = document.getElementById('hypnose-session'); const timerDisplay = sessionView?.querySelector('.timer'); const sessionTextContent = document.getElementById('session-text-content'); const stepIndicator = document.getElementById('session-step-indicator'); const ttsToggle = document.getElementById('hypno-tts-enable'); const noiseSelect = document.getElementById('hypno-noise'); const volumeSlider = document.getElementById('hypno-volume');
                 if (sessionTitle) sessionTitle.textContent = sessionData.title + " (Prêt)"; if (timerDisplay) timerDisplay.textContent = Utils.formatTime(sessionData.duration); if (sessionTextContent) sessionTextContent.innerHTML = `<p>Préparez-vous. Cliquez sur "Démarrer".</p>`; if (stepIndicator) stepIndicator.textContent = `Durée: ${Math.round(sessionData.duration / 60)} min`;
                 if (startBtn) { startBtn.textContent = `Démarrer la session`; startBtn.onclick = () => { console.log(`[Start Button onclick] Démarrage pour session: ${sessionKey}`); startHypnoSession(sessionKey); }; startBtn.disabled = false; console.log("Start btn prepared."); } else { console.error("Start button not found in DOM!"); }
                 if (sessionView) sessionView.classList.remove('hidden'); document.getElementById('stop-session-btn')?.classList.add('hidden');
                 if (noiseSelect) noiseSelect.disabled = false; if (volumeSlider) volumeSlider.disabled = false; if (ttsToggle) ttsToggle.disabled = !TTSManager.isSupported();
                 sessionView?.scrollIntoView({ behavior: 'smooth', block: 'start' }); } else { /* console.log("Clicked non-session button in menu."); */ }
            }
            function handleTtsToggleChange(e) { const isEnabled = e.target.checked; Store.setTtsPreference(isEnabled); console.log("Pref TTS sauvegardée:", isEnabled); }
            function cleanupHypnosePage() {
                 console.log("[Cleanup Hypnose Page] Démarrage..."); if (hypnoTimerInterval) stopHypnoSession();
                 const menu = document.getElementById('hypnose-menu'); const stopBtn = document.getElementById('stop-session-btn'); const ttsToggle = document.getElementById('hypno-tts-enable'); const startBtn = document.getElementById('start-session-btn');
                 if(menu && pageHandlers.hypnoMenuClick) { menu.removeEventListener('click', pageHandlers.hypnoMenuClick); console.log("[Cleanup Hypnose Page] Listener menu retiré."); }
                 if(stopBtn && pageHandlers.hypnoStopClick) { stopBtn.removeEventListener('click', pageHandlers.hypnoStopClick); console.log("[Cleanup Hypnose Page] Listener stop retiré."); }
                 if(ttsToggle && pageHandlers.ttsToggleChange) { ttsToggle.removeEventListener('change', pageHandlers.ttsToggleChange); console.log("[Cleanup Hypnose Page] Listener TTS retiré."); }
                 if(startBtn) startBtn.onclick = null;
                 delete pageHandlers.hypnoMenuClick; delete pageHandlers.hypnoStopClick; delete pageHandlers.ttsToggleChange;
                 console.log("[Cleanup Hypnose Page] Nettoyage terminé.");
            }

            // --- FIN Fonctions spécifiques Auto-Hypnose ---
            // --- FIN Fonctions spécifiques Auto-Hypnose ---
            // --- Page Générateur de Sons ---
            let soundTimerInterval_page = null; let soundTimerEndTime_page = 0;
            function updateSoundTimerDisplay_page() { const statusSpan = document.getElementById('sound-timer-status'); if (!statusSpan || !AudioManager.isPlaying() || !noiseTimer) { if (statusSpan) statusSpan.textContent = ''; clearInterval(soundTimerInterval_page); soundTimerInterval_page = null; return; } const now = Date.now(); const remainingSeconds = Math.max(0, Math.round((soundTimerEndTime_page - now) / 1000)); if (remainingSeconds > 0) statusSpan.textContent = `Arrêt dans: ${Utils.formatTime(remainingSeconds)}`; else { statusSpan.textContent = ''; clearInterval(soundTimerInterval_page); soundTimerInterval_page = null; } }

            function initSoundsPage() {
                console.log("Init Sounds");
                const playBtn = document.getElementById('play-sound-btn');
                const stopBtn = document.getElementById('stop-sound-btn');
                const volumeSlider = document.getElementById('sound-volume');
                const volumeOutput = volumeSlider?.nextElementSibling;
                const updateVolumeOutputDisplay = () => { if (volumeSlider && volumeOutput) volumeOutput.textContent = parseFloat(volumeSlider.value).toFixed(2); };

                // Stocker les handlers dans l'objet global pageHandlers
                pageHandlers.soundPlay = handlePlaySound_page;
                pageHandlers.soundStop = handleStopSound_page;
                pageHandlers.soundVolumeInput = handleSoundVolumeInput_page;
                pageHandlers.soundVolumeChange = handleSoundVolumeChange_page;
                pageHandlers.audioTimerStart = handleAudioTimerStart_page;
                pageHandlers.audioTimerEnd = handleAudioTimerEnd_page;
                pageHandlers.audioTimerClear = handleAudioTimerClear_page;

                // Nettoyer les listeners précédents au cas où (sécurité)
                playBtn?.removeEventListener('click', pageHandlers.soundPlay);
                stopBtn?.removeEventListener('click', pageHandlers.soundStop);
                volumeSlider?.removeEventListener('input', pageHandlers.soundVolumeInput);
                volumeSlider?.removeEventListener('change', pageHandlers.soundVolumeChange);
                document.removeEventListener('audiotimerstart', pageHandlers.audioTimerStart);
                document.removeEventListener('audiotimerend', pageHandlers.audioTimerEnd);
                document.removeEventListener('audiotimerclear', pageHandlers.audioTimerClear);

                // Attacher les nouveaux listeners
                playBtn?.addEventListener('click', pageHandlers.soundPlay);
                stopBtn?.addEventListener('click', pageHandlers.soundStop);
                volumeSlider?.addEventListener('input', pageHandlers.soundVolumeInput);
                volumeSlider?.addEventListener('change', pageHandlers.soundVolumeChange);
                document.addEventListener('audiotimerstart', pageHandlers.audioTimerStart);
                document.addEventListener('audiotimerend', pageHandlers.audioTimerEnd);
                document.addEventListener('audiotimerclear', pageHandlers.audioTimerClear);

                updateVolumeOutputDisplay();
                stopBtn?.classList.add('hidden');
                playBtn?.classList.remove('hidden');
                console.log("Sounds page listeners attached.");
             }

            function handlePlaySound_page() { const type = document.getElementById('sound-type-select').value; const volume = parseFloat(document.getElementById('sound-volume').value); const durationMinutes = parseInt(document.getElementById('sound-timer').value, 10) || 0; const success = AudioManager.playNoise(type, volume, durationMinutes); if (success) { document.getElementById('play-sound-btn')?.classList.add('hidden'); document.getElementById('stop-sound-btn')?.classList.remove('hidden'); document.getElementById('sound-type-select').disabled = true; document.getElementById('sound-timer').disabled = true; } }
            function handleStopSound_page() { const stopped = AudioManager.stopNoise(); if (stopped) { document.getElementById('play-sound-btn')?.classList.remove('hidden'); document.getElementById('stop-sound-btn')?.classList.add('hidden'); document.getElementById('sound-type-select').disabled = false; document.getElementById('sound-timer').disabled = false; document.getElementById('sound-timer-status').textContent = ''; if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); soundTimerInterval_page = null; } }
            function handleSoundVolumeInput_page(e) { const volumeOutput = e.target.nextElementSibling; if (volumeOutput) volumeOutput.textContent = parseFloat(e.target.value).toFixed(2); if (AudioManager.isPlaying()) AudioManager.setVolume(parseFloat(e.target.value)); }
            function handleSoundVolumeChange_page(e) { AudioManager.setVolume(parseFloat(e.target.value)); }
            function handleAudioTimerStart_page(e) { const durationMinutes = e.detail.durationMinutes; soundTimerEndTime_page = Date.now() + durationMinutes * 60 * 1000; if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); updateSoundTimerDisplay_page(); soundTimerInterval_page = setInterval(updateSoundTimerDisplay_page, 1000); }
            function handleAudioTimerEnd_page() { handleStopSound_page(); } // Appelle la fonction qui gère l'UI
            function handleAudioTimerClear_page() { if (soundTimerInterval_page) clearInterval(soundTimerInterval_page); soundTimerInterval_page = null; const statusSpan = document.getElementById('sound-timer-status'); if (statusSpan) statusSpan.textContent = ''; }

            function cleanupSoundsPage() {
                 console.log("Cleanup Sounds");
                 if (AudioManager.isPlaying()) handleStopSound_page(); // Arrête le son et nettoie l'UI associée
                 const playBtn = document.getElementById('play-sound-btn');
                 const stopBtn = document.getElementById('stop-sound-btn');
                 const volumeSlider = document.getElementById('sound-volume');

                 // Retirer les listeners en utilisant les références stockées dans pageHandlers
                 if(pageHandlers.soundPlay) playBtn?.removeEventListener('click', pageHandlers.soundPlay);
                 if(pageHandlers.soundStop) stopBtn?.removeEventListener('click', pageHandlers.soundStop);
                 if(pageHandlers.soundVolumeInput) volumeSlider?.removeEventListener('input', pageHandlers.soundVolumeInput);
                 if(pageHandlers.soundVolumeChange) volumeSlider?.removeEventListener('change', pageHandlers.soundVolumeChange);
                 if(pageHandlers.audioTimerStart) document.removeEventListener('audiotimerstart', pageHandlers.audioTimerStart);
                 if(pageHandlers.audioTimerEnd) document.removeEventListener('audiotimerend', pageHandlers.audioTimerEnd);
                 if(pageHandlers.audioTimerClear) document.removeEventListener('audiotimerclear', pageHandlers.audioTimerClear);

                 // Supprimer les références stockées
                 delete pageHandlers.soundPlay; delete pageHandlers.soundStop; delete pageHandlers.soundVolumeInput; delete pageHandlers.soundVolumeChange; delete pageHandlers.audioTimerStart; delete pageHandlers.audioTimerEnd; delete pageHandlers.audioTimerClear;

                 // Assurer que le timer d'affichage est arrêté
                 if (soundTimerInterval_page) clearInterval(soundTimerInterval_page);
                 soundTimerInterval_page = null;
                 console.log("Sounds page listeners removed.");
             }

            // --- Page Suivi ---
            function initTrackingPage() {
                console.log("Init Tracking");
                const form = document.getElementById('tracking-form'); const clearDataBtn = document.getElementById('clear-data-btn'); const exportJsonBtn = document.getElementById('export-data-btn'); const exportCsvBtn = document.getElementById('export-csv-btn'); const historyLimitSelect = document.getElementById('history-limit'); const chartLimitSelect = document.getElementById('chart-limit');

                // Stocker les handlers dans pageHandlers global
                pageHandlers.trackingSubmit = handleTrackingSubmit;
                pageHandlers.clearData = handleClearData;
                pageHandlers.exportJson = handleExportJson;
                pageHandlers.exportCsv = handleExportCsv;
                pageHandlers.updateTracking = updateTrackingDisplay;

                // Nettoyer et attacher les listeners
                form?.removeEventListener('submit', pageHandlers.trackingSubmit);
                clearDataBtn?.removeEventListener('click', pageHandlers.clearData);
                exportJsonBtn?.removeEventListener('click', pageHandlers.exportJson);
                exportCsvBtn?.removeEventListener('click', pageHandlers.exportCsv);
                historyLimitSelect?.removeEventListener('change', pageHandlers.updateTracking);
                chartLimitSelect?.removeEventListener('change', pageHandlers.updateTracking);

                form?.addEventListener('submit', pageHandlers.trackingSubmit);
                clearDataBtn?.addEventListener('click', pageHandlers.clearData);
                exportJsonBtn?.addEventListener('click', pageHandlers.exportJson);
                exportCsvBtn?.addEventListener('click', pageHandlers.exportCsv);
                historyLimitSelect?.addEventListener('change', pageHandlers.updateTracking);
                chartLimitSelect?.addEventListener('change', pageHandlers.updateTracking);

                updateTrackingDisplay(); // Affichage initial
                console.log("Tracking page listeners attached.");
             }

            function updateTrackingDisplay() { const historyLimit = document.getElementById('history-limit')?.value || '30'; const chartLimit = document.getElementById('chart-limit')?.value || '30'; let limitHistoryNum = historyLimit === 'all' ? null : parseInt(historyLimit, 10); let limitChartDays = chartLimit === 'all' ? null : parseInt(chartLimit, 10); const entries = Store.getJournalEntries(limitHistoryNum); UI.displayJournalHistory(entries); const allJournalData = Store.getState().journal; drawIntensityChart(allJournalData, limitChartDays); }
            function handleTrackingSubmit(e) { e.preventDefault(); const form = e.target; const formData = new FormData(form); const newEntry = { intensity: formData.get('intensity'), notes: formData.get('notes') }; const savedEntry = Store.addJournalEntry(newEntry); if (savedEntry) { form.reset(); const intensityRange = document.getElementById('tracking-intensity'); if(intensityRange && intensityRange.nextElementSibling) intensityRange.nextElementSibling.textContent = intensityRange.defaultValue; UI.showToast('Entrée ajoutée.', 'success'); updateTrackingDisplay(); } else { UI.showToast("Erreur ajout entrée.", 'error'); } }
            function handleClearData() { Store.clearAllData(); }
            function handleExportJson() { try { const data = Store.getState(); const dataStr = JSON.stringify(data, null, 2); const blob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `acouphenes_zen_data_${new Date().toISOString().split('T')[0]}.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); UI.showToast("Export JSON OK.", "success"); } catch (e) { console.error("Erreur export JSON:", e); UI.showToast("Erreur export JSON.", "error"); } }
            function handleExportCsv() { try { const journal = Store.getState().journal; if (!journal || journal.length === 0) { UI.showToast("Journal vide.", "warning"); return; } const header = "DateHeureISO;Intensite;Notes\n"; const rows = journal.map(entry => { const date = entry.date; const intensity = entry.intensity; let notes = entry.notes || ""; if (notes.includes('"') || notes.includes(';') || notes.includes('\n')) { notes = `"${notes.replace(/"/g, '""')}"`; } return `${date};${intensity};${notes}`; }); const csvContent = header + rows.join("\n"); const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `acouphenes_zen_journal_${new Date().toISOString().split('T')[0]}.csv`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); UI.showToast("Export CSV OK.", "success"); } catch (e) { console.error("Erreur export CSV:", e); UI.showToast("Erreur export CSV.", "error"); } }
            function drawIntensityChart(data, limitDays) { const container = document.getElementById('tracking-chart'); const noDataMsg = document.getElementById('chart-no-data'); if (!container || !noDataMsg) return; container.innerHTML = ''; noDataMsg.classList.add('hidden'); let filteredData = data; if (limitDays !== null && limitDays > 0) { const limitDate = new Date(); limitDate.setDate(limitDate.getDate() - limitDays); filteredData = data.filter(entry => new Date(entry.date) >= limitDate); } if (filteredData.length < 2) { noDataMsg.classList.remove('hidden'); return; } filteredData.sort((a, b) => new Date(a.date) - new Date(b.date)); const svgNS = "http://www.w3.org/2000/svg"; const svg = document.createElementNS(svgNS, "svg"); const containerRect = container.getBoundingClientRect(); const svgWidth = containerRect.width || 600; const svgHeight = 250; const margin = { top: 20, right: 30, bottom: 40, left: 40 }; const width = svgWidth - margin.left - margin.right; const height = svgHeight - margin.top - margin.bottom; svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`); svg.setAttribute("preserveAspectRatio", "xMidYMid meet"); svg.style.width = "100%"; svg.style.height = `${svgHeight}px`; const g = document.createElementNS(svgNS, "g"); g.setAttribute("transform", `translate(${margin.left},${margin.top})`); svg.appendChild(g); const firstDate = new Date(filteredData[0].date); const lastDate = new Date(filteredData[filteredData.length - 1].date); const totalTimeDiff = lastDate.getTime() - firstDate.getTime(); const xScale = (date) => { if (totalTimeDiff === 0) return 0; const timeDiff = new Date(date).getTime() - firstDate.getTime(); return (timeDiff / totalTimeDiff) * width; }; const yScale = (intensity) => height - (intensity / 10) * height; const yAxis = document.createElementNS(svgNS, "line"); yAxis.setAttribute("x1", 0); yAxis.setAttribute("y1", 0); yAxis.setAttribute("x2", 0); yAxis.setAttribute("y2", height); yAxis.setAttribute("class", "chart-axis"); g.appendChild(yAxis); [0, 5, 10].forEach(val => { const y = yScale(val); const label = document.createElementNS(svgNS, "text"); label.setAttribute("x", -margin.left / 2); label.setAttribute("y", y); label.setAttribute("dy", "0.32em"); label.setAttribute("class", "chart-text axis-label-y"); label.textContent = val; g.appendChild(label); const gridLine = document.createElementNS(svgNS, "line"); gridLine.setAttribute("x1", 0); gridLine.setAttribute("y1", y); gridLine.setAttribute("x2", width); gridLine.setAttribute("y2", y); gridLine.setAttribute("class", "chart-grid"); g.appendChild(gridLine); }); const xAxis = document.createElementNS(svgNS, "line"); xAxis.setAttribute("x1", 0); xAxis.setAttribute("y1", height); xAxis.setAttribute("x2", width); xAxis.setAttribute("y2", height); xAxis.setAttribute("class", "chart-axis"); g.appendChild(xAxis); const formatDateLabel = (date) => date.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit'}); [firstDate, lastDate].forEach((date, index) => { if(!date) return; const x = index === 0 ? 0 : width; const label = document.createElementNS(svgNS, "text"); label.setAttribute("x", x); label.setAttribute("y", height + margin.bottom / 2); label.setAttribute("dy", "0.71em"); label.setAttribute("class", "chart-text axis-label-x"); if (index === 1 && filteredData.length > 1) label.style.textAnchor = "end"; else label.style.textAnchor = "start"; label.textContent = formatDateLabel(date); g.appendChild(label); }); const linePath = document.createElementNS(svgNS, "path"); const pathData = filteredData.map((d, i) => { const x = xScale(d.date); const y = yScale(d.intensity); return `${i === 0 ? 'M' : 'L'} ${x.toFixed(2)} ${y.toFixed(2)}`; }).join(" "); linePath.setAttribute("d", pathData); linePath.setAttribute("class", "chart-line"); g.appendChild(linePath); filteredData.forEach(d => { const x = xScale(d.date); const y = yScale(d.intensity); const point = document.createElementNS(svgNS, "circle"); point.setAttribute("cx", x); point.setAttribute("cy", y); point.setAttribute("r", 4); point.setAttribute("class", "chart-point"); const title = document.createElementNS(svgNS, "title"); const pointDate = new Date(d.date); title.textContent = `${pointDate.toLocaleDateString('fr-FR')} ${pointDate.toLocaleTimeString('fr-FR',{hour:'2-digit', minute:'2-digit'})} - Intensité: ${d.intensity}`; point.appendChild(title); g.appendChild(point); }); container.appendChild(svg); }

            function cleanupTrackingPage() {
                 console.log("Cleanup Tracking");
                 const form = document.getElementById('tracking-form'); const clearDataBtn = document.getElementById('clear-data-btn'); const exportJsonBtn = document.getElementById('export-data-btn'); const exportCsvBtn = document.getElementById('export-csv-btn'); const historyLimitSelect = document.getElementById('history-limit'); const chartLimitSelect = document.getElementById('chart-limit');
                 // Retirer les listeners en utilisant pageHandlers global
                 if(pageHandlers.trackingSubmit) form?.removeEventListener('submit', pageHandlers.trackingSubmit);
                 if(pageHandlers.clearData) clearDataBtn?.removeEventListener('click', pageHandlers.clearData);
                 if(pageHandlers.exportJson) exportJsonBtn?.removeEventListener('click', pageHandlers.exportJson);
                 if(pageHandlers.exportCsv) exportCsvBtn?.removeEventListener('click', pageHandlers.exportCsv);
                 if(pageHandlers.updateTracking) { historyLimitSelect?.removeEventListener('change', pageHandlers.updateTracking); chartLimitSelect?.removeEventListener('change', pageHandlers.updateTracking); }
                 // Nettoyer le graphique
                 const container = document.getElementById('tracking-chart'); if (container) container.innerHTML = '';
                 // Supprimer les références stockées
                 delete pageHandlers.trackingSubmit; delete pageHandlers.clearData; delete pageHandlers.exportJson; delete pageHandlers.exportCsv; delete pageHandlers.updateTracking;
                 console.log("Tracking listeners removed.");
             }

            // --- Page Ressources ---
             function initResourcesPage() { console.log("Init Ressources"); /* Rien de spécial à faire ici pour l'instant */ }
             function cleanupResourcesPage() { console.log("Cleanup Ressources"); /* Rien de spécial à faire ici pour l'instant */ }

            // --- Initialisation Générale ---
             function initThemeToggle() { const toggleButton = document.getElementById('theme-toggle'); if (toggleButton) { toggleButton.addEventListener('click', () => { const currentTheme = Store.getThemePreference(); const newTheme = currentTheme === 'dark' ? 'light' : 'dark'; Store.updateThemePreference(newTheme); Store.applyThemePreference(); }); Store.applyThemePreference(); } }

            // --- DÉMARRAGE DE L'APPLICATION ---
            Router.init();
            console.log("Acouphènes Zen App Ready v1.1 Corrected.");

        }); // Fin de DOMContentLoaded
    </script>
</body>
</html>
