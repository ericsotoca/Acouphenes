<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Titre mis à jour pour refléter la finalisation -->
    <title>Acouphènes Zen v1.0 - Gestion & Auto-hypnose</title>
    <style>
        /* --- CSS Intégré --- */

        /* Variables (Thème Clair par défaut) */
        :root {
            --bg-color: #f4f7f9;
            --text-color: #333;
            --primary-color: #4a90e2; /* Bleu doux */
            --secondary-color: #7cb342; /* Vert apaisant */
            --accent-color: #f7b731; /* Jaune doux */
            --card-bg: #ffffff;
            --border-color: #e0e0e0;
            --input-bg: #ffffff;
            --button-text: #ffffff;
            --link-color: #4a90e2;
            --disabled-color: #cccccc;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --danger-color: #e74c3c; /* Rouge pour suppression */

            /* Nouvelle variable pour le padding dynamique */
            --nav-height: 70px; /* Valeur par défaut, sera ajustée par JS */

            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-size-base: 16px;
            --line-height-base: 1.6;

            --spacing-xs: 4px;
            --spacing-s: 8px;
            --spacing-m: 16px;
            --spacing-l: 24px;
            --spacing-xl: 32px;

            --border-radius: 4px;
            --shadow: 0 2px 5px var(--shadow-color);
        }

        /* Thème Sombre */
        body.dark-mode {
            --bg-color: #2c3e50; /* Bleu nuit */
            --text-color: #ecf0f1; /* Blanc cassé */
            --primary-color: #5dade2; /* Bleu plus clair */
            --secondary-color: #82e0aa; /* Vert plus clair */
            --accent-color: #f4d03f; /* Jaune plus clair */
            --card-bg: #34495e; /* Bleu gris foncé */
            --border-color: #4b6584; /* Gris bleu */
            --input-bg: #4b6584;
            --button-text: #2c3e50; /* Texte sombre pour boutons clairs */
            --link-color: #5dade2;
            --disabled-color: #7f8c8d; /* Gris sombre */
            --shadow-color: rgba(0, 0, 0, 0.3);
            --danger-color: #f1948a; /* Rouge plus clair */
        }

        /* Reset et Styles Globaux */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: var(--font-size-base);
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: var(--line-height-base);
            transition: background-color 0.3s ease, color 0.3s ease;
            /* Le padding-top est maintenant défini dynamiquement par JS */
            /* padding-top: var(--nav-height); */
        }

        #app {
            max-width: 900px;
            margin: 0 auto;
            padding: var(--spacing-l);
        }

        /* Navigation */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: var(--card-bg);
            box-shadow: var(--shadow);
            padding: var(--spacing-s) var(--spacing-l);
            z-index: 1000;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            /* Transition pour la hauteur si elle devait changer dynamiquement */
            /* transition: height 0.3s ease; */
        }
         nav .nav-brand {
            font-weight: bold;
            font-size: 1.3em;
            color: var(--primary-color);
            text-decoration: none;
            margin-right: var(--spacing-l);
         }

        nav ul {
            list-style: none;
            display: flex;
            gap: var(--spacing-m);
            flex-wrap: wrap;
             align-items: center;
        }

        nav a {
            text-decoration: none;
            color: var(--link-color);
            font-weight: 500;
            transition: color 0.2s ease, background-color 0.2s ease;
            padding: var(--spacing-s) var(--spacing-m);
            border-radius: var(--border-radius);
        }

        nav a:hover,
        nav a.active {
            color: var(--primary-color);
            background-color: color-mix(in srgb, var(--primary-color) 10%, transparent);
        }

        /* Contenu Principal */
        main {
            /* Pas besoin de padding-top ici, car le body l'a déjà */
            min-height: calc(100vh - var(--nav-height) - 80px); /* Ajuster pour footer */
        }

        .content-section {
            background-color: var(--card-bg);
            padding: var(--spacing-l);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: var(--spacing-l);
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Éléments de Formulaire */
        fieldset {
            border: 1px solid var(--border-color);
            padding: var(--spacing-m);
            border-radius: var(--border-radius);
            margin-bottom: var(--spacing-l); /* Ajout marge en bas */
        }
        legend {
            font-weight: 600;
            padding: 0 var(--spacing-s);
            color: var(--primary-color);
            margin-bottom: var(--spacing-m); /* Ajout marge en bas */
        }
        label {
            display: block;
            margin-bottom: var(--spacing-s);
            font-weight: 500;
        }
        /* Style pour les groupes de radio boutons */
        .radio-group label,
        .checkbox-group label { /* Ajout pour checkbox TTS */
            display: inline-block;
            margin-right: var(--spacing-m);
            font-weight: normal;
            vertical-align: middle;
            cursor: pointer;
        }
        .radio-group input[type="radio"],
        .checkbox-group input[type="checkbox"] { /* Ajout pour checkbox TTS */
            margin-right: var(--spacing-xs);
            vertical-align: middle;
            cursor: pointer;
        }


        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: var(--spacing-s) var(--spacing-m);
            margin-bottom: var(--spacing-m);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: inherit;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

         /* Style pour les sliders */
        input[type="range"] {
            width: calc(100% - 50px); /* Laisser de la place pour l'output */
            vertical-align: middle;
             cursor: pointer;
             margin-bottom: var(--spacing-m); /* Assurer espace en bas */
        }
        output {
            display: inline-block;
            min-width: 30px;
            text-align: right;
            font-weight: bold;
            color: var(--primary-color);
            vertical-align: middle;
            margin-left: var(--spacing-s);
        }

        button,
        .button {
            display: inline-block;
            background-color: var(--primary-color);
            color: var(--button-text);
            border: none;
            padding: var(--spacing-m) var(--spacing-l);
            border-radius: var(--border-radius);
            font-size: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            text-align: center;
            text-decoration: none;
             margin-right: var(--spacing-s); /* Espace entre boutons */
             margin-bottom: var(--spacing-s); /* Espace si wrap */
        }
         button:last-child, .button:last-child {
             margin-right: 0;
         }

        button:hover,
        .button:hover {
            background-color: color-mix(in srgb, var(--primary-color) 90%, black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        button:disabled,
        .button:disabled {
            background-color: var(--disabled-color);
            color: color-mix(in srgb, var(--text-color) 50%, var(--disabled-color));
            cursor: not-allowed;
            box-shadow: none;
        }

        .button-secondary {
            background-color: var(--secondary-color);
        }
         .button-secondary:hover {
            background-color: color-mix(in srgb, var(--secondary-color) 90%, black);
        }
        .button-danger {
            background-color: var(--danger-color);
        }
         .button-danger:hover {
            background-color: color-mix(in srgb, var(--danger-color) 80%, black);
         }

        /* Utilitaires */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .mt-s { margin-top: var(--spacing-s); }
        .mt-m { margin-top: var(--spacing-m); }
        .mt-l { margin-top: var(--spacing-l); }
        .mb-s { margin-bottom: var(--spacing-s); }
        .mb-m { margin-bottom: var(--spacing-m); }
        .mb-l { margin-bottom: var(--spacing-l); }
        .mr-m { margin-right: var(--spacing-m); }
         .alert {
             padding: var(--spacing-m);
             margin-top: var(--spacing-m); /* Ajout espace au dessus */
             margin-bottom: var(--spacing-m);
             border-radius: var(--border-radius);
             border: 1px solid transparent;
         }
         .alert-info {
             color: #0c5460;
             background-color: #d1ecf1;
             border-color: #bee5eb;
         }
         .alert-warning {
            color: #856404;
            background-color: #fff3cd;
            border-color: #ffeeba;
         }
         .alert-success {
            color: #155724;
            background-color: #d4edda;
            border-color: #c3e6cb;
         }
         .alert-danger {
             color: #721c24;
             background-color: #f8d7da;
             border-color: #f5c6cb;
         }
         /* Style pour Toast (Notifications) */
         .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            border-radius: 25px; /* Plus arrondi */
            color: white;
            z-index: 1001;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            opacity: 0;
            transition: opacity 0.5s ease, bottom 0.5s ease;
            font-size: 0.95em;
            text-align: center;
         }
         .toast-info { background-color: #3498db; }
         .toast-success { background-color: #2ecc71; }
         .toast-warning { background-color: #f39c12; color: #333; }
         .toast-error { background-color: #e74c3c; }
         .toast.show {
             opacity: 1;
             bottom: 30px; /* Remonte un peu */
         }


        /* Styles spécifiques aux modules */
        #hypnose-session .timer {
            font-size: 2.5em;
            font-weight: bold;
            text-align: center;
            margin: var(--spacing-l) 0;
            color: var(--secondary-color);
             font-variant-numeric: tabular-nums;
        }
        #hypnose-session .session-text {
            background-color: color-mix(in srgb, var(--bg-color) 95%, var(--text-color));
            padding: var(--spacing-m) var(--spacing-l);
            border-radius: var(--border-radius);
            min-height: 180px;
            border-left: 5px solid var(--primary-color);
            font-size: 1.1em;
            line-height: 1.7;
            overflow-y: auto;
            max-height: 300px;
            margin-bottom: var(--spacing-l); /* Espace avant controles */
        }
        #hypnose-session .controls {
            border-top: 1px solid var(--border-color);
            padding-top: var(--spacing-m);
            text-align: left; /* Aligner les contrôles à gauche */
        }
        #hypnose-session .controls > div { margin-bottom: var(--spacing-m); } /* Espace entre lignes de contrôles */
        #hypnose-session .controls label { display: inline-block; margin-right: var(--spacing-s); min-width: 100px; }
        #hypnose-session .controls input[type="range"] { width: 120px; vertical-align: middle; }
        #hypnose-session .controls select { width: auto; display: inline-block; margin-right: var(--spacing-m); vertical-align: middle; }
        #hypnose-session .controls .checkbox-group { margin-top: var(--spacing-s); } /* Espace pour le toggle TTS */
        #hypnose-session .tts-status { /* Style pour message support TTS */
            font-size: 0.9em;
            font-style: italic;
            margin-left: var(--spacing-s);
            color: var(--disabled-color);
        }

        /* Suivi */
        #tracking-history { margin-bottom: var(--spacing-l); }
        #tracking-history ul {
            list-style: none;
            padding-left: 0;
             max-height: 400px;
             overflow-y: auto;
             border: 1px solid var(--border-color);
             padding: var(--spacing-m);
             border-radius: var(--border-radius);
             margin-top: var(--spacing-s); /* Espace après select */
        }
        #tracking-history li {
            border-bottom: 1px dashed var(--border-color);
            padding: var(--spacing-m) 0;
            margin-bottom: var(--spacing-s);
        }
         #tracking-history li:last-child {
            border-bottom: none;
            margin-bottom: 0;
         }
         #tracking-history strong { color: var(--primary-color); }
         #tracking-history em { color: color-mix(in srgb, var(--text-color) 70%, var(--bg-color));}
         #tracking-history .controls label, #tracking-chart-container .controls label { margin-right: var(--spacing-s); }
         #tracking-history .controls select, #tracking-chart-container .controls select { width: auto; vertical-align: middle; }

         /* Graphique SVG */
        #tracking-chart-container {
            margin-top: var(--spacing-l);
             min-height: 280px; /* Un peu plus haut */
             border: 1px solid var(--border-color);
             border-radius: var(--border-radius);
             padding: var(--spacing-m);
             position: relative;
        }
         #tracking-chart-container svg {
             display: block;
             width: 100%;
             height: 100%;
             min-height: 240px; /* Hauteur min du SVG */
         }
         .chart-line {
            fill: none;
            stroke: var(--secondary-color);
            stroke-width: 2.5px; /* Ligne un peu plus épaisse */
         }
         .chart-point {
            fill: var(--primary-color);
            stroke: var(--card-bg);
            stroke-width: 1.5px;
             cursor: pointer; /* Indiquer cliquable (même si pas d'action) */
             transition: r 0.2s ease;
         }
         .chart-point:hover {
             r: 6; /* Grossir au survol */
         }
         .chart-axis {
            stroke: var(--border-color);
            stroke-width: 1px;
         }
         .chart-grid { /* Style pour les lignes de grille */
             stroke: var(--border-color);
             stroke-width: 1px;
             opacity: 0.3;
             stroke-dasharray: 2,2; /* Pointillés */
         }
         .chart-text {
            font-size: 11px; /* Légèrement plus grand */
            fill: var(--text-color);
            text-anchor: middle;
         }
         .chart-text.axis-label-y { text-anchor: end; }
         .chart-text.axis-label-x { text-anchor: middle; }
         .chart-no-data {
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             color: var(--disabled-color);
             font-style: italic;
         }

         /* Footer */
         footer {
             text-align: center;
             padding: var(--spacing-l); /* Plus d'espace */
             margin-top: var(--spacing-l);
             font-size: 0.9em;
             color: color-mix(in srgb, var(--text-color) 60%, var(--bg-color));
             border-top: 1px solid var(--border-color);
         }


        /* Responsive */
        @media (max-width: 768px) {
            body {
                /* Le padding est géré par JS, pas besoin de le changer ici */
            }
            nav {
                padding: var(--spacing-s) var(--spacing-m);
                justify-content: center;
            }
            nav .nav-brand { margin-bottom: var(--spacing-s); width: 100%; text-align: center; }
            nav ul {
                 gap: var(--spacing-s);
                 justify-content: center;
                 width: 100%;
                 margin-top: var(--spacing-s);
            }
            #app {
                 padding: var(--spacing-m);
            }
            .content-section {
                 padding: var(--spacing-m);
            }
             input[type="range"] { width: calc(100% - 40px); }
             output { min-width: 25px; }
             #hypnose-session .timer { font-size: 2em; }
             #hypnose-session .controls label { min-width: 80px; } /* Réduire largeur min label */
             #hypnose-session .controls input[type="range"] { width: 100px; }
        }
        @media (max-width: 480px) {
            /* Ajustements fins pour très petits écrans */
             nav ul { gap: var(--spacing-xs); }
             nav a { padding: var(--spacing-xs) var(--spacing-s); font-size: 0.9em; }
             button, .button { font-size: 0.95em; padding: var(--spacing-s) var(--spacing-m); }
             .chart-text { font-size: 9px; }
        }

        /* Theme Toggle */
        #theme-toggle {
            cursor: pointer;
            background: none;
            border: none;
            font-size: 1.6em;
            padding: 0 var(--spacing-s);
            color: var(--text-color);
             margin-left: auto; /* Pousse le bouton vers la droite */
             order: 3; /* S'assurer qu'il reste à droite même si nav wrap */
        }
        @media (max-width: 768px) {
            #theme-toggle { margin-left: 0; order: 0; /* Remettre au début ou fin ? */ }
        }

    </style>
</head>
<body>
    <!-- Le contenu de l'app -->
    <div id="app">
        <!-- Navigation (reste identique) -->
        <nav id="main-nav">
             <a href="#home" class="nav-brand">Acouphènes Zen</a>
            <ul>
                <li><a href="#home">Accueil</a></li>
                <li><a href="#evaluation">Évaluation</a></li>
                <li><a href="#hypnose">Auto-Hypnose</a></li>
                <li><a href="#sounds">Sons</a></li>
                <li><a href="#tracking">Suivi</a></li>
                <li><a href="#resources">Ressources</a></li>
            </ul>
             <button id="theme-toggle" title="Changer le thème">☀️</button>
        </nav>

        <!-- Contenu principal -->
        <main id="main-content">
            <!-- Le contenu des templates sera injecté ici -->
        </main>

        <!-- Footer (reste identique) -->
        <footer>
            <p>Acouphènes Zen &copy; 2024 - Outil de gestion non médical.</p>
            <p style="font-size: 0.8em; margin-top: 5px;"><strong>Important:</strong> Cette application ne remplace pas un avis médical. Consultez un professionnel de santé.</p>
        </footer>
    </div>

    <!-- --- Modèles HTML (Contenu interne principalement identique, sauf template-hypnose) --- -->

    <template id="template-home">
        <!-- Contenu de template-home (inchangé par rapport à la version précédente) -->
         <section class="content-section">
            <h1>Bienvenue sur Acouphènes Zen</h1>
            <p class="lead" style="font-size: 1.1em;">Votre compagnon pour mieux comprendre et gérer vos acouphènes au quotidien grâce à l'auto-hypnose et aux sons thérapeutiques.</p>

            <div class="alert alert-warning mt-l mb-l">
                <strong>Avertissement Important :</strong> Acouphènes Zen est un outil d'accompagnement et de gestion. Il n'est pas destiné à diagnostiquer, traiter ou guérir les acouphènes. Consultez <strong>toujours</strong> un médecin ou un spécialiste ORL pour un diagnostic précis et un plan de traitement adapté à votre situation.
            </div>

            <h2 class="mt-l">Comment cette application peut vous aider :</h2>
            <ul>
                <li><strong>Comprendre :</strong> Accédez à des informations claires sur les acouphènes et l'approche par l'auto-hypnose (<a href="#resources">Ressources</a>).</li>
                <li><strong>Évaluer :</strong> Faites une première évaluation de vos acouphènes et de leur impact (<a href="#evaluation">Évaluation</a>).</li>
                <li><strong>Apaiser :</strong> Utilisez des sessions guidées d'auto-hypnose conçues pour la relaxation et la gestion de la perception des acouphènes (<a href="#hypnose">Auto-Hypnose</a>). Celles-ci peuvent maintenant être lues à voix haute !</li>
                <li><strong>Masquer :</strong> Générez des sons thérapeutiques (bruit blanc, rose, brun) pour potentiellement réduire la gêne occasionnée par les acouphènes (<a href="#sounds">Sons</a>).</li>
                <li><strong>Suivre :</strong> Tenez un journal de l'intensité de vos acouphènes et visualisez votre progression (<a href="#tracking">Suivi</a>).</li>
            </ul>

            <h2 class="mt-l">Pour commencer :</h2>
            <p>Nous vous recommandons de commencer par la section <a href="#evaluation">Évaluation</a> pour mieux cerner votre situation. Ensuite, explorez les sessions d'<a href="#hypnose">Auto-Hypnose</a> ou le <a href="#sounds">Générateur de Sons</a>.</p>

            <p class="mt-m" style="font-style: italic;">Toutes vos données sont stockées <strong>uniquement sur votre appareil</strong> (dans le stockage local de votre navigateur) et ne sont jamais envoyées sur un serveur.</p>

            <div class="text-center mt-l">
                <a href="#evaluation" class="button">Commencer l'évaluation</a>
            </div>
        </section>
    </template>

    <template id="template-evaluation">
        <!-- Contenu de template-evaluation (inchangé) -->
         <section class="content-section">
            <h2>Évaluation Initiale des Acouphènes</h2>
            <form id="evaluation-form">
                <p>Ce questionnaire aide à mieux comprendre vos acouphènes et leur impact. Vos réponses sont confidentielles et stockées localement.</p>

                <fieldset class="mb-l">
                    <legend>Caractéristiques des acouphènes</legend>
                    <label for="sound-type">Quel type de son entendez-vous principalement ? (Ex: Sifflement aigu, bourdonnement grave, pulsation, cliquetis...)</label>
                    <input type="text" id="sound-type" name="sound-type" required placeholder="Décrivez le son principal">

                    <label class="mt-m">Le son est-il perçu dans :</label>
                    <div class="radio-group">
                        <input type="radio" id="ear-left" name="ear-location" value="left"> <label for="ear-left">Oreille gauche</label>
                        <input type="radio" id="ear-right" name="ear-location" value="right"> <label for="ear-right">Oreille droite</label>
                        <input type="radio" id="ear-both" name="ear-location" value="both" checked> <label for="ear-both">Les deux oreilles</label>
                        <input type="radio" id="ear-head" name="ear-location" value="head"> <label for="ear-head">Dans la tête</label>
                    </div>

                    <label for="intensity-avg" class="mt-m">Sur une échelle de 0 (pas d'acouphène audible) à 10 (insupportablement fort), quelle est l'intensité <strong>moyenne</strong> de vos acouphènes quand vous y prêtez attention ?</label>
                    <input type="range" id="intensity-avg" name="intensity-avg" min="0" max="10" value="5" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>5</output>

                    <label for="variation" class="mt-m">L'intensité de vos acouphènes varie-t-elle beaucoup au cours de la journée ou des jours ?</label>
                    <select id="variation" name="variation">
                        <option value="peu">Peu ou pas</option>
                        <option value="moderee">Modérément</option>
                        <option value="beaucoup">Beaucoup</option>
                    </select>
                </fieldset>

                 <fieldset class="mb-l">
                     <legend>Impact sur votre quotidien</legend>
                     <label for="impact-sleep">Sur une échelle de 0 (aucun impact) à 10 (impact majeur), à quel point vos acouphènes affectent-ils votre <strong>sommeil</strong> (endormissement, réveils) ?</label>
                    <input type="range" id="impact-sleep" name="impact-sleep" min="0" max="10" value="3" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>3</output>

                     <label for="impact-concentration" class="mt-m">À quel point affectent-ils votre capacité de <strong>concentration</strong> ou votre attention (travail, lecture...) ? (0=aucun, 10=majeur)</label>
                    <input type="range" id="impact-concentration" name="impact-concentration" min="0" max="10" value="3" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>3</output>

                    <label for="impact-mood" class="mt-m">À quel point affectent-ils votre <strong>humeur</strong> (stress, anxiété, irritabilité, moral) ? (0=aucun, 10=majeur)</label>
                    <input type="range" id="impact-mood" name="impact-mood" min="0" max="10" value="3" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>3</output>

                     <label for="impact-hearing" class="mt-m">À quel point pensez-vous que vos acouphènes interfèrent avec votre capacité à <strong>entendre</strong> les sons extérieurs ? (0=aucun, 10=majeur)</label>
                    <input type="range" id="impact-hearing" name="impact-hearing" min="0" max="10" value="2" step="1" oninput="this.nextElementSibling.textContent = this.value"> <output>2</output>
                 </fieldset>

                 <fieldset>
                    <legend>Facteurs d'influence (Optionnel)</legend>
                    <label for="triggers">Y a-t-il des facteurs qui semblent <strong>aggraver</strong> vos acouphènes ? (Ex: Stress, fatigue, bruit fort, silence, caféine, alcool, certains aliments, posture...)</label>
                    <textarea id="triggers" name="triggers" rows="3" placeholder="Notez ici ce qui semble augmenter vos acouphènes"></textarea>

                     <label for="reducers" class="mt-m">Y a-t-il des facteurs qui semblent les <strong>atténuer</strong> ou vous aider à mieux les gérer ? (Ex: Bruit de fond, musique douce, relaxation, activité physique, concentration sur une tâche...)</label>
                    <textarea id="reducers" name="reducers" rows="3" placeholder="Notez ici ce qui semble vous aider"></textarea>
                 </fieldset>

                <div id="evaluation-result" class="mt-l mb-m"></div>

                <button type="submit" class="mt-m">Enregistrer ou Mettre à jour</button>
            </form>
        </section>
    </template>

    <template id="template-hypnose">
        <!-- Modifié pour inclure le toggle TTS -->
        <section class="content-section">
            <h2>Auto-Hypnose Guidée</h2>
            <p>Choisissez une session ci-dessous. Installez-vous confortablement dans un endroit calme. Utilisez des écouteurs si possible.</p>
             <div class="alert alert-info mt-m">
                <strong>Conseil :</strong> Activez la lecture vocale pour pouvoir fermer les yeux et vous laisser guider. La régularité est la clé.
             </div>

            <div id="hypnose-menu" class="mt-l">
                <h3 class="mb-m">Sélectionnez une session :</h3>
                <button class="button mb-m" data-session="debutant">Débutant (env. 10 min)</button>
                <button class="button mb-m" data-session="intermediaire">Intermédiaire (env. 15 min)</button>
                <button class="button mb-m" data-session="avance">Avancé (env. 20 min)</button>
            </div>

            <div id="hypnose-session" class="hidden mt-l">
                <h3 id="session-title" class="mb-m"></h3>
                <div class="timer">--:--</div>
                <p id="session-step-indicator" class="text-center" style="font-style: italic; margin-bottom: var(--spacing-m);"></p>
                <div class="session-text" id="session-text-content">
                    <p>Chargement de la session...</p>
                </div>
                <div class="controls mt-l">
                     <!-- Options Audio -->
                     <div>
                         <label for="hypno-noise">Bruit fond:</label>
                         <select id="hypno-noise">
                             <option value="none">Aucun</option>
                             <option value="white">Bruit Blanc</option>
                             <option value="pink">Bruit Rose</option>
                             <option value="brown">Bruit Brun</option>
                         </select>
                         <label for="hypno-volume" class="ml-m">Volume:</label>
                         <input type="range" id="hypno-volume" min="0" max="0.5" step="0.01" value="0.05">
                     </div>
                     <!-- Option TTS -->
                     <div class="checkbox-group">
                         <input type="checkbox" id="hypno-tts-enable">
                         <label for="hypno-tts-enable">Activer la lecture vocale des instructions</label>
                         <span id="tts-status" class="tts-status"></span> <!-- Pour état support TTS -->
                     </div>
                     <!-- Boutons de contrôle Session -->
                    <div class="mt-l text-center">
                        <button id="start-session-btn" class="button-secondary">Démarrer la session</button>
                        <button id="stop-session-btn" class="button-danger hidden">Arrêter la session</button>
                    </div>
                </div>
            </div>
        </section>
    </template>

    <template id="template-sounds">
        <!-- Contenu de template-sounds (inchangé) -->
         <section class="content-section">
            <h2>Générateur de Sons Thérapeutiques</h2>
            <p>Utilisez ces sons pour créer un environnement sonore plus confortable. Ils peuvent aider à masquer l'acouphène ou à détourner votre attention.</p>
             <div class="alert alert-info mt-m">
                <strong>Conseil :</strong> Expérimentez avec différents types de sons et volumes. L'objectif n'est pas de couvrir complètement l'acouphène, mais de trouver un niveau où il devient moins perceptible ou moins gênant. Un volume juste en dessous ou au niveau de votre acouphène est souvent recommandé (thérapie par le bruit / TRT).
             </div>

            <div class="sound-generator-controls mt-l">
                 <div class="mb-m">
                    <label for="sound-type-select">Type de son :</label>
                     <select id="sound-type-select">
                         <option value="white">Bruit Blanc</option>
                         <option value="pink">Bruit Rose</option>
                         <option value="brown">Bruit Brun</option>
                     </select>
                 </div>

                <div class="mb-m">
                    <label for="sound-volume">Volume :</label>
                    <input type="range" id="sound-volume" min="0" max="0.7" step="0.01" value="0.1"> <output>0.10</output>
                </div>

                 <div class="mb-l">
                    <label for="sound-timer">Minuteur d'arrêt (minutes, 0 = infini) :</label>
                    <input type="number" id="sound-timer" min="0" step="5" value="0" style="width: 100px; display: inline-block; vertical-align: middle;">
                     <span id="sound-timer-status" style="margin-left: var(--spacing-s); vertical-align: middle;"></span>
                 </div>

                <div class="mt-l text-center">
                    <button id="play-sound-btn" class="button">▶️ Jouer</button>
                    <button id="stop-sound-btn" class="button-danger hidden">⏹️ Arrêter</button>
                </div>

            </div>
        </section>
    </template>

    <template id="template-tracking">
        <!-- Contenu de template-tracking (inchangé) -->
         <section class="content-section">
            <h2>Suivi Quotidien de vos Acouphènes</h2>
            <p>Noter régulièrement l'intensité de vos acouphènes et les facteurs associés peut vous aider à identifier des tendances et à mieux comprendre ce qui influence votre perception.</p>

            <form id="tracking-form" class="mb-l">
                 <fieldset>
                     <legend>Ajouter une entrée au journal</legend>
                     <div class="alert alert-info mb-m">Date et heure actuelles seront enregistrées automatiquement.</div>
                    <label for="tracking-intensity">Sur une échelle de 0 (pas d'acouphène audible) à 10 (insupportablement fort), comment évaluez-vous l'intensité de vos acouphènes <strong>en ce moment</strong> ?</label>
                    <input type="range" id="tracking-intensity" name="intensity" min="0" max="10" value="5" step="1" required oninput="this.nextElementSibling.textContent = this.value"> <output>5</output>

                    <label for="tracking-notes" class="mt-m">Notes (optionnel) : Qu'avez-vous remarqué aujourd'hui ? (Ex: Niveau de stress, fatigue, activités, sessions effectuées, humeur, environnement sonore...)</label>
                    <textarea id="tracking-notes" name="notes" rows="4" placeholder="Ex: Journée stressante, acouphènes plus forts. Session de relaxation aidé un peu."></textarea>

                    <button type="submit" class="mt-m">Ajouter au journal</button>
                 </fieldset>
            </form>

            <hr style="margin: var(--spacing-l) 0; border: none; border-top: 1px solid var(--border-color);">

             <fieldset id="tracking-history" class="mb-l">
                <legend>Historique des Entrées</legend>
                 <div class="controls mb-m" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--spacing-m);">
                     <label for="history-limit">Afficher les :</label>
                     <select id="history-limit">
                         <option value="10">10 dernières</option>
                         <option value="30" selected>30 dernières</option>
                         <option value="100">100 dernières</option>
                         <option value="all">Toutes</option>
                     </select>
                 </div>
                <p id="history-loading" class="text-center italic">Chargement de l'historique...</p>
                <ul></ul>
            </fieldset>

             <fieldset id="tracking-chart-container">
                <legend>Graphique d'Évolution de l'Intensité</legend>
                <div class="controls mb-m" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--spacing-m);">
                     <label for="chart-limit">Période :</label>
                     <select id="chart-limit">
                         <option value="7">7 derniers jours</option>
                         <option value="30" selected>30 derniers jours</option>
                         <option value="90">90 derniers jours</option>
                         <option value="all">Tout l'historique</option>
                     </select>
                 </div>
                 <div id="tracking-chart"></div>
                 <div id="chart-no-data" class="chart-no-data hidden">Pas assez de données pour afficher le graphique.</div>
            </fieldset>

             <div class="mt-l text-center">
                 <button id="export-data-btn" class="button-secondary">Exporter (JSON)</button>
                 <button id="export-csv-btn" class="button-secondary">Exporter (CSV)</button>
                 <button id="clear-data-btn" class="button-danger">Supprimer TOUTES les données</button>
             </div>
        </section>
    </template>

    <template id="template-resources">
        <!-- Contenu de template-resources (inchangé) -->
         <section class="content-section">
            <h2>Ressources Éducatives</h2>
            <p>Mieux comprendre les acouphènes et les approches de gestion est une étape importante.</p>
             <div class="alert alert-warning mt-m mb-l">
                 <strong>Rappel :</strong> Les informations fournies ici sont à but éducatif et ne constituent pas un avis médical. Consultez un professionnel de la santé pour toute question relative à votre santé.
             </div>

            <article class="mb-l">
                <h3>Qu'est-ce que l'Acouphène ?</h3>
                <p>L'acouphène (ou tinnitus) est la perception d'un son (sifflement, bourdonnement, grésillement, pulsation...) en l'absence de toute source sonore externe correspondante. Ce n'est pas une maladie en soi, mais un symptôme dont les causes peuvent être multiples :</p>
                <ul>
                    <li>Exposition à des bruits forts (ponctuelle ou répétée).</li>
                    <li>Perte auditive liée à l'âge (presbyacousie).</li>
                    <li>Infections de l'oreille, bouchon de cérumen.</li>
                    <li>Maladies (Ménière, otosclérose...).</li>
                    <li>Traumatismes crâniens ou cervicaux.</li>
                    <li>Certains médicaments (ototoxiques).</li>
                    <li>Stress, anxiété, fatigue.</li>
                    <li>Problèmes vasculaires ou neurologiques (plus rares).</li>
                </ul>
                <p>Il est crucial de consulter un médecin ou un ORL pour déterminer la cause potentielle et écarter toute pathologie sous-jacente nécessitant un traitement spécifique.</p>
            </article>

            <article class="mb-l">
                <h3>L'Auto-Hypnose pour la Gestion des Acouphènes</h3>
                <p>L'auto-hypnose est une technique qui permet d'atteindre volontairement un état de conscience modifié, caractérisé par une relaxation profonde et une concentration focalisée. Dans le contexte des acouphènes, elle ne vise pas à "supprimer" le son, mais plutôt à :</p>
                <ul>
                    <li><strong>Réduire le Stress et l'Anxiété :</strong> Le stress est un facteur majeur d'aggravation perçue des acouphènes. L'hypnose aide à activer la réponse de relaxation du corps.</li>
                    <li><strong>Modifier la Perception :</strong> Apprendre à percevoir l'acouphène comme un son neutre, moins intrusif, moins chargé émotionnellement.</li>
                    <li><strong>Détourner l'Attention :</strong> Entraîner le cerveau à se focaliser sur d'autres sensations, pensées ou sons agréables, diminuant ainsi l'attention portée à l'acouphène.</li>
                    <li><strong>Améliorer le Sommeil :</strong> La relaxation induite peut faciliter l'endormissement malgré les acouphènes.</li>
                    <li><strong>Reprendre le Contrôle :</strong> Sentir que l'on dispose d'outils pour gérer l'impact de l'acouphène peut réduire le sentiment d'impuissance.</li>
                </ul>
                <p>La régularité de la pratique est la clé. Les sessions proposées dans cette application, avec lecture vocale optionnelle, sont progressives pour vous guider.</p>
            </article>

             <article class="mb-l">
                <h3>Thérapie par le Son (Sound Therapy)</h3>
                <p>L'utilisation de sons externes (bruit blanc, rose, brun, sons de la nature, musique) est une approche courante. L'objectif peut être :</p>
                <ul>
                    <li><strong>Masquage :</strong> Utiliser un son externe pour couvrir partiellement ou totalement l'acouphène.</li>
                    <li><strong>Distraction :</strong> Fournir un autre son sur lequel se concentrer.</li>
                    <li><strong>Habituation (TRT - Tinnitus Retraining Therapy) :</strong> Utiliser un bruit neutre (souvent du bruit blanc ou rose) à un faible volume, juste en dessous ou au niveau de l'acouphène, pour aider le cerveau à "s'habituer" à l'acouphène et à le considérer comme un son non pertinent. Cela demande du temps et souvent l'accompagnement d'un professionnel.</li>
                </ul>
                 <p>Le générateur de sons de cette application vous permet d'expérimenter avec différents bruits.</p>
             </article>

            <article>
                <h3>Conseils Complémentaires de Gestion</h3>
                <ul>
                    <li><strong>Protégez votre audition :</strong> Évitez l'exposition aux bruits forts sans protection (bouchons d'oreilles, casque anti-bruit).</li>
                    <li><strong>Gérez votre stress :</strong> Intégrez des activités relaxantes dans votre quotidien (méditation, yoga, marche dans la nature, hobbies...).</li>
                    <li><strong>Soignez votre sommeil :</strong> Couchez-vous et levez-vous à heures régulières, créez un environnement propice au sommeil (calme, sombre, frais). Un léger bruit de fond peut aider.</li>
                    <li><strong>Activité physique :</strong> L'exercice régulier aide à réduire le stress et améliore la circulation sanguine.</li>
                    <li><strong>Alimentation :</strong> Bien qu'il n'y ait pas de régime "anti-acouphènes" universel, une alimentation équilibrée est bénéfique. Certaines personnes notent une influence de la caféine, de l'alcool, du sel ou de certains additifs. Tenez un journal si vous suspectez un lien.</li>
                    <li><strong>Évitez le silence complet :</strong> Le silence peut rendre l'acouphène plus perceptible. Un fond sonore léger (radio douce, fontaine d'intérieur, application de sons) peut être utile, surtout la nuit.</li>
                     <li><strong>Restez informé mais pas obsédé :</strong> Comprendre l'acouphène est utile, mais passer des heures à chercher des informations en ligne peut augmenter l'anxiété.</li>
                     <li><strong>Cherchez du soutien :</strong> Parlez-en à vos proches, ou rejoignez des groupes de soutien (associations de patients comme France Acouphènes).</li>
                </ul>
            </article>

             <article class="mt-l">
                 <h3>FAQ (Foire Aux Questions)</h3>
                 <p><strong>Q: Cette application peut-elle guérir mes acouphènes ?</strong><br> R: Non. Acouphènes Zen est conçu comme un outil pour vous aider à gérer les symptômes et l'impact des acouphènes sur votre vie quotidienne. Il ne s'agit pas d'un traitement curatif. La guérison dépend de la cause sous-jacente, qui doit être évaluée par un professionnel.</p>
                 <p class="mt-m"><strong>Q: L'auto-hypnose est-elle sûre ?</strong><br> R: Oui, l'auto-hypnose est généralement considérée comme une technique sûre lorsqu'elle est utilisée pour la relaxation et la gestion du stress. Vous restez conscient et en contrôle. N'utilisez pas l'application en conduisant ou en effectuant des tâches nécessitant votre pleine attention.</p>
                 <p class="mt-m"><strong>Q: La lecture vocale fonctionne-t-elle sur tous les navigateurs ?</strong><br> R: La synthèse vocale (Text-to-Speech) est une fonctionnalité standard des navigateurs modernes (Chrome, Firefox, Safari, Edge). Cependant, la qualité des voix disponibles et leur disponibilité peuvent varier selon votre navigateur et votre système d'exploitation. Si l'option est grisée ou ne fonctionne pas, votre navigateur ne la supporte peut-être pas complètement.</p>
                 <p class="mt-m"><strong>Q: Quel bruit (blanc, rose, brun) est le meilleur ?</strong><br> R: Il n'y a pas de "meilleur" bruit universel. Cela dépend des préférences personnelles et des caractéristiques de votre acouphène.
                    <ul>
                        <li>Le <strong>bruit blanc</strong> contient toutes les fréquences à égale intensité, il peut être perçu comme plus "sifflant".</li>
                        <li>Le <strong>bruit rose</strong> a plus d'énergie dans les basses fréquences (son plus grave, comme une cascade ou une pluie forte), souvent perçu comme plus doux.</li>
                        <li>Le <strong>bruit brun</strong> a encore plus d'énergie dans les basses fréquences (son très grave, comme un grondement lointain ou un torrent), perçu comme le plus "profond".</li>
                    </ul>
                    Expérimentez pour voir ce qui vous convient le mieux.
                 </p>
                 <p class="mt-m"><strong>Q: Mes données sont-elles sécurisées ?</strong><br> R: Toutes les données que vous entrez (évaluation, journal) sont stockées <strong>exclusivement</strong> dans le stockage local de votre navigateur sur votre appareil. Elles ne sont jamais envoyées à un serveur externe. Vous pouvez les supprimer à tout moment via la section "Suivi".</p>
             </article>
        </section>
    </template>


    <!-- --- JavaScript Intégré --- -->
    <script>
        // Attend que le DOM soit complètement chargé
        document.addEventListener('DOMContentLoaded', () => {

            console.log("Acouphènes Zen App Initializing v1.0...");

            // --- MODULE: Utilitaires Globaux ---
            const Utils = (() => {
                // Fonction simple pour échapper le HTML
                function escapeHtml(unsafe) {
                    if (typeof unsafe !== 'string') return unsafe;
                    return unsafe
                         .replace(/&/g, "&amp;")
                         .replace(/</g, "&lt;")
                         .replace(/>/g, "&gt;")
                         .replace(/"/g, "&quot;")
                         .replace(/'/g, "&#039;");
                 }

                 // Fonction pour formater le temps en mm:ss
                 function formatTime(seconds) {
                    if (isNaN(seconds) || seconds < 0) return "--:--";
                    const mins = Math.floor(seconds / 60);
                    const secs = Math.floor(seconds % 60);
                    return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
                 }

                 // Fonction pour mettre à jour dynamiquement le padding du body
                 function updateBodyPadding() {
                    const nav = document.getElementById('main-nav');
                    if (nav) {
                        const navHeight = nav.offsetHeight;
                        // Ajouter un petit buffer pour être sûr
                        const buffer = 5;
                        document.body.style.paddingTop = `${navHeight + buffer}px`;
                        // Mettre à jour la variable CSS pour que d'autres éléments puissent l'utiliser
                        document.documentElement.style.setProperty('--nav-height', `${navHeight + buffer}px`);
                        // console.log("Body padding updated:", navHeight + buffer);
                    }
                 }

                 // Fonction Debounce (pour optimiser l'appel sur resize)
                 function debounce(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                 };


                 return {
                    escapeHtml,
                    formatTime,
                    updateBodyPadding,
                    debounce
                 };
            })();


            // --- MODULE: État Global & Stockage Local ---
            const Store = (() => {
                const STORAGE_KEY = 'acouphenesZenData_v1.1'; // Clé versionnée (incrémentée pour pref TTS)
                const MAX_JOURNAL_ENTRIES = 365;

                let state = {
                    userProfile: {
                        initialAssessment: null,
                        preferences: {
                             theme: 'light',
                             hypnoTtsEnabled: false // Nouvelle préférence pour TTS
                        }
                    },
                    sessions: [], // { timestamp: ISOString, sessionKey: string, duration: number, completed: boolean }
                    journal: [],  // { date: ISOString, intensity: number, notes: string }
                    lastActive: null
                };

                function load() {
                    const storedData = localStorage.getItem(STORAGE_KEY);
                    if (storedData) {
                        try {
                            const parsedData = JSON.parse(storedData);
                            // Fusionner prudemment, en gardant les valeurs par défaut si manquant
                            const defaultPrefs = { theme: 'light', hypnoTtsEnabled: false };
                            state = {
                                userProfile: {
                                    initialAssessment: parsedData.userProfile?.initialAssessment || null,
                                    preferences: {
                                        ...defaultPrefs,
                                        ...(parsedData.userProfile?.preferences || {})
                                     }
                                },
                                sessions: Array.isArray(parsedData.sessions) ? parsedData.sessions : [],
                                journal: Array.isArray(parsedData.journal) ? parsedData.journal : [],
                                lastActive: parsedData.lastActive || null
                            };
                            state.journal.sort((a, b) => new Date(a.date) - new Date(b.date));
                            console.log('Données chargées depuis localStorage.');
                        } catch (e) {
                            console.error("Erreur lors du chargement depuis localStorage:", e);
                        }
                    } else {
                         console.log('Aucune donnée locale trouvée, état initial.');
                    }
                    applyThemePreference();
                }

                function save() {
                    state.lastActive = new Date().toISOString();
                    try {
                        state.journal.sort((a, b) => new Date(a.date) - new Date(b.date));
                        if (state.journal.length > MAX_JOURNAL_ENTRIES) {
                            state.journal = state.journal.slice(state.journal.length - MAX_JOURNAL_ENTRIES);
                        }
                        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                    } catch (e) {
                        console.error("Erreur lors de la sauvegarde dans localStorage:", e);
                        UI.showToast("Erreur sauvegarde données.", "error");
                    }
                }

                function getState() {
                    return JSON.parse(JSON.stringify(state));
                }

                function updateProfile(profileData) { state.userProfile.initialAssessment = profileData; save(); }
                function addJournalEntry(entry) {
                     if (typeof entry.intensity === 'undefined' || entry.intensity === null) return null;
                     entry.date = new Date().toISOString();
                     entry.notes = (entry.notes || "").trim();
                     state.journal.push(entry);
                     save();
                     return entry;
                 }
                function getJournalEntries(limit = null) {
                     const sortedJournal = [...state.journal].sort((a, b) => new Date(b.date) - new Date(a.date));
                     if (limit && typeof limit === 'number' && limit > 0) { return sortedJournal.slice(0, limit); }
                     return sortedJournal;
                 }
                function addSessionLog(logData) { logData.timestamp = new Date().toISOString(); state.sessions.push(logData); save(); }
                function updateThemePreference(theme) { state.userProfile.preferences.theme = theme; save(); }
                function getThemePreference() { return (state.userProfile.preferences.theme === 'dark') ? 'dark' : 'light'; }
                // Fonctions pour la préférence TTS
                function setTtsPreference(enabled) { state.userProfile.preferences.hypnoTtsEnabled = !!enabled; save(); }
                function getTtsPreference() { return !!state.userProfile.preferences.hypnoTtsEnabled; }

                function clearAllData() {
                     if (confirm("ATTENTION !\n\nÊtes-vous absolument sûr de vouloir supprimer TOUTES vos données (évaluation, journal, historique des sessions, préférences) ?\n\nCette action est IRRÉVERSIBLE.")) {
                        localStorage.removeItem(STORAGE_KEY);
                        const currentTheme = getThemePreference(); // Garder le thème actuel
                        const currentTtsPref = getTtsPreference(); // Garder la pref TTS actuelle
                        state = {
                            userProfile: { initialAssessment: null, preferences: { theme: currentTheme, hypnoTtsEnabled: currentTtsPref } },
                            sessions: [], journal: [], lastActive: null
                        };
                        save(); // Sauver l'état réinitialisé (avec prefs conservées)
                        console.log("Toutes les données utilisateur (sauf préférences) ont été supprimées.");
                        window.location.hash = '#home';
                        window.location.reload();
                        return true;
                    }
                    return false;
                 }

                 function applyThemePreference() {
                     const theme = getThemePreference();
                     document.body.classList.toggle('dark-mode', theme === 'dark');
                     const toggleButton = document.getElementById('theme-toggle');
                     if (toggleButton) {
                        toggleButton.textContent = theme === 'dark' ? '☀️' : '🌙';
                        toggleButton.title = `Passer au thème ${theme === 'dark' ? 'clair' : 'sombre'}`;
                     }
                 }
                 load(); // Charger au démarrage

                return { getState, updateProfile, addJournalEntry, getJournalEntries, addSessionLog, updateThemePreference, getThemePreference, applyThemePreference, setTtsPreference, getTtsPreference, clearAllData };
            })();

            // --- MODULE: UI (Manipulation du DOM & Feedback) ---
            const UI = (() => {
                const uiElements = {
                    mainContent: document.getElementById('main-content'),
                    navLinks: document.querySelectorAll('#main-nav a[href^="#"]'),
                };

                function renderTemplate(templateId, context = {}) {
                    const template = document.getElementById(templateId);
                    if (!template) {
                        console.error(`Template non trouvé : ${templateId}`);
                        uiElements.mainContent.innerHTML = `<section class="content-section"><p class="alert alert-danger">Erreur : Contenu de la page introuvable.</p></section>`;
                        setActiveNavLink('');
                        return null;
                    }
                    try {
                        const content = template.content.cloneNode(true);
                        uiElements.mainContent.innerHTML = '';
                        uiElements.mainContent.appendChild(content);
                        setActiveNavLink(templateId.replace('template-', ''));
                        window.scrollTo({ top: 0, behavior: 'smooth' }); // Smooth scroll to top
                        return uiElements.mainContent.firstChild;
                    } catch (error) {
                         console.error(`Erreur lors du rendu du template ${templateId}:`, error);
                         uiElements.mainContent.innerHTML = `<section class="content-section"><p class="alert alert-danger">Erreur lors de l'affichage de cette section.</p></section>`;
                         setActiveNavLink('');
                         return null;
                    }
                }

                function setActiveNavLink(hash) {
                     uiElements.navLinks.forEach(link => {
                         link.classList.remove('active');
                         if (link.getAttribute('href') === `#${hash}`) { link.classList.add('active'); }
                     });
                 }

                 function displayEvaluationResult(score, message) {
                    const resultDiv = document.getElementById('evaluation-result');
                    if (resultDiv) {
                        let alertClass = 'alert-success';
                        if (score >= 25) alertClass = 'alert-danger';
                        else if (score >= 15) alertClass = 'alert-warning';
                        resultDiv.innerHTML = `<div class="alert ${alertClass}"><strong>Résultat :</strong> ${Utils.escapeHtml(message)} (Score d'impact: ${score})</div>`;
                        resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                 }

                 function renderJournalEntry(entry) {
                    const li = document.createElement('li');
                    const entryDate = new Date(entry.date);
                    const formattedDateTime = entryDate.toLocaleString('fr-FR', { dateStyle: 'short', timeStyle: 'short' });
                    li.innerHTML = `<strong>${formattedDateTime}</strong> - Intensité: <span style="font-weight: bold; color: var(--primary-color);">${entry.intensity}/10</span> ${entry.notes ? `<br><em>${Utils.escapeHtml(entry.notes)}</em>` : ''}`;
                    return li;
                 }

                 function displayJournalHistory(entries) {
                    const historyList = document.querySelector('#tracking-history ul');
                    const loadingMsg = document.getElementById('history-loading');
                    if (!historyList || !loadingMsg) return;
                    historyList.innerHTML = '';
                    if (!entries || entries.length === 0) {
                        loadingMsg.textContent = "Votre journal est vide.";
                        loadingMsg.style.display = 'block';
                    } else {
                         loadingMsg.style.display = 'none';
                         entries.forEach(entry => {
                            const li = renderJournalEntry(entry);
                            if (li) historyList.appendChild(li);
                         });
                    }
                 }

                 function showToast(message, type = 'info', duration = 3000) {
                    const toast = document.createElement('div');
                    // Utiliser la classe CSS définie plus haut
                    toast.className = `toast toast-${type}`;
                    toast.textContent = message;
                    document.body.appendChild(toast);
                    requestAnimationFrame(() => {
                        toast.classList.add('show'); // Déclenche l'animation d'entrée
                    });
                    setTimeout(() => {
                        toast.classList.remove('show'); // Déclenche l'animation de sortie
                        toast.addEventListener('transitionend', () => {
                             if (toast.parentNode) { toast.parentNode.removeChild(toast); }
                        }, { once: true });
                    }, duration);
                }

                return { renderTemplate, setActiveNavLink, displayEvaluationResult, displayJournalHistory, showToast };
            })();


            // --- MODULE: Audio (Web Audio API) ---
            const AudioManager = (() => {
                let audioContext;
                let masterGainNode;
                let currentNoiseSource = null;
                let currentNoiseType = null;
                let noiseTimer = null;

                function getContext() {
                    // ... (code getContext identique à la version précédente)
                     if (!audioContext) {
                        try {
                           window.AudioContext = window.AudioContext || window.webkitAudioContext;
                           if (!window.AudioContext) { throw new Error("Web Audio API non supportée"); }
                           audioContext = new AudioContext();
                           masterGainNode = audioContext.createGain();
                           masterGainNode.connect(audioContext.destination);
                           console.log("AudioContext créé et prêt.");
                        } catch(e) {
                           console.error("Erreur AudioContext:", e);
                           UI.showToast("Erreur: Audio non supporté.", "error", 5000);
                           return null;
                        }
                    }
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().catch(err => console.error("Erreur reprise AudioContext:", err));
                    }
                    return audioContext;
                }
                function initContextOnInteraction() {
                    // ... (code initContextOnInteraction identique)
                     const initAudio = () => {
                         const context = getContext();
                         if (context && context.state === 'running') {
                             console.log("Contexte audio activé par interaction.");
                             document.body.removeEventListener('click', initAudio, { capture: true });
                             document.body.removeEventListener('touchstart', initAudio, { capture: true });
                             document.body.removeEventListener('keydown', initAudio, { capture: true });
                         }
                     };
                     document.body.addEventListener('click', initAudio, { once: true, capture: true });
                     document.body.addEventListener('touchstart', initAudio, { once: true, capture: true });
                     document.body.addEventListener('keydown', initAudio, { once: true, capture: true });
                 }
                 // --- Fonctions de création de bruit (identiques) ---
                 function createWhiteNoiseSource(context) { /* ... identique ... */
                    const bufferSize = context.sampleRate * 2;
                    const noiseBuffer = context.createBuffer(1, bufferSize, context.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
                    const source = context.createBufferSource();
                    source.buffer = noiseBuffer; source.loop = true; return source;
                 }
                 function createPinkNoiseSource(context) { /* ... identique ... */
                    const whiteNoise = createWhiteNoiseSource(context);
                    const pinkFilter = context.createBiquadFilter();
                    pinkFilter.type = 'lowpass';
                    pinkFilter.frequency.setValueAtTime(800, context.currentTime);
                    pinkFilter.Q.setValueAtTime(0.707, context.currentTime);
                    whiteNoise.connect(pinkFilter); return { source: whiteNoise, outputNode: pinkFilter };
                 }
                 function createBrownNoiseSource(context) { /* ... identique ... */
                    const whiteNoise = createWhiteNoiseSource(context);
                    const brownFilter = context.createBiquadFilter();
                    brownFilter.type = 'lowpass';
                    brownFilter.frequency.setValueAtTime(300, context.currentTime);
                    brownFilter.Q.setValueAtTime(1, context.currentTime);
                    whiteNoise.connect(brownFilter); return { source: whiteNoise, outputNode: brownFilter };
                 }

                function playNoise(type, volume, durationMinutes = 0) {
                    stopNoise();
                    const context = getContext();
                    if (!context || context.state !== 'running') {
                         UI.showToast("Cliquez sur la page pour activer l'audio.", "warning");
                         console.warn("Contexte audio non prêt.");
                         return false;
                     }
                    let noiseInfo;
                    // ... (switch case identique)
                     switch (type) {
                        case 'white': noiseInfo = { source: createWhiteNoiseSource(context), outputNode: createWhiteNoiseSource(context) }; break; // Correction : utiliser la même source
                        case 'pink': noiseInfo = createPinkNoiseSource(context); break;
                        case 'brown': noiseInfo = createBrownNoiseSource(context); break;
                        default: console.error(`Type bruit non supporté: ${type}`); UI.showToast(`Bruit inconnu: ${type}`, "error"); return false;
                     }
                    currentNoiseSource = noiseInfo.source; currentNoiseType = type;
                    noiseInfo.outputNode.connect(masterGainNode);
                    setVolume(volume);
                    currentNoiseSource.start(0);
                    console.log(`Bruit ${type} démarré (vol: ${volume.toFixed(2)})`);
                    // Gestion minuteur (identique)
                    if (durationMinutes > 0) {
                         const durationSeconds = durationMinutes * 60;
                         console.log(`Minuteur arrêt réglé sur ${durationMinutes} min.`);
                         noiseTimer = setTimeout(() => {
                             console.log("Minuteur arrêt atteint."); stopNoise(); UI.showToast("Son arrêté (minuteur).", "info");
                             document.dispatchEvent(new CustomEvent('audiotimerend'));
                         }, durationSeconds * 1000);
                         document.dispatchEvent(new CustomEvent('audiotimerstart', { detail: { durationMinutes } }));
                     } else { document.dispatchEvent(new CustomEvent('audiotimerclear')); }
                     return true;
                }

                function stopNoise() {
                    // ... (code stopNoise identique)
                     if (noiseTimer) { clearTimeout(noiseTimer); noiseTimer = null; document.dispatchEvent(new CustomEvent('audiotimerclear')); console.log("Minuteur arrêt annulé."); }
                     if (currentNoiseSource) {
                         try { currentNoiseSource.disconnect(); currentNoiseSource.stop(0); } catch (e) {}
                         const stoppedType = currentNoiseType; currentNoiseSource = null; currentNoiseType = null;
                         console.log(`Bruit ${stoppedType} arrêté.`); return true;
                     } return false;
                }

                function setVolume(volume) {
                    // ... (code setVolume identique)
                     volume = Math.max(0, Math.min(1, volume));
                     if (masterGainNode && audioContext) { masterGainNode.gain.setTargetAtTime(volume, audioContext.currentTime, 0.015); }
                }
                function isPlaying() { return !!currentNoiseSource; }

                return { initContextOnInteraction, playNoise, stopNoise, setVolume, isPlaying };
            })();

            // --- MODULE: Synthèse Vocale (TTS) ---
            const TTSManager = (() => {
                let synthesis = window.speechSynthesis;
                let isSupported = false;
                let currentUtterance = null;

                function init() {
                    if ('speechSynthesis' in window) {
                        isSupported = true;
                        console.log("TTS pris en charge.");
                        // Tenter de charger les voix (peut être asynchrone)
                         synthesis.getVoices(); // Appel initial
                         if (synthesis.onvoiceschanged !== undefined) {
                            synthesis.onvoiceschanged = () => console.log("Voix TTS chargées/mises à jour.");
                         }
                    } else {
                        console.warn("TTS non pris en charge par ce navigateur.");
                    }
                }

                function speak(text) {
                    if (!isSupported || !text) return false;
                    // Annuler la lecture précédente si elle existe
                    cancel();

                    currentUtterance = new SpeechSynthesisUtterance(text);
                    // Essayer de trouver une voix française
                    const voices = synthesis.getVoices();
                    let frVoice = voices.find(voice => voice.lang === 'fr-FR');
                    // Si pas de FR-FR, chercher FR générique
                    if (!frVoice) frVoice = voices.find(voice => voice.lang.startsWith('fr'));
                    if (frVoice) {
                        currentUtterance.voice = frVoice;
                        // console.log("Voix française trouvée:", frVoice.name);
                    } else {
                         console.warn("Aucune voix française trouvée pour TTS, utilisation de la voix par défaut.");
                    }
                    currentUtterance.lang = 'fr-FR'; // Définir la langue de l'utterance
                    currentUtterance.pitch = 1; // Normal
                    currentUtterance.rate = 0.9; // Un peu plus lent pour l'hypnose

                    // Gérer la fin de la lecture (pour savoir quand c'est fini)
                    currentUtterance.onend = () => {
                        // console.log("TTS terminé pour:", text.substring(0, 20) + "...");
                        currentUtterance = null;
                    };
                    currentUtterance.onerror = (event) => {
                        console.error('Erreur TTS:', event.error);
                         UI.showToast("Erreur de lecture vocale.", "error");
                        currentUtterance = null;
                    };

                    // Déclencher la lecture
                    try {
                       synthesis.speak(currentUtterance);
                       return true;
                    } catch (error) {
                        console.error("Erreur lors de synthesis.speak:", error);
                         UI.showToast("Impossible de démarrer la lecture vocale.", "error");
                         return false;
                    }
                }

                function cancel() {
                    if (synthesis && synthesis.speaking) {
                        synthesis.cancel();
                        // console.log("TTS annulé.");
                        currentUtterance = null;
                    }
                }

                function isSpeaking() {
                     return synthesis && synthesis.speaking;
                }

                // Initialiser dès que le module est défini
                init();

                return {
                    isSupported: () => isSupported,
                    speak,
                    cancel,
                    isSpeaking
                };
            })();


            // --- MODULE: Routage ---
            const Router = (() => {
                // ... (code Router.handleRouteChange identique, appelle les init/cleanup) ...
                let currentPageInitFunction = null;
                let currentPageCleanupFunction = null;

                function handleRouteChange() {
                    const hash = window.location.hash || '#home'; let route = hash.substring(1);
                    if (typeof currentPageCleanupFunction === 'function') { try { currentPageCleanupFunction(); } catch (e) { console.error("Erreur cleanup:", e); } currentPageCleanupFunction = null; }
                    currentPageInitFunction = null;
                    if (AudioManager.isPlaying()) { AudioManager.stopNoise(); UI.showToast("Son arrêté.", "info"); }
                    if (TTSManager.isSpeaking()) { TTSManager.cancel(); console.log("TTS arrêté en changeant de page."); } // Arrêter TTS aussi

                    const templateId = `template-${route}`;
                    if (!document.getElementById(templateId)) { route = 'home'; window.location.hash = '#home'; }
                    console.log(`Navigation vers: ${route}`);
                    const renderedElement = UI.renderTemplate(`template-${route}`);
                    if (renderedElement) {
                        switch (route) {
                            case 'evaluation': currentPageInitFunction = initEvaluationPage; currentPageCleanupFunction = cleanupEvaluationPage; break;
                            case 'hypnose': currentPageInitFunction = initHypnosePage; currentPageCleanupFunction = cleanupHypnosePage; break;
                            case 'sounds': currentPageInitFunction = initSoundsPage; currentPageCleanupFunction = cleanupSoundsPage; break;
                            case 'tracking': currentPageInitFunction = initTrackingPage; currentPageCleanupFunction = cleanupTrackingPage; break;
                            case 'resources': currentPageInitFunction = initResourcesPage; break;
                            case 'home': default: currentPageInitFunction = initHomePage; break;
                        }
                        if (typeof currentPageInitFunction === 'function') { try { currentPageInitFunction(); console.log(`Init ${route} OK.`); } catch(e) { console.error(`Erreur init ${route}:`, e); UI.showToast(`Erreur chargement section ${route}.`, "error"); } }
                    }
                }
                function init() {
                    window.addEventListener('hashchange', handleRouteChange);
                    AudioManager.initContextOnInteraction();
                    initThemeToggle();
                    // Gérer le padding dynamique au chargement et au redimensionnement
                    Utils.updateBodyPadding(); // Appel initial
                     // Utiliser debounce pour optimiser l'appel sur resize
                     window.addEventListener('resize', Utils.debounce(Utils.updateBodyPadding, 150));
                    handleRouteChange(); // Gérer route initiale
                }
                return { init };
            })();

            // --- Fonctions d'initialisation et de nettoyage spécifiques aux pages ---

            function initHomePage() { /* Rien de spécifique */ }
            function cleanupHomePage() { /* Rien de spécifique */ }

            // Page d'évaluation (logique identique)
             function initEvaluationPage() { /* ... identique ... */
                const form = document.getElementById('evaluation-form'); const resultDiv = document.getElementById('evaluation-result'); const savedProfile = Store.getState().userProfile.initialAssessment;
                if (form && savedProfile) { Object.keys(savedProfile).forEach(key => { /* ... préremplissage ... */ }); resultDiv.innerHTML = `<div class="alert alert-info">Infos chargées.</div>`; } else if (resultDiv) { resultDiv.innerHTML = ''; }
                form?.addEventListener('submit', handleEvaluationSubmit);
             }
             function handleEvaluationSubmit(e) { /* ... identique ... */
                e.preventDefault(); const form = e.target; const formData = new FormData(form); const data = {}; let score = 0; const impactKeys = ['intensity-avg', 'impact-sleep', 'impact-concentration', 'impact-mood', 'impact-hearing'];
                formData.forEach((value, key) => { data[key] = Utils.escapeHtml(value.trim()); if (impactKeys.includes(key)) { score += parseInt(value, 10) || 0; } });
                console.log('Données évaluation:', data, 'Score:', score); Store.updateProfile(data);
                let message = "Évaluation enregistrée. "; if (score >= 25) { message += "Impact significatif."; } else if (score >= 15) { message += "Impact modéré."; } else { message += "Impact léger."; }
                UI.displayEvaluationResult(score, message); UI.showToast("Évaluation enregistrée !", "success");
             }
            function cleanupEvaluationPage() { /* ... identique ... */
                const form = document.getElementById('evaluation-form'); form?.removeEventListener('submit', handleEvaluationSubmit); console.log("Cleanup Évaluation");
            }

            // Page d'Auto-Hypnose (logique mise à jour pour TTS)
             let hypnoTimerInterval = null;
             let hypnoSessionEndTime = 0;
             let hypnoCurrentSessionData = null;
             let hypnoNoiseType = 'none';
             let hypnoVolume = 0.05;
             let hypnoSessionCompleted = false;
             let hypnoTtsEnabled = false; // État local du TTS pour la session
             const sessionsData = { /* ... Contenu sessions identique ... */ };

            function updateHypnoTimer() {
                 const now = Date.now();
                 const remaining = Math.max(0, (hypnoSessionEndTime - now) / 1000);
                 const timerDisplay = document.querySelector('#hypnose-session .timer');
                 const textContent = document.getElementById('session-text-content');
                 const stepIndicator = document.getElementById('session-step-indicator');
                 let newTextDisplayed = false; // Flag pour savoir si on a changé le texte

                 if (timerDisplay) timerDisplay.textContent = Utils.formatTime(remaining);

                 if (hypnoCurrentSessionData && textContent) {
                     const elapsed = hypnoCurrentSessionData.duration - remaining;
                     const currentStepIndex = hypnoCurrentSessionData.script.slice().reverse().findIndex(step => elapsed >= step.time);
                     const currentStep = currentStepIndex !== -1 ? hypnoCurrentSessionData.script[hypnoCurrentSessionData.script.length - 1 - currentStepIndex] : null;

                     if (currentStep) {
                         const currentTextElement = textContent.querySelector('p');
                         // Comparer avec le texte brut, pas le HTML échappé
                         const displayedText = currentTextElement ? currentTextElement.dataset.rawText : null;

                         if (!displayedText || displayedText !== currentStep.text) {
                             textContent.innerHTML = `<p data-raw-text="${Utils.escapeHtml(currentStep.text)}">${Utils.escapeHtml(currentStep.text)}</p>`; // Stocker texte brut dans data attribute
                             textContent.scrollTop = textContent.scrollHeight;
                             newTextDisplayed = true; // On a changé le texte affiché

                             // --- Déclenchement TTS ---
                             if (hypnoTtsEnabled && TTSManager.isSupported()) {
                                 TTSManager.speak(currentStep.text); // Lire le nouveau texte
                             }
                             // -------------------------
                         }
                         if (stepIndicator) {
                             const totalSteps = hypnoCurrentSessionData.script.length;
                             const currentStepNumber = hypnoCurrentSessionData.script.length - currentStepIndex;
                             stepIndicator.textContent = `Étape ${currentStepNumber} / ${totalSteps}`;
                         }
                     }
                 }

                 if (remaining === 0) {
                     hypnoSessionCompleted = true;
                     stopHypnoSession();
                 }
             }

            function startHypnoSession(sessionKey) {
                 hypnoCurrentSessionData = sessionsData[sessionKey];
                 if (!hypnoCurrentSessionData) { UI.showToast("Erreur chargement session.", "error"); return; }

                 const menu = document.getElementById('hypnose-menu');
                 const sessionView = document.getElementById('hypnose-session');
                 const startBtn = document.getElementById('start-session-btn');
                 const stopBtn = document.getElementById('stop-session-btn');
                 const timerDisplay = sessionView?.querySelector('.timer');
                 const sessionTextContent = document.getElementById('session-text-content');
                 const stepIndicator = document.getElementById('session-step-indicator');
                 const noiseSelect = document.getElementById('hypno-noise');
                 const volumeSlider = document.getElementById('hypno-volume');
                 const ttsToggle = document.getElementById('hypno-tts-enable');

                 // Récupérer options
                 hypnoNoiseType = noiseSelect.value;
                 hypnoVolume = parseFloat(volumeSlider.value);
                 hypnoTtsEnabled = ttsToggle.checked; // Lire l'état du toggle

                 hypnoSessionCompleted = false;
                 sessionTextContent.innerHTML = `<p data-raw-text="${Utils.escapeHtml(hypnoCurrentSessionData.script[0]?.text || '')}">${Utils.escapeHtml(hypnoCurrentSessionData.script[0]?.text || 'Préparation...')}</p>`;
                 stepIndicator.textContent = `Étape 1 / ${hypnoCurrentSessionData.script.length}`;
                 timerDisplay.textContent = Utils.formatTime(hypnoCurrentSessionData.duration);

                 menu.classList.add('hidden');
                 sessionView.classList.remove('hidden');
                 startBtn.classList.add('hidden');
                 stopBtn.classList.remove('hidden');
                 noiseSelect.disabled = true;
                 volumeSlider.disabled = true;
                 ttsToggle.disabled = true; // Désactiver aussi pendant la session

                 if (hypnoNoiseType !== 'none') AudioManager.playNoise(hypnoNoiseType, hypnoVolume);
                 else AudioManager.stopNoise();

                 // Démarrer TTS si activé (pour la première étape)
                 if (hypnoTtsEnabled && TTSManager.isSupported() && hypnoCurrentSessionData.script[0]) {
                     TTSManager.speak(hypnoCurrentSessionData.script[0].text);
                 }

                 hypnoSessionEndTime = Date.now() + hypnoCurrentSessionData.duration * 1000;
                 updateHypnoTimer();
                 hypnoTimerInterval = setInterval(updateHypnoTimer, 1000);

                 console.log(`Session hypnose démarrée: ${sessionKey}, TTS: ${hypnoTtsEnabled}`);
                 UI.showToast(`Session "${hypnoCurrentSessionData.title}" démarrée.`, "info");
             }

             function stopHypnoSession() {
                 const sessionEndedNaturally = hypnoSessionCompleted;
                 clearInterval(hypnoTimerInterval); hypnoTimerInterval = null;
                 AudioManager.stopNoise();
                 TTSManager.cancel(); // Arrêter la lecture vocale

                 if (hypnoCurrentSessionData) { Store.addSessionLog({ sessionKey: Object.keys(sessionsData).find(key => sessionsData[key] === hypnoCurrentSessionData), duration: hypnoCurrentSessionData.duration, completed: sessionEndedNaturally }); console.log(`Session ${sessionEndedNaturally ? 'terminée' : 'arrêtée'}`); }

                 const menu = document.getElementById('hypnose-menu');
                 const sessionView = document.getElementById('hypnose-session');
                 const startBtn = document.getElementById('start-session-btn');
                 const stopBtn = document.getElementById('stop-session-btn');
                 const noiseSelect = document.getElementById('hypno-noise');
                 const volumeSlider = document.getElementById('hypno-volume');
                 const ttsToggle = document.getElementById('hypno-tts-enable');

                 if (sessionView) sessionView.classList.add('hidden');
                 if (menu) menu.classList.remove('hidden');
                 if (stopBtn) stopBtn.classList.add('hidden');
                 if (startBtn) { startBtn.classList.remove('hidden'); startBtn.textContent = "Sélectionnez une session"; startBtn.disabled = true; startBtn.onclick = null; }
                 if (noiseSelect) noiseSelect.disabled = false;
                 if (volumeSlider) volumeSlider.disabled = false;
                 if (ttsToggle) ttsToggle.disabled = !TTSManager.isSupported(); // Réactiver si supporté

                 if (sessionEndedNaturally) UI.showToast("Session terminée !", "success");
                 else UI.showToast("Session arrêtée.", "warning");
                 hypnoCurrentSessionData = null; hypnoSessionCompleted = false;
             }

            function initHypnosePage() {
                 const menu = document.getElementById('hypnose-menu');
                 const sessionView = document.getElementById('hypnose-session');
                 const startBtn = document.getElementById('start-session-btn');
                 const stopBtn = document.getElementById('stop-session-btn');
                 const ttsToggle = document.getElementById('hypno-tts-enable');
                 const ttsStatus = document.getElementById('tts-status');

                 // État initial UI
                 if (menu) menu.classList.remove('hidden');
                 if (sessionView) sessionView.classList.add('hidden');
                 if (startBtn) { startBtn.textContent = "Sélectionnez une session"; startBtn.disabled = true; startBtn.classList.remove('hidden'); }
                 if (stopBtn) stopBtn.classList.add('hidden');

                 // Configurer le toggle TTS
                 if (ttsToggle && ttsStatus) {
                     if (TTSManager.isSupported()) {
                         ttsToggle.checked = Store.getTtsPreference(); // Charger préférence
                         ttsToggle.disabled = false;
                         ttsStatus.textContent = ''; // Pas besoin de message si supporté
                         ttsToggle.addEventListener('change', handleTtsToggleChange);
                     } else {
                         ttsToggle.checked = false;
                         ttsToggle.disabled = true;
                         ttsStatus.textContent = '(Lecture vocale non supportée par votre navigateur)';
                     }
                 }

                 menu?.addEventListener('click', handleHypnoMenuClick);
                 stopBtn?.addEventListener('click', stopHypnoSession);
             }
             function handleHypnoMenuClick(e) { /* ... (Logique identique pour préparer la session) ... */
                if (e.target.tagName === 'BUTTON' && e.target.dataset.session) {
                     const sessionKey = e.target.dataset.session; const sessionData = sessionsData[sessionKey]; if (!sessionData) return;
                     const startBtn = document.getElementById('start-session-btn'); const sessionTitle = document.getElementById('session-title'); const sessionView = document.getElementById('hypnose-session'); const timerDisplay = sessionView?.querySelector('.timer'); const sessionTextContent = document.getElementById('session-text-content'); const stepIndicator = document.getElementById('session-step-indicator');
                     if (sessionTitle) sessionTitle.textContent = sessionData.title + " (Prêt)";
                     if (timerDisplay) timerDisplay.textContent = Utils.formatTime(sessionData.duration);
                     if (sessionTextContent) sessionTextContent.innerHTML = `<p>Préparez-vous. Cliquez sur "Démarrer".</p>`;
                     if (stepIndicator) stepIndicator.textContent = `Durée: ${Math.round(sessionData.duration / 60)} min`;
                     if (startBtn) { startBtn.textContent = `Démarrer la session`; startBtn.onclick = () => startHypnoSession(sessionKey); startBtn.disabled = false; }
                     if (sessionView) sessionView.classList.remove('hidden');
                     document.getElementById('stop-session-btn')?.classList.add('hidden');
                     // Réactiver contrôles (si désactivés avant)
                     const ttsToggle = document.getElementById('hypno-tts-enable');
                      document.getElementById('hypno-noise').disabled = false; document.getElementById('hypno-volume').disabled = false;
                      if (ttsToggle) ttsToggle.disabled = !TTSManager.isSupported();
                     sessionView.scrollIntoView({ behavior: 'smooth', block: 'start' });
                 }
             }
             function handleTtsToggleChange(e) {
                 const isEnabled = e.target.checked;
                 Store.setTtsPreference(isEnabled); // Sauver la préférence
                 hypnoTtsEnabled = isEnabled; // Mettre à jour l'état local (sera utilisé au démarrage)
                 console.log("Préférence TTS mise à jour:", isEnabled);
             }
            function cleanupHypnosePage() {
                 if (hypnoTimerInterval) { stopHypnoSession(); console.warn("Session hypnose arrêtée (quitté section)."); }
                 const menu = document.getElementById('hypnose-menu');
                 const stopBtn = document.getElementById('stop-session-btn');
                 const ttsToggle = document.getElementById('hypno-tts-enable');
                 const startBtn = document.getElementById('start-session-btn');
                 menu?.removeEventListener('click', handleHypnoMenuClick);
                 stopBtn?.removeEventListener('click', stopHypnoSession);
                 ttsToggle?.removeEventListener('change', handleTtsToggleChange);
                 if(startBtn) startBtn.onclick = null;
                 console.log("Cleanup Hypnose");
            }

            // Page Générateur de Sons (logique identique)
             let soundTimerInterval = null; let soundTimerEndTime = 0;
             function updateSoundTimerDisplay() { /* ... identique ... */
                const statusSpan = document.getElementById('sound-timer-status'); if (!statusSpan || !AudioManager.isPlaying() || !noiseTimer) { if (statusSpan) statusSpan.textContent = ''; clearInterval(soundTimerInterval); soundTimerInterval = null; return; }
                const now = Date.now(); const remainingSeconds = Math.max(0, Math.round((soundTimerEndTime - now) / 1000));
                if (remainingSeconds > 0) { statusSpan.textContent = `Arrêt dans: ${Utils.formatTime(remainingSeconds)}`; } else { statusSpan.textContent = ''; clearInterval(soundTimerInterval); soundTimerInterval = null; }
             }
             function initSoundsPage() { /* ... identique ... */
                const playBtn = document.getElementById('play-sound-btn'); const stopBtn = document.getElementById('stop-sound-btn'); const volumeSlider = document.getElementById('sound-volume'); const volumeOutput = volumeSlider?.nextElementSibling;
                const updateVolumeOutputDisplay = () => { if (volumeSlider && volumeOutput) volumeOutput.textContent = parseFloat(volumeSlider.value).toFixed(2); }
                playBtn?.addEventListener('click', handlePlaySound); stopBtn?.addEventListener('click', handleStopSound); volumeSlider?.addEventListener('input', handleSoundVolumeInput); volumeSlider?.addEventListener('change', handleSoundVolumeChange);
                updateVolumeOutputDisplay(); stopBtn?.classList.add('hidden'); playBtn?.classList.remove('hidden');
                document.addEventListener('audiotimerstart', handleAudioTimerStart); document.addEventListener('audiotimerend', handleAudioTimerEnd); document.addEventListener('audiotimerclear', handleAudioTimerClear);
             }
             function handlePlaySound() { /* ... identique ... */
                const type = document.getElementById('sound-type-select').value; const volume = parseFloat(document.getElementById('sound-volume').value); const durationMinutes = parseInt(document.getElementById('sound-timer').value, 10) || 0;
                const success = AudioManager.playNoise(type, volume, durationMinutes);
                if (success) { document.getElementById('play-sound-btn')?.classList.add('hidden'); document.getElementById('stop-sound-btn')?.classList.remove('hidden'); document.getElementById('sound-type-select').disabled = true; document.getElementById('sound-timer').disabled = true; }
             }
             function handleStopSound() { /* ... identique ... */
                const stopped = AudioManager.stopNoise();
                if (stopped) { document.getElementById('play-sound-btn')?.classList.remove('hidden'); document.getElementById('stop-sound-btn')?.classList.add('hidden'); document.getElementById('sound-type-select').disabled = false; document.getElementById('sound-timer').disabled = false; document.getElementById('sound-timer-status').textContent = ''; if (soundTimerInterval) clearInterval(soundTimerInterval); soundTimerInterval = null; }
             }
             function handleSoundVolumeInput(e) { /* ... identique ... */
                 const volumeOutput = e.target.nextElementSibling; if (volumeOutput) volumeOutput.textContent = parseFloat(e.target.value).toFixed(2); if (AudioManager.isPlaying()) AudioManager.setVolume(parseFloat(e.target.value));
             }
             function handleSoundVolumeChange(e) { AudioManager.setVolume(parseFloat(e.target.value)); }
             function handleAudioTimerStart(e) { /* ... identique ... */
                const durationMinutes = e.detail.durationMinutes; soundTimerEndTime = Date.now() + durationMinutes * 60 * 1000; if (soundTimerInterval) clearInterval(soundTimerInterval); updateSoundTimerDisplay(); soundTimerInterval = setInterval(updateSoundTimerDisplay, 1000);
             }
             function handleAudioTimerEnd() { handleStopSound(); }
             function handleAudioTimerClear() { /* ... identique ... */
                if (soundTimerInterval) clearInterval(soundTimerInterval); soundTimerInterval = null; const statusSpan = document.getElementById('sound-timer-status'); if (statusSpan) statusSpan.textContent = '';
             }
             function cleanupSoundsPage() { /* ... identique ... */
                if (AudioManager.isPlaying()) handleStopSound();
                const playBtn = document.getElementById('play-sound-btn'); const stopBtn = document.getElementById('stop-sound-btn'); const volumeSlider = document.getElementById('sound-volume');
                playBtn?.removeEventListener('click', handlePlaySound); stopBtn?.removeEventListener('click', handleStopSound); volumeSlider?.removeEventListener('input', handleSoundVolumeInput); volumeSlider?.removeEventListener('change', handleSoundVolumeChange);
                document.removeEventListener('audiotimerstart', handleAudioTimerStart); document.removeEventListener('audiotimerend', handleAudioTimerEnd); document.removeEventListener('audiotimerclear', handleAudioTimerClear);
                if (soundTimerInterval) clearInterval(soundTimerInterval); soundTimerInterval = null; console.log("Cleanup Sons");
             }

            // Page Suivi (logique identique, utilise Utils.escapeHtml)
             function initTrackingPage() { /* ... identique ... */
                 const form = document.getElementById('tracking-form'); const clearDataBtn = document.getElementById('clear-data-btn'); const exportJsonBtn = document.getElementById('export-data-btn'); const exportCsvBtn = document.getElementById('export-csv-btn'); const historyLimitSelect = document.getElementById('history-limit'); const chartLimitSelect = document.getElementById('chart-limit');
                 form?.addEventListener('submit', handleTrackingSubmit); clearDataBtn?.addEventListener('click', handleClearData); exportJsonBtn?.addEventListener('click', handleExportJson); exportCsvBtn?.addEventListener('click', handleExportCsv); historyLimitSelect?.addEventListener('change', updateTrackingDisplay); chartLimitSelect?.addEventListener('change', updateTrackingDisplay);
                 updateTrackingDisplay();
             }
             function updateTrackingDisplay() { /* ... identique ... */
                 const historyLimit = document.getElementById('history-limit')?.value || '30'; const chartLimit = document.getElementById('chart-limit')?.value || '30'; let limitHistoryNum = historyLimit === 'all' ? null : parseInt(historyLimit, 10); let limitChartDays = chartLimit === 'all' ? null : parseInt(chartLimit, 10);
                 const entries = Store.getJournalEntries(limitHistoryNum); UI.displayJournalHistory(entries); const allJournalData = Store.getState().journal; drawIntensityChart(allJournalData, limitChartDays);
             }
             function handleTrackingSubmit(e) { /* ... identique ... */
                e.preventDefault(); const form = e.target; const formData = new FormData(form); const newEntry = { intensity: formData.get('intensity'), notes: formData.get('notes') }; const savedEntry = Store.addJournalEntry(newEntry);
                if (savedEntry) { form.reset(); const intensityRange = document.getElementById('tracking-intensity'); if(intensityRange && intensityRange.nextElementSibling) intensityRange.nextElementSibling.textContent = intensityRange.defaultValue; UI.showToast('Entrée ajoutée.', 'success'); updateTrackingDisplay(); } else { UI.showToast("Erreur ajout entrée.", 'error'); }
             }
             function handleClearData() { Store.clearAllData(); }
             function handleExportJson() { /* ... identique ... */
                try { const data = Store.getState(); const dataStr = JSON.stringify(data, null, 2); const blob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `acouphenes_zen_data_${new Date().toISOString().split('T')[0]}.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); UI.showToast("Export JSON terminé.", "success"); } catch (e) { console.error("Erreur export JSON:", e); UI.showToast("Erreur export JSON.", "error"); }
             }
             function handleExportCsv() { /* ... identique ... */
                try { const journal = Store.getState().journal; if (!journal || journal.length === 0) { UI.showToast("Journal vide.", "warning"); return; } const header = "DateHeureISO;Intensite;Notes\n"; const rows = journal.map(entry => { const date = entry.date; const intensity = entry.intensity; let notes = entry.notes || ""; if (notes.includes('"') || notes.includes(';') || notes.includes('\n')) { notes = `"${notes.replace(/"/g, '""')}"`; } return `${date};${intensity};${notes}`; }); const csvContent = header + rows.join("\n"); const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `acouphenes_zen_journal_${new Date().toISOString().split('T')[0]}.csv`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); UI.showToast("Export CSV terminé.", "success"); } catch (e) { console.error("Erreur export CSV:", e); UI.showToast("Erreur export CSV.", "error"); }
             }
             function drawIntensityChart(data, limitDays) { /* ... (Code dessin SVG identique) ... */
                 const container = document.getElementById('tracking-chart'); const noDataMsg = document.getElementById('chart-no-data'); if (!container || !noDataMsg) return; container.innerHTML = ''; noDataMsg.classList.add('hidden');
                 let filteredData = data; if (limitDays !== null && limitDays > 0) { const limitDate = new Date(); limitDate.setDate(limitDate.getDate() - limitDays); filteredData = data.filter(entry => new Date(entry.date) >= limitDate); }
                 if (filteredData.length < 2) { noDataMsg.classList.remove('hidden'); console.log("Pas assez données pour graph."); return; }
                 filteredData.sort((a, b) => new Date(a.date) - new Date(b.date));
                 const svgNS = "http://www.w3.org/2000/svg"; const svg = document.createElementNS(svgNS, "svg"); const containerRect = container.getBoundingClientRect(); const svgWidth = containerRect.width || 600; const svgHeight = 250; const margin = { top: 20, right: 30, bottom: 40, left: 40 }; const width = svgWidth - margin.left - margin.right; const height = svgHeight - margin.top - margin.bottom;
                 svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`); svg.setAttribute("preserveAspectRatio", "xMidYMid meet"); svg.style.width = "100%"; svg.style.height = `${svgHeight}px`;
                 const g = document.createElementNS(svgNS, "g"); g.setAttribute("transform", `translate(${margin.left},${margin.top})`); svg.appendChild(g);
                 const firstDate = new Date(filteredData[0].date); const lastDate = new Date(filteredData[filteredData.length - 1].date); const totalTimeDiff = lastDate.getTime() - firstDate.getTime();
                 const xScale = (date) => { if (totalTimeDiff === 0) return 0; const timeDiff = new Date(date).getTime() - firstDate.getTime(); return (timeDiff / totalTimeDiff) * width; }; const yScale = (intensity) => height - (intensity / 10) * height;
                 const yAxis = document.createElementNS(svgNS, "line"); yAxis.setAttribute("x1", 0); yAxis.setAttribute("y1", 0); yAxis.setAttribute("x2", 0); yAxis.setAttribute("y2", height); yAxis.setAttribute("class", "chart-axis"); g.appendChild(yAxis);
                 [0, 5, 10].forEach(val => { const y = yScale(val); const label = document.createElementNS(svgNS, "text"); label.setAttribute("x", -margin.left / 2); label.setAttribute("y", y); label.setAttribute("dy", "0.32em"); label.setAttribute("class", "chart-text axis-label-y"); label.textContent = val; g.appendChild(label); const gridLine = document.createElementNS(svgNS, "line"); gridLine.setAttribute("x1", 0); gridLine.setAttribute("y1", y); gridLine.setAttribute("x2", width); gridLine.setAttribute("y2", y); gridLine.setAttribute("class", "chart-grid"); g.appendChild(gridLine); });
                 const xAxis = document.createElementNS(svgNS, "line"); xAxis.setAttribute("x1", 0); xAxis.setAttribute("y1", height); xAxis.setAttribute("x2", width); xAxis.setAttribute("y2", height); xAxis.setAttribute("class", "chart-axis"); g.appendChild(xAxis);
                 const formatDateLabel = (date) => date.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit'}); [firstDate, lastDate].forEach((date, index) => { const x = index === 0 ? 0 : width; const label = document.createElementNS(svgNS, "text"); label.setAttribute("x", x); label.setAttribute("y", height + margin.bottom / 2); label.setAttribute("dy", "0.71em"); label.setAttribute("class", "chart-text axis-label-x"); if (index === filteredData.length - 1) label.style.textAnchor = "end"; else if (index === 0) label.style.textAnchor = "start"; label.textContent = formatDateLabel(date); g.appendChild(label); });
                 const linePath = document.createElementNS(svgNS, "path"); const pathData = filteredData.map((d, i) => { const x = xScale(d.date); const y = yScale(d.intensity); return `${i === 0 ? 'M' : 'L'} ${x.toFixed(2)} ${y.toFixed(2)}`; }).join(" "); linePath.setAttribute("d", pathData); linePath.setAttribute("class", "chart-line"); g.appendChild(linePath);
                 filteredData.forEach(d => { const x = xScale(d.date); const y = yScale(d.intensity); const point = document.createElementNS(svgNS, "circle"); point.setAttribute("cx", x); point.setAttribute("cy", y); point.setAttribute("r", 4); point.setAttribute("class", "chart-point"); const title = document.createElementNS(svgNS, "title"); const pointDate = new Date(d.date); title.textContent = `${pointDate.toLocaleDateString('fr-FR')} ${pointDate.toLocaleTimeString('fr-FR',{hour:'2-digit', minute:'2-digit'})} - Intensité: ${d.intensity}`; point.appendChild(title); g.appendChild(point); });
                 container.appendChild(svg);
             }
             function cleanupTrackingPage() { /* ... identique ... */
                 const form = document.getElementById('tracking-form'); const clearDataBtn = document.getElementById('clear-data-btn'); const exportJsonBtn = document.getElementById('export-data-btn'); const exportCsvBtn = document.getElementById('export-csv-btn'); const historyLimitSelect = document.getElementById('history-limit'); const chartLimitSelect = document.getElementById('chart-limit');
                 form?.removeEventListener('submit', handleTrackingSubmit); clearDataBtn?.removeEventListener('click', handleClearData); exportJsonBtn?.removeEventListener('click', handleExportJson); exportCsvBtn?.removeEventListener('click', handleExportCsv); historyLimitSelect?.removeEventListener('change', updateTrackingDisplay); chartLimitSelect?.removeEventListener('change', updateTrackingDisplay);
                 const container = document.getElementById('tracking-chart'); if (container) container.innerHTML = ''; console.log("Cleanup Suivi");
             }

             // Page Ressources
             function initResourcesPage() { /* Rien */ }
             function cleanupResourcesPage() { /* Rien */ }


            // --- Initialisation Générale ---
             function initThemeToggle() { /* ... identique ... */
                const toggleButton = document.getElementById('theme-toggle');
                if (toggleButton) {
                    toggleButton.addEventListener('click', () => { const currentTheme = Store.getThemePreference(); const newTheme = currentTheme === 'dark' ? 'light' : 'dark'; Store.updateThemePreference(newTheme); Store.applyThemePreference(); });
                    Store.applyThemePreference(); // Appliquer thème initial
                }
             }

            // --- DÉMARRAGE DE L'APPLICATION ---
            Router.init(); // Initialise le routage, l'audio, le thème, et le padding dynamique
            console.log("Acouphènes Zen App Ready v1.0.");

        }); // Fin de DOMContentLoaded
    </script>
</body>
</html>
